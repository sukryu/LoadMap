/*
 * main.c
 *
 * 이 파일은 우리가 구현한 다양한 기법들에서 공간 복잡도를 최적화하는 방법들을 보여주는 예제 함수들을 포함합니다.
 * 주요 공간 최적화 기법:
 *   1. in-place 알고리즘: 추가 메모리 없이 입력 데이터 자체를 수정
 *   2. 동적 계획법(DP)의 공간 최적화: 전체 DP 테이블 대신 Rolling Array(슬라이딩 배열) 사용
 *   3. 불필요한 배열/메모리 재할당 최소화: 포인터와 변수 재사용
 *
 * 포함된 함수 목록:
 *   - fibonacciOptimized: 피보나치 수열을 O(1) 공간 복잡도로 계산 (in-place 업데이트)
 *   - minPathSumOptimized: 2차원 격자에서 최소 경로 합을 구할 때, 2차원 DP 테이블 대신 1차원 배열(롤링 배열)을 사용
 *   - removeDuplicatesInPlace: 정렬된 배열에서 추가 메모리 없이 중복 원소를 제거 (in-place 방식)
 *
 * 주석을 매우 상세하게 작성하여, 코드만 보더라도 각 기법의 공간 최적화 전략과 시간/공간 복잡도를 쉽게 이해할 수 있도록 구성했습니다.
 *
 * 참고: 이 파일에는 main 함수는 포함되어 있지 않습니다. 별도의 테스트 코드나 main 함수를 작성하여 각 함수를 호출하고 검증할 수 있습니다.
 */

#include <stdio.h>
#include <stdlib.h>

/*
 * 함수: fibonacciOptimized
 * --------------------------
 * 설명:
 *   피보나치 수열의 n번째 항을 계산하는 함수입니다.
 *   일반적인 DP 방식은 배열에 모든 중간 결과를 저장하지만, 
 *   이 함수는 최근 두 개의 값만을 사용하여 O(1) 추가 공간으로 계산합니다.
 *
 * 매개변수:
 *   - n: 계산하고자 하는 피보나치 수열의 항 번호 (0 기반, 예: n = 0이면 0, n = 1이면 1)
 *
 * 반환값:
 *   n번째 피보나치 수를 반환합니다.
 *
 * 시간 복잡도: O(n)
 * 공간 복잡도: O(1)
 */
int fibonacciOptimized(int n) {
    if (n <= 1)
        return n;

    // a, b는 이전 두 피보나치 수를 저장 (a = F(n-2), b = F(n-1))
    int a = 0, b = 1;
    for (int i = 2; i <= n; i++) {
        int temp = a + b; // 현재 항: F(n) = F(n-1) + F(n-2)
        a = b;            // 이전 항 업데이트: a <- F(n-1)
        b = temp;         // 현재 항 업데이트: b <- F(n)
    }
    return b;
}

/*
 * 함수: minPathSumOptimized
 * ---------------------------
 * 설명:
 *   2차원 격자(grid)에서 좌측 상단 (0, 0)부터 우측 하단 (rows-1, cols-1)까지 이동하며,
 *   경로상의 숫자 합의 최솟값을 구하는 문제를, 전체 2차원 DP 테이블 대신 1차원 배열(롤링 배열)을 사용하여 공간을 최적화합니다.
 *   이동은 오른쪽 또는 아래쪽으로만 가능하다고 가정합니다.
 *
 * 매개변수:
 *   - grid: 2차원 정수 배열 (격자)
 *   - rows: grid의 행의 개수
 *   - cols: grid의 열의 개수
 *
 * 반환값:
 *   좌측 상단부터 우측 하단까지 도달하는 최소 경로 합 (정수)
 *
 * 시간 복잡도: O(rows * cols)
 * 공간 복잡도: O(cols)
 *
 * 공간 최적화 아이디어:
 *   - 각 행의 DP 값은 바로 이전 행의 값만 필요하므로, 전체 행을 저장할 필요 없이 한 행만 갱신
 */
int minPathSumOptimized(int** grid, int rows, int cols) {
    // 1차원 배열 dp를 할당하여 현재 행의 최소 경로 합을 저장 (열 크기만큼 필요)
    int* dp = (int*)malloc(cols * sizeof(int));
    if (dp == NULL) return -1; // 메모리 할당 실패 시

    // 첫 행 초기화: 왼쪽에서 오른쪽으로 누적합 계산
    dp[0] = grid[0][0];
    for (int j = 1; j < cols; j++) {
        dp[j] = dp[j - 1] + grid[0][j];
    }

    // 각 행을 순회하며 dp 배열을 갱신
    for (int i = 1; i < rows; i++) {
        // 첫 열: 바로 위의 값과 현재 셀 값을 더함
        dp[0] = dp[0] + grid[i][0];
        // 나머지 열: 현재 셀을 포함하는 최소 경로 합은
        // 왼쪽(dp[j-1])과 위(dp[j]) 중 작은 값에 현재 값을 더한 값
        for (int j = 1; j < cols; j++) {
            int minPrev = (dp[j] < dp[j - 1]) ? dp[j] : dp[j - 1];
            dp[j] = grid[i][j] + minPrev;
        }
    }
    int result = dp[cols - 1];
    free(dp); // 동적 할당된 메모리 해제
    return result;
}

/*
 * 함수: removeDuplicatesInPlace
 * -------------------------------
 * 설명:
 *   정렬된 배열에서 중복 원소를 추가 메모리 없이 in-place로 제거합니다.
 *   이 방식은 두 포인터(느린 포인터와 빠른 포인터)를 사용하여 배열의 앞부분에 유일한 원소들을 재배치합니다.
 *
 * 매개변수:
 *   - arr: 정렬된 정수 배열
 *   - n: 배열의 원소 개수
 *
 * 반환값:
 *   중복 제거 후 유일한 원소의 개수를 반환합니다.
 *
 * 시간 복잡도: O(n)
 * 공간 복잡도: O(1)
 *
 * 공간 최적화 아이디어:
 *   - 별도의 배열을 사용하지 않고, 기존 배열 내부에서 인덱스만 조작하여 중복을 제거함
 */
int removeDuplicatesInPlace(int* arr, int n) {
    if (n == 0) return 0; // 빈 배열 처리

    int slow = 0; // 느린 포인터: 유일한 원소의 마지막 위치를 추적
    for (int fast = 1; fast < n; fast++) {
        if (arr[fast] != arr[slow]) {
            slow++;           // 새로운 유일 원소 위치로 이동
            arr[slow] = arr[fast]; // 빠른 포인터가 가리키는 값을 복사
        }
    }
    return slow + 1; // 유일한 원소의 수 (0 기반 인덱스이므로 +1)
}

/*
 * End of main.c
 *
 * 이 파일은 다양한 알고리즘 기법에서 공간 복잡도를 최적화하는 방법들을 예제 코드로 구현한 것입니다.
 *
 * 제공된 함수들은 다음과 같은 최적화 전략을 보여줍니다:
 *   - 피보나치 수열 계산에서 O(n) 배열 대신 두 변수만을 사용하여 O(1) 공간 복잡도 달성
 *   - 2차원 최소 경로 합 문제에서 전체 DP 테이블 대신 1차원 롤링 배열을 사용하여 공간 최적화
 *   - 정렬된 배열에서 in-place 중복 제거를 통해 추가 메모리 없이 문제 해결
 *
 * 각 함수에는 상세한 주석을 통해 사용된 기법과 공간/시간 복잡도에 대한 설명이 포함되어 있으므로,
 * 코드만 보더라도 쉽게 이해할 수 있습니다.
 *
 * 참고: main 함수는 포함되어 있지 않으므로, 별도의 테스트 코드나 main 함수를 작성하여
 *        이 함수들을 호출하고 검증할 수 있습니다.
 */
