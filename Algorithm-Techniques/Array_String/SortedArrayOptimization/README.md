# 정렬된 배열에서의 최적화

정렬된 배열은 이미 정렬된 상태라는 고유한 특성을 활용하여 다양한 알고리즘 최적화를 적용할 수 있는 매우 유용한 데이터 구조입니다. 이 문서에서는 정렬된 배열을 효과적으로 다루기 위한 여러 가지 최적화 기법들을 상세하게 설명합니다.

---

## 1. 기본 원리 및 이점

- **정렬된 배열의 특성:**  
  배열이 정렬되어 있다는 사실은 특정 값의 검색, 범위 탐색, 중복 처리 등에서 큰 장점을 제공합니다.

- **주요 이점:**  
  - **빠른 검색:** 이진 탐색(Binary Search)을 통해 O(log n) 시간 복잡도로 원하는 값을 찾을 수 있습니다.
  - **효율적인 범위 처리:** 정렬된 상태에서는 두 포인터 기법(Two Pointers)이나 슬라이딩 윈도우(Sliding Window)와 같은 기법을 쉽게 적용할 수 있습니다.
  - **중복 제거 최적화:** 인접한 값이 동일한 특성을 활용하여 in-place로 중복 원소를 제거할 수 있습니다.

---

## 2. 이진 탐색 (Binary Search)

- **개념:**  
  정렬된 배열에서 특정 값이나 조건에 맞는 원소의 위치를 찾기 위한 대표적인 알고리즘입니다.
  
- **주요 응용:**  
  - **값 존재 여부 검사:** 배열 내에 특정 값이 있는지 확인
  - **범위 탐색:** lower_bound, upper_bound를 사용하여 특정 값 이상의 첫 위치나 이하의 마지막 위치를 찾기
  
- **시간 복잡도:**  
  O(log n)

### 예시: 이진 탐색 의사코드

```
function binarySearch(arr, target):
    low = 0
    high = length(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        else if arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1  // target이 존재하지 않는 경우
```

---

## 3. 투 포인터 기법 (Two Pointers)

- **개념:**  
  정렬된 배열에서 두 개의 포인터를 사용하여 조건에 맞는 원소의 쌍 또는 특정 합/차 등의 값을 효율적으로 찾는 방법입니다.
  
- **주요 응용:**  
  - **두 수의 합 문제:** 두 수의 합이 주어진 목표에 도달하는 쌍 찾기
  - **중복 제거:** 배열에서 중복 원소를 제거하고 유일한 값만 남기기 (in-place)
  
- **시간 복잡도:**  
  O(n)

---

## 4. 중복 제거 (Removing Duplicates)

- **개념:**  
  정렬된 배열에서는 동일한 값이 연속하여 나타나므로, 단일 패스를 통해 중복 원소를 효율적으로 제거할 수 있습니다.
  
- **주요 응용:**  
  - **in-place 중복 제거:** 추가적인 공간 사용 없이 배열 내에서 중복을 제거하고, 유일한 원소들로 배열을 재구성
  
- **시간 복잡도:**  
  O(n)

---

## 5. 병합 알고리즘 (Merging Sorted Arrays)

- **개념:**  
  두 개 이상의 정렬된 배열을 하나의 정렬된 배열로 병합할 때, 각 배열의 포인터를 활용하여 순차적으로 비교하면서 병합합니다.
  
- **주요 응용:**  
  - **병합 정렬(Merge Sort)의 병합 단계:** 여러 정렬된 리스트를 효율적으로 합치는 과정
  - **다중 배열의 통합:** 여러 데이터 소스를 하나로 통합할 때 유용
  
- **시간 복잡도:**  
  O(n + m) (두 배열의 길이가 각각 n과 m일 때)

---

## 6. 기타 최적화 기법 및 고려사항

- **슬라이딩 윈도우와의 결합:**  
  정렬된 배열에서 특정 범위의 합이나 조건을 빠르게 판별할 때 슬라이딩 윈도우 기법과 이진 탐색 또는 투 포인터 기법을 결합할 수 있습니다.

- **값 범위 기반 최적화:**  
  정렬 상태를 이용하여 특정 구간을 미리 판별하거나, 조건을 만족하지 않는 구간을 건너뛰는 최적화도 고려할 수 있습니다.

- **시간/공간 복잡도 고려:**  
  대부분의 기법은 추가적인 메모리 사용 없이 정렬 상태를 활용하지만, 이진 탐색 및 두 포인터 알고리즘은 특히 대규모 데이터에서 높은 효율성을 보입니다.

---

## 7. 결론

정렬된 배열은 그 자체로 최적화 기법을 적용할 수 있는 강력한 자료구조입니다.  
이 문서에서 소개한 이진 탐색, 투 포인터 기법, 중복 제거, 병합 알고리즘 등의 최적화 기법을 적절히 활용하면, 코딩 테스트나 실제 문제 해결 시 효율적이고 최적의 솔루션을 구현할 수 있습니다.

각 문제 유형에 따라 올바른 기법을 선택하여 적용하고, 시간 및 공간 복잡도를 항상 고려하면서 최적의 코드를 작성하시기 바랍니다.