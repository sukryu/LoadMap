# 특수 문자열 패턴 이론 정리

특수 문자열 패턴은 단순한 문자 나열을 넘어, 와일드카드, 반복, 조건부 패턴 등 다양한 규칙을 포함하는 문자열 패턴을 의미합니다.  
이 문서에서는 코딩 테스트에서 자주 등장하는 특수 문자열 패턴 문제의 개념, 알고리즘, 응용 방법 및 주의사항을 초보자도 쉽게 이해할 수 있도록 자세하게 설명합니다.

---

## 1. 개요

- **정의:**  
  특수 문자열 패턴은 일반적인 문자열과 달리 특정 규칙(예: 와일드카드 문자, 반복 규칙, 조건부 매칭)을 포함하여, 해당 규칙에 맞는 문자열을 판별하거나 찾는 문제를 다룹니다.

- **필요성:**  
  - **문제 해결:** 코딩 테스트에서 정규 표현식 매칭, 와일드카드 매칭, 패턴 분해 등의 문제로 자주 출제됩니다.  
  - **텍스트 처리:** 로그 분석, 데이터 필터링 등 실무에서도 사용되는 기법입니다.

- **응용 분야:**  
  - 정규 표현식(Regular Expression) 엔진 구현  
  - 와일드카드 패턴 매칭 (예: `?`, `*`를 포함한 패턴)  
  - 문자열 내 특정 패턴의 검색 (예: KMP 알고리즘, 보이어-무어 알고리즘)

---

## 2. 주요 개념

- **패턴 매칭:**  
  문자열 내에서 특정 패턴(규칙)을 찾거나, 해당 패턴과 문자열이 일치하는지 판단하는 문제

- **와일드카드 문자:**  
  - `?` : 임의의 한 문자와 매칭  
  - `*` : 0개 이상의 문자를 매칭  
  이러한 문자를 포함한 패턴 매칭 문제는 동적 계획법(DP)이나 백트래킹 기법으로 해결할 수 있습니다.

- **정규 표현식 매칭:**  
  패턴에 특정 반복이나 선택적 요소(예: `a*`, `a|b`)가 포함될 때, NFA(비결정적 유한 오토마타)나 DP를 활용하여 문자열이 패턴과 일치하는지 판단합니다.

- **패턴 검색 알고리즘:**  
  - **KMP 알고리즘:** 부분 일치를 이용하여 검색 시간을 O(n)으로 줄입니다.  
  - **보이어-무어 알고리즘:** 불일치 발생 시 여러 문자를 한 번에 건너뛰어 효율적인 검색을 도모합니다.  
  - **라빈-카프 알고리즘:** 해시 함수를 사용하여 여러 패턴을 빠르게 검색합니다.

---

## 3. 알고리즘 및 기법

### 3.1 와일드카드 매칭 (Wildcard Matching)

- **문제 예시:**  
  문자열 `s`와 패턴 `p`가 주어질 때, `p`에 포함된 `?`와 `*`를 해석하여 `s`와 매칭되는지 판별하는 문제  
- **기법:**  
  - **동적 계획법(DP):**  
    DP 테이블을 구성하여 `dp[i][j]`를 "s의 처음 i글자와 p의 처음 j글자가 매칭되는가"로 정의  
    - **점화식:**  
      - `p[j-1] == s[i-1]` 또는 `p[j-1] == '?'` → `dp[i][j] = dp[i-1][j-1]`  
      - `p[j-1] == '*'` → `dp[i][j] = dp[i][j-1] || dp[i-1][j]`  
  - **백트래킹:** 재귀 호출을 통해 가능한 매칭 경우를 모두 탐색 (일반적으로 비효율적일 수 있음)

- **시간 복잡도:**  
  DP를 사용하면 O(m*n) (m: 문자열 길이, n: 패턴 길이)

### 3.2 정규 표현식 매칭 (Regular Expression Matching)

- **문제 예시:**  
  패턴 내 `.`(임의의 단일 문자)와 `*`(앞 문자가 0번 이상 반복)를 포함하는 매칭 문제  
- **기법:**  
  - **동적 계획법(DP):**  
    `dp[i][j]`를 "s의 처음 i글자와 p의 처음 j글자가 매칭되는가"로 정의하여 재귀적 관계 설정  
    - **점화식:**  
      - 일반 문자 또는 `.`는 직접 비교  
      - `*`의 경우, 0회 사용 또는 1회 이상 사용에 따른 경우 분리 처리

- **시간 복잡도:**  
  O(m*n)

### 3.3 패턴 검색 (Substring Search)

- **KMP 알고리즘:**  
  - 패턴의 부분 일치 테이블(파이 함수)을 사전 계산하여, 문자열 내에서 패턴이 시작되는 인덱스를 빠르게 찾음  
  - 시간 복잡도: O(n + m)
- **보이어-무어 알고리즘:**  
  - 불일치 발생 시 패턴을 한 번에 여러 칸 이동하여 검색 효율을 높임

아래는 **“Longest Palindromic Substring(가장 긴 팰린드롬 부분 문자열)”** 문제를 **특수 문자열 패턴**의 한 사례로 추가한 내용입니다.  
기존 문서의 구조를 유지하면서, `3. 알고리즘 및 기법` 섹션에 **3.4 팰린드롬(회문) 관련 알고리즘**을 새로 추가했습니다.

---

### 3.4 팰린드롬(회문) 관련 알고리즘

#### 문제 예시

- **Longest Palindromic Substring(가장 긴 팰린드롬 부분 문자열):**  
  주어진 문자열에서, 앞뒤가 동일하게 읽히는 가장 긴 연속된 부분 문자열(회문)의 길이나 실제 부분 문자열을 찾는 문제  
  *예시:*  
  - 입력: `"babad"` → 가능한 답: `"bab"` 또는 `"aba"`  
  - 입력: `"cbbd"` → 답: `"bb"`

#### 기법

##### (1) 중심 확장(Expand Around Center)

- **개념:**  
  부분 문자열의 “중심점”을 잡고, 양쪽으로 동시에 확장하면서 팰린드롬인지 확인하는 기법  
  - 홀수 길이 팰린드롬: 한 문자(i)를 중심으로 확장  
  - 짝수 길이 팰린드롬: 두 문자(i, i+1) 사이를 중심으로 확장

- **알고리즘 흐름:**  
  1. 문자열의 각 인덱스 i(0 ~ n-1)에 대하여,  
     - (a) i를 중심으로 확장  
     - (b) i와 i+1 사이를 중심으로 확장  
  2. 확장 가능한 최대 범위까지 양쪽 문자가 같은지 비교  
  3. 최대 길이를 갱신해 가며 가장 긴 팰린드롬 부분 문자열을 찾는다.

- **시간 복잡도:** O(n^2)  
  (각 인덱스를 중심으로 최악의 경우 최대 O(n) 확장)

##### (2) 동적 계획법(DP)

- **개념:**  
  2차원 DP 테이블을 활용하여, 구간 [i, j]가 팰린드롬인지 여부를 저장

- **알고리즘 흐름:**  
  1. 길이가 1인 부분 문자열(단일 문자)은 무조건 팰린드롬  
  2. 길이가 2인 경우, 두 문자가 같으면 팰린드롬  
  3. 길이가 3 이상인 경우, s[i] == s[j]이고 내부 구간 [i+1, j-1]이 팰린드롬이면 [i, j]도 팰린드롬  
  4. 모든 i, j에 대해 팰린드롬 여부를 구하며, 가장 긴 구간을 갱신

- **시간 복잡도:** O(n^2), 공간 복잡도: O(n^2)

##### (3) Manacher 알고리즘

- **개념:**  
  팰린드롬을 O(n) 시간에 찾기 위한 특수 알고리즘. 문자열 사이사이에 구분자를 삽입하고, 현재까지의 팰린드롬 범위 정보를 재활용(거울 인덱스)하여 확장 시간을 줄인다.

- **알고리즘 흐름(개략):**  
  1. 문자열을 전처리(예: 각 문자 사이에 `#` 삽입)하여 홀/짝수 팰린드롬 처리를 통합  
  2. 보조 배열 p[i]에 “중심 i에서의 팰린드롬 반경”을 저장  
  3. 현재까지의 최대 팰린드롬 구간 [center - radius, center + radius]를 유지하면서, 새로운 인덱스 i가 이 구간 내부에 있으면, i의 거울 인덱스 mirror = 2*center - i 정보를 활용  
  4. 최소 필요 범위만큼 확장한 뒤, 추가로 (i - p[i] - 1)과 (i + p[i] + 1)이 같은지 확인하며 확장  
  5. 최대 반경을 업데이트하며 전체 과정 O(n)에 완료

- **시간 복잡도:** O(n)

---

#### 시간 및 공간 복잡도

- **중심 확장, DP:** O(n^2) 시간  
- **Manacher:** O(n) 시간


- [펠린드롬(회문) 관련 알고리즘 바로가기](main.cpp)
- [나머지 알고리즘 바로가기](main.c)
---

## 4. 문제 유형 및 응용 예시

- **와일드카드/정규 표현식 매칭 문제:**  
  패턴 내 특수 문자를 해석하여 문자열이 매칭되는지 판단하는 문제  
  *예시:* LeetCode의 "Wildcard Matching", "Regular Expression Matching"

- **특정 패턴 검색:**  
  문자열 내에서 특정 하위 패턴의 존재 여부나 위치를 찾는 문제  
  *예시:* KMP, 보이어-무어를 이용한 검색

- **패턴 분해 및 분석:**  
  주어진 문자열을 패턴에 따라 분해하거나 재구성하는 문제  
  *예시:* 압축 문자열 해제, 패턴에 따른 문자열 변환

---

## 5. 시간 및 공간 복잡도 고려

- **동적 계획법 기반 매칭:**  
  - 시간 복잡도: O(m*n)  
  - 공간 복잡도: O(m*n) (메모이제이션 배열 사용)
- **KMP 알고리즘:**  
  - 시간 복잡도: O(n + m)  
  - 공간 복잡도: O(m) (부분 일치 테이블)
- **보이어-무어 및 라빈-카프:**  
  - 최적의 경우 더 빠른 검색 가능, 최악의 경우에도 효율적

---

## 6. 주의사항 및 팁

- **경계 조건:**  
  - 빈 문자열 및 빈 패턴 처리  
  - 패턴의 시작과 끝에 특수 문자가 위치할 경우에 대한 처리

- **반복 및 중복 계산 최소화:**  
  DP를 사용할 경우, 불필요한 중복 계산을 피하기 위해 캐싱을 철저히 수행

- **메모리 사용:**  
  DP 배열이나 부분 일치 테이블 등의 추가 메모리 사용에 유의

- **알고리즘 선택:**  
  문제의 크기와 특성에 따라 적절한 알고리즘(예: KMP vs DP)을 선택하는 것이 중요함

---

## 7. 결론

특수 문자열 패턴 문제는 단순한 문자열 비교를 넘어서, 와일드카드, 정규 표현식, 반복 규칙 등 다양한 조건을 포함합니다.  
- **핵심:**  
  문제의 규칙을 명확히 파악하고, 적절한 알고리즘(DP, KMP, 보이어-무어 등)을 선택하는 것이 중요합니다.  
- **응용:**  
  텍스트 검색, 로그 분석, 데이터 필터링 등 실무에서도 많이 활용됩니다.

이 문서를 통해 특수 문자열 패턴에 대한 기본 개념과 여러 알고리즘 기법을 이해하고, 코딩 테스트 및 실제 문제 해결에 효과적으로 활용하시길 바랍니다.
