/*
 * main.c
 *
 * 이 파일은 우리가 지금까지 구현한 기법들을 활용하여 시간 복잡도를 최적화하는 방법들을 보여주는 예제 함수들을 포함합니다.
 *
 * 시간 복잡도 최적화의 주요 전략:
 *   1. 불필요한 중복 계산을 줄이기 위해 메모이제이션(동적 계획법)을 사용
 *      - 예: 피보나치 수열의 재귀적 계산을 메모이제이션을 통해 O(2^n) → O(n)으로 개선
 *
 *   2. 전처리와 효율적인 알고리즘을 사용하여 반복적인 검색/매칭 시간을 단축
 *      - 예: KMP 알고리즘은 문자열 매칭을 O(n+m) 시간에 수행하여, 단순 반복문 기반 검색의 시간 복잡도를 획기적으로 낮춤
 *
 *   3. 문제의 특성에 맞는 알고리즘을 선택하여 전체 실행 시간을 줄임
 *      - 예: 이진 탐색, 분할 정복, 그리고 최적화된 동적 계획법 등을 적절히 활용
 *
 * 아래에 포함된 예제 함수들은 각 기법을 통한 시간 복잡도 최적화 방법을 상세한 주석과 함께 구현한 것입니다.
 *
 * 포함된 함수 목록:
 *   - fibonacciMemoized: 메모이제이션을 사용하여 피보나치 수열을 효율적으로 계산
 *   - kmpSearch: KMP 알고리즘을 사용하여 부분 문자열 검색을 최적화
 *   - minPathSumOptimized: 2차원 격자에서 최소 경로 합 문제를 1차원 롤링 배열을 사용해 시간 복잡도를 유지하면서 구현
 *
 * 참고: 이 파일에는 main 함수는 포함되어 있지 않으므로, 별도의 테스트 코드나 main 함수를 작성하여
 *        각 함수를 호출하고 결과를 검증할 수 있습니다.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//////////////////////////////////////////////
// 1. 피보나치 수열 (메모이제이션 최적화)  //
//////////////////////////////////////////////

/*
 * 함수: fibonacciMemoized
 * -------------------------
 * 설명:
 *   피보나치 수열의 n번째 항을 계산하는 함수입니다.
 *   전형적인 재귀적 접근 방식은 중복 계산으로 인해 시간 복잡도가 O(2^n)입니다.
 *   이 함수는 메모이제이션(동적 계획법)을 사용하여 계산한 값을 캐시에 저장함으로써
 *   중복 계산을 제거하고, 시간 복잡도를 O(n)으로 최적화합니다.
 *
 * 매개변수:
 *   - n: 계산하고자 하는 피보나치 수열의 항 번호 (0 기반, 예: n = 0이면 0, n = 1이면 1)
 *   - memo: n번째 항의 결과를 저장하는 배열. 미리 -1로 초기화되어 있어야 합니다.
 *
 * 반환값:
 *   n번째 피보나치 수를 반환합니다.
 *
 * 시간 복잡도: O(n) – 각 항을 한 번씩만 계산
 * 공간 복잡도: O(n) – 결과를 저장하는 캐시 배열 사용
 */
int fibonacciMemoized(int n, int* memo) {
    if (n <= 1)
        return n;
    // 이미 계산된 값이 있으면 반환
    if (memo[n] != -1)
        return memo[n];
    // 재귀 호출과 메모이제이션을 통해 계산
    memo[n] = fibonacciMemoized(n - 1, memo) + fibonacciMemoized(n - 2, memo);
    return memo[n];
}

/*
 * 함수: initFibonacciMemo
 * -------------------------
 * 설명:
 *   fibonacciMemoized 함수를 호출하기 전에, 캐시 배열(memo)을 초기화합니다.
 *   배열의 모든 원소를 -1로 설정하여 아직 계산되지 않았음을 표시합니다.
 *
 * 매개변수:
 *   - n: 피보나치 수열 계산에 필요한 최대 항 번호
 *
 * 반환값:
 *   - 초기화된 캐시 배열 포인터 (caller는 사용 후 free()로 메모리 해제 필요)
 */
int* initFibonacciMemo(int n) {
    int* memo = (int*)malloc((n + 1) * sizeof(int));
    if (!memo)
        return NULL;
    for (int i = 0; i <= n; i++) {
        memo[i] = -1;
    }
    return memo;
}

//////////////////////////////////////////////
// 2. 문자열 매칭 (KMP 알고리즘 최적화)      //
//////////////////////////////////////////////

/*
 * 함수: computeLPS
 * -------------------
 * 설명:
 *   KMP 알고리즘에서 사용되는 LPS (Longest Prefix Suffix) 배열을 계산합니다.
 *   LPS 배열은 패턴의 각 인덱스에서 접두사와 접미사가 일치하는 최대 길이를 저장하여,
 *   매칭 실패 시 건너뛸 인덱스를 빠르게 결정하는 데 사용됩니다.
 *
 * 매개변수:
 *   - pattern: 검색할 패턴 문자열 (null 종료)
 *   - m: 패턴의 길이
 *
 * 반환값:
 *   동적 할당된 LPS 배열의 포인터 (caller가 free()로 메모리 해제 필요)
 *
 * 시간 복잡도: O(m)
 * 공간 복잡도: O(m)
 */
int* computeLPS(const char* pattern, int m) {
    int* lps = (int*)malloc(m * sizeof(int));
    if (!lps)
        return NULL;
    lps[0] = 0; // 첫 번째 문자는 접두사-접미사 길이가 0
    int len = 0; // 이전 접두사-접미사 일치 길이
    int i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                // len을 이전에 계산된 lps[len-1]로 재조정하여 재검사
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

/*
 * 함수: kmpSearch
 * ------------------
 * 설명:
 *   KMP 알고리즘을 사용하여 텍스트(text) 내에서 패턴(pattern)이 처음 등장하는 위치를 찾습니다.
 *   LPS 배열을 미리 계산하여, 매칭 실패 시 불필요한 반복 검사를 줄임으로써 전체 시간 복잡도를 O(n + m)으로 최적화합니다.
 *
 * 매개변수:
 *   - text: 검색 대상 텍스트 문자열 (null 종료)
 *   - pattern: 검색할 패턴 문자열 (null 종료)
 *
 * 반환값:
 *   패턴이 처음 등장하는 0 기반 인덱스를 반환하며, 패턴이 없으면 -1을 반환합니다.
 *
 * 시간 복잡도: O(n + m)
 * 공간 복잡도: O(m) – LPS 배열 사용
 */
int kmpSearch(const char* text, const char* pattern) {
    int n = strlen(text);
    int m = strlen(pattern);
    if (m == 0)
        return 0; // 빈 패턴은 항상 매칭됨

    int* lps = computeLPS(pattern, m);
    if (!lps)
        return -1; // 메모리 할당 실패

    int i = 0; // 텍스트 인덱스
    int j = 0; // 패턴 인덱스

    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        }
        if (j == m) {
            // 전체 패턴이 매칭되었음: 매칭 시작 인덱스는 i - j
            free(lps);
            return i - j;
        } else if (i < n && text[i] != pattern[j]) {
            // 불일치 발생 시, j를 lps[j-1]로 이동 (가능한 건너뛰기)
            if (j != 0)
                j = lps[j - 1];
            else
                i++;
        }
    }
    free(lps);
    return -1; // 패턴을 찾지 못함
}

//////////////////////////////////////////////
// 3. 2차원 최소 경로 합 (DP 최적화: 롤링 배열) //
//////////////////////////////////////////////

/*
 * 함수: minPathSumOptimized
 * ---------------------------
 * 설명:
 *   2차원 격자(grid)에서 좌측 상단 (0, 0)부터 우측 하단 (rows-1, cols-1)까지 이동하며,
 *   경로상의 숫자 합의 최솟값을 구하는 문제를 풀기 위해,
 *   전체 2차원 DP 테이블 대신 1차원 롤링 배열을 사용하여 공간 복잡도를 최적화합니다.
 *   이동은 오른쪽 또는 아래쪽으로만 가능하다고 가정합니다.
 *
 * 매개변수:
 *   - grid: 2차원 정수 배열 (격자)
 *   - rows: grid의 행의 개수
 *   - cols: grid의 열의 개수
 *
 * 반환값:
 *   좌측 상단부터 우측 하단까지 도달하는 최소 경로 합 (정수)
 *
 * 시간 복잡도: O(rows * cols)
 * 공간 복잡도: O(cols) – 1차원 배열만 사용
 *
 * 공간 최적화 아이디어:
 *   - 각 행의 DP 값은 바로 이전 행의 값만 필요하므로 전체 2차원 배열 대신 1차원 배열을 사용
 */
int minPathSumOptimized(int** grid, int rows, int cols) {
    // 열의 개수만큼 1차원 배열 dp 할당
    int* dp = (int*)malloc(cols * sizeof(int));
    if (dp == NULL)
        return -1; // 메모리 할당 실패

    // 첫 행 초기화: 첫 셀부터 오른쪽으로 누적합 계산
    dp[0] = grid[0][0];
    for (int j = 1; j < cols; j++) {
        dp[j] = dp[j - 1] + grid[0][j];
    }

    // 각 행마다 dp 배열 갱신
    for (int i = 1; i < rows; i++) {
        // 첫 열은 위쪽 값과 현재 셀 값을 더함
        dp[0] = dp[0] + grid[i][0];
        for (int j = 1; j < cols; j++) {
            // 현재 셀의 최소 경로 합은 위쪽(dp[j])과 왼쪽(dp[j-1]) 중 작은 값에 현재 값을 더한 값
            int minPrev = (dp[j] < dp[j - 1]) ? dp[j] : dp[j - 1];
            dp[j] = grid[i][j] + minPrev;
        }
    }
    int result = dp[cols - 1];
    free(dp);
    return result;
}

/*
 * End of main.c
 *
 * 이 파일은 다양한 기법들을 통해 시간 복잡도를 최적화하는 방법을 보여주는 예제 함수들을 포함합니다.
 *
 * 포함된 최적화 기법:
 *   - 메모이제이션을 활용한 피보나치 수열 계산: 중복 계산 제거 (시간 복잡도 O(n))
 *   - KMP 알고리즘을 통한 문자열 매칭: 전처리(LPS 배열)를 이용하여 O(n + m) 시간 복잡도 달성
 *   - 2차원 최소 경로 합 문제에서 1차원 롤링 배열을 사용하여 공간을 절약하면서 시간 복잡도를 유지
 *
 * 각 함수는 상세한 주석과 함께 구현되어 있으므로, 코드만 보더라도 최적화 기법의 원리와 시간/공간 복잡도를 쉽게 이해할 수 있습니다.
 *
 * 참고: main 함수는 포함되어 있지 않으므로, 별도의 테스트 코드나 main 함수를 작성하여
 *        이 함수들을 호출하고 검증할 수 있습니다.
 */
