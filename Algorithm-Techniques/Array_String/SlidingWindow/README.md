# 슬라이딩 윈도우 기법 이론 정리

슬라이딩 윈도우(Sliding Window) 기법은 배열이나 문자열과 같이 연속된 구간(subarray, substring)을 다루는 문제에서 매우 유용하게 사용되는 알고리즘 기법입니다. 이 문서에서는 슬라이딩 윈도우 기법의 기본 개념, 동작 원리, 다양한 응용 사례와 주의사항 등을 초보자도 이해할 수 있도록 자세하게 정리합니다.

---

## 1. 슬라이딩 윈도우 기법이란?

- **기본 개념:**  
  슬라이딩 윈도우 기법은 연속된 구간 내에서 어떤 조건을 만족하는 값을 효율적으로 계산하기 위해, 고정 또는 가변 길이의 윈도우(부분 구간)를 이용하여 데이터를 순회하는 방법입니다.

- **핵심 아이디어:**  
  전체 배열이나 문자열을 한 번 순회하면서, 현재 윈도우에 포함된 값들을 기반으로 원하는 결과(합, 평균, 최대/최소값 등)를 빠르게 갱신합니다. 이를 통해 이중 반복문으로 해결되는 문제를 선형 시간(O(n))에 해결할 수 있습니다.

---

## 2. 슬라이딩 윈도우의 종류

- **고정 길이 윈도우 (Fixed Window):**  
  윈도우의 크기가 미리 정해져 있는 경우 사용합니다.  
  *예시:* 길이가 `K`인 부분 배열의 합 또는 평균 계산.

- **가변 길이 윈도우 (Variable Window):**  
  문제 조건에 따라 윈도우의 크기가 동적으로 변경되는 경우 사용합니다.  
  *예시:* 연속된 부분 배열의 합이 특정 값 이상이 되는 최소 또는 최대 길이 찾기.

---

## 3. 슬라이딩 윈도우 기법의 동작 원리

1. **초기화:**  
   - 윈도우의 시작점과 끝점을 나타내는 포인터(예: `left`와 `right`)를 초기화합니다.
   - 윈도우에 포함된 데이터를 기반으로 하는 상태 변수(예: 합, 카운트 등)를 초기화합니다.

2. **윈도우 확장:**  
   - `right` 포인터를 이동시켜 윈도우에 새로운 원소를 추가합니다.
   - 추가된 원소에 따라 상태 변수를 업데이트합니다.

3. **조건 검사 및 윈도우 축소:**  
   - 윈도우의 상태(예: 합)가 문제의 조건을 만족하는 경우, `left` 포인터를 이동시켜 윈도우의 크기를 축소하며 조건을 유지할 수 있는지 확인합니다.
   - 이 과정에서 최적의 결과(예: 최소 길이, 최대 값 등)를 갱신합니다.

4. **반복:**  
   - 위 과정을 배열 또는 문자열의 끝까지 반복하며 최종 결과를 도출합니다.

---

## 4. 대표적인 문제 유형 및 응용 예시

### 4.1 고정 길이 윈도우 문제

- **문제 예시:**  
  "길이가 `K`인 부분 배열 중 합이 최대인 값을 찾기"
  
- **해결 방법:**  
  1. 초기 윈도우의 합을 계산합니다.
  2. 윈도우를 오른쪽으로 한 칸씩 이동하며, 이전 원소는 빼고 새로운 원소는 더해 윈도우의 합을 갱신합니다.
  3. 매 이동마다 최대값을 업데이트합니다.
  
- **시간 복잡도:** O(n)

### 4.2 가변 길이 윈도우 문제

- **문제 예시:**  
  "연속된 부분 배열의 합이 `target` 이상이 되는 최소 길이를 찾기"
  
- **해결 방법:**  
  1. `right` 포인터를 이동시키며 윈도우의 합을 증가시킵니다.
  2. 윈도우의 합이 `target` 이상이면, `left` 포인터를 이동시키며 조건을 만족하는 최소 길이를 갱신합니다.
  
- **시간 복잡도:** O(n)  
  (각 포인터는 최대 한 번씩 이동하므로)

### 4.3 문자열 관련 문제

- **문제 예시:**  
  "중복 없는 가장 긴 부분 문자열 찾기"
  
- **해결 방법:**  
  1. 윈도우를 이용하여 현재 구간에 포함된 문자들을 해시 테이블이나 배열로 관리합니다.
  2. 중복 문자가 등장하면, `left` 포인터를 이동시켜 중복을 제거하고 윈도우의 길이를 조절합니다.
  
- **시간 복잡도:** O(n)

---

## 5. 슬라이딩 윈도우 기법 사용 시 주의사항

- **인덱스 범위 관리:**  
  윈도우를 이동할 때 배열이나 문자열의 범위를 벗어나지 않도록 항상 조건문으로 확인해야 합니다.

- **상태 변수 업데이트:**  
  윈도우에 원소가 추가되거나 제거될 때, 관련 상태(합, 최대/최소 값, 카운트 등)를 올바르게 업데이트해야 합니다.  
  예를 들어, 합을 계산할 경우 새 원소 추가 시 더하고, 윈도우 축소 시 해당 원소를 빼야 합니다.

- **종료 조건:**  
  `left`와 `right` 포인터의 이동 조건과 종료 조건을 명확하게 설정하여 무한 루프에 빠지지 않도록 주의합니다.

- **경계 조건 처리:**  
  특히 윈도우의 시작과 끝 부분에서 발생할 수 있는 예외 상황(예: 빈 배열 처리, 윈도우 크기가 배열 전체보다 큰 경우 등)을 꼼꼼하게 처리해야 합니다.

- **불필요한 계산 최소화:**  
  윈도우 이동 시 중복 계산을 줄이기 위해 상태 변수를 적절히 활용하여 효율성을 극대화합니다.

---

## 6. 예제 코드 (의사코드)

### 6.1 고정 길이 슬라이딩 윈도우: 최대 부분 배열 합 구하기

```
function maxFixedWindowSum(arr, k):
    if length(arr) < k:
        return -1  // 배열의 길이가 윈도우 크기보다 작으면 오류 처리
    currentSum = sum(arr[0:k])  // 초기 윈도우 합 계산
    maxSum = currentSum
    for i from k to length(arr) - 1:
        // 윈도우를 오른쪽으로 한 칸 이동:
        // 새 원소 추가하고, 윈도우에서 가장 왼쪽 원소 제거
        currentSum = currentSum + arr[i] - arr[i - k]
        maxSum = max(maxSum, currentSum)
    return maxSum
```

### 6.2 가변 길이 슬라이딩 윈도우: 최소 길이 부분 배열 구하기

```
function minSubarrayLength(arr, target):
    n = length(arr)
    minLength = n + 1  // 최대 길이보다 큰 값으로 초기화
    currentSum = 0
    left = 0
    for right from 0 to n - 1:
        currentSum += arr[right]  // 윈도우에 새 원소 추가
        while currentSum >= target:
            // 조건을 만족하면 현재 윈도우의 길이를 갱신
            minLength = min(minLength, right - left + 1)
            currentSum -= arr[left]  // 윈도우에서 가장 왼쪽 원소 제거
            left += 1  // 윈도우 축소
    return (minLength == n + 1) ? 0 : minLength  // 조건을 만족하는 부분 배열이 없으면 0 반환
```

---

## 7. 결론

슬라이딩 윈도우 기법은 연속된 구간의 데이터를 효율적으로 처리할 수 있도록 도와주는 강력한 알고리즘 도구입니다.  
초보자는 고정 길이 문제부터 연습을 시작하고, 점차 가변 길이 문제로 난이도를 높여가며 다양한 문제에 적용해 보는 것이 좋습니다.  
문제의 조건에 맞춰 윈도우의 확장 및 축소를 올바르게 관리하고, 상태 변수를 꼼꼼히 업데이트하는 습관이 성공적인 문제 해결의 열쇠입니다.

이 문서를 통해 슬라이딩 윈도우 기법의 기본 원리와 다양한 응용 방법을 충분히 이해하고, 코딩 테스트 및 실전 문제 해결에 효과적으로 활용하시길 바랍니다.