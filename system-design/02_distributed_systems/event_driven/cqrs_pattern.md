# CQRS (Command Query Responsibility Segregation)

> **목표:**  
> - CQRS 패턴의 기본 개념과 핵심 원리를 이해한다.  
> - 명령(Command)과 조회(Query)를 분리하여 시스템의 복잡도를 낮추고, 성능을 최적화하는 방법을 학습한다.  
> - 이벤트 소싱과 결합한 CQRS 적용 사례 및 실무 전략을 연구한다.

---

## 1. 개념 개요

> **CQRS는 데이터 변경(명령)과 데이터 조회(쿼리)를 별도의 모델로 분리하여 처리함으로써, 복잡한 도메인 로직을 단순화하고 성능과 확장성을 향상시키는 아키텍처 패턴이다.**

- **정의:**  
  - CQRS 패턴은 하나의 모델(모놀리식 CRUD 방식) 대신, 명령(Command)과 조회(Query) 책임을 분리하여 각각 독립적으로 최적화된 데이터 모델을 사용합니다.
  - 명령 모델은 데이터 변경에 집중하며, 조회 모델은 빠른 응답과 확장성을 위해 읽기 전용으로 최적화됩니다.

- **왜 중요한가?**  
  - **복잡한 도메인 로직 처리:** 도메인 로직이 복잡한 시스템에서 쓰기와 읽기 요구사항이 다를 경우, 각 모델을 분리하여 설계하면 유지보수와 확장이 용이합니다.
  - **성능 최적화:** 읽기와 쓰기를 별도로 최적화할 수 있으므로, 읽기 부하가 높은 시스템에서 높은 성능과 확장성을 달성할 수 있습니다.
  - **이벤트 소싱과의 결합:** 이벤트 소싱 패턴과 결합하면, 모든 상태 변경 이벤트를 기록하고 이를 기반으로 읽기 모델을 재구성할 수 있어 감사 및 복구 기능이 강화됩니다.

- **어떤 문제를 해결하는가?**  
  - 단일 데이터 모델로 읽기와 쓰기 요구사항을 동시에 만족시키려 할 때 발생하는 복잡성과 성능 저하 문제  
  - 트랜잭션 처리와 조회 성능 간의 상충 문제를 분리하여 각각 최적화할 수 있습니다.

---

## 2. 동작 원리 및 구성 요소

### 2.1 명령(Command) 모델
- **역할:**  
  - 데이터 변경 작업(쓰기)을 담당합니다.
  - 도메인 로직을 처리하며, 상태 변경 이벤트를 발생시키고, 필요시 이벤트 소싱과 연계하여 이벤트 로그에 기록합니다.
- **특징:**  
  - 쓰기 작업에 집중하므로, 복잡한 비즈니스 규칙을 적용하기 쉽습니다.
  - 트랜잭션 단위로 작업이 처리되며, 실패 시 롤백 또는 보상 트랜잭션을 통해 복구할 수 있습니다.

### 2.2 조회(Query) 모델
- **역할:**  
  - 데이터 조회(읽기) 작업을 전담합니다.
  - 읽기 전용 데이터 모델을 사용하여, 빠른 응답 시간과 높은 확장성을 보장합니다.
- **특징:**  
  - 명령 모델과는 별도로 최적화되어, 복잡한 조인 연산이나 대량의 데이터를 빠르게 제공할 수 있습니다.
  - 실시간 또는 배치 방식으로 명령 모델에서 발생한 이벤트를 반영하여, 읽기 모델을 갱신합니다.

### 2.3 데이터 동기화 및 이벤트 처리
- **이벤트 소싱 연계:**  
  - 명령 모델에서 발생한 이벤트를 이벤트 버스나 메시지 큐를 통해 조회 모델에 전달합니다.
  - 조회 모델은 해당 이벤트를 처리하여 자신의 상태를 갱신하며, 이를 통해 최신 데이터 상태를 유지합니다.
- **비동기 처리:**  
  - 읽기와 쓰기 모델 간의 동기화는 주로 비동기적으로 처리되어, 전체 시스템의 응답성과 확장성을 높입니다.

---

## 3. 장단점 및 고려 사항

### 장점
- **성능 최적화:**  
  - 읽기와 쓰기 작업을 분리하여 각 모델을 독립적으로 최적화할 수 있으므로, 특히 읽기 부하가 높은 시스템에서 뛰어난 성능을 발휘합니다.
- **복잡성 감소:**  
  - 도메인 로직을 명령 모델로 집중시켜, 복잡한 비즈니스 규칙과 트랜잭션 처리를 단순화할 수 있습니다.
- **유연성 및 확장성:**  
  - 읽기와 쓰기 모델이 독립적이므로, 서비스의 요구사항 변화에 따라 각각의 모델을 자유롭게 확장할 수 있습니다.
- **감사 및 이벤트 재생:**  
  - 이벤트 소싱과 결합 시, 모든 상태 변경 이벤트를 기록하고 이를 기반으로 시스템 상태를 재구성할 수 있어, 감사 및 복구 기능이 강화됩니다.

### 단점
- **데이터 동기화 복잡성:**  
  - 명령 모델과 조회 모델 간의 비동기 동기화 및 이벤트 처리 로직이 추가되므로, 구현 및 운영의 복잡성이 증가할 수 있습니다.
- **최종 일관성 문제:**  
  - 읽기 모델이 이벤트를 반영하는 데 약간의 지연이 발생할 수 있어, 일시적인 데이터 불일치가 발생할 수 있습니다.
- **개발 및 유지보수 비용:**  
  - 두 개의 별도 데이터 모델을 유지해야 하므로, 초기 설계 및 이후 변경 관리에 추가적인 노력이 필요합니다.

### 고려 사항
- **비즈니스 요구사항 분석:**  
  - 시스템의 읽기/쓰기 패턴, 응답 시간 요구사항, 데이터 정합성 중요도 등을 면밀히 분석하여, CQRS 도입이 적합한지 판단해야 합니다.
- **동기화 전략:**  
  - 명령 모델과 조회 모델 간의 동기화 주기, 이벤트 처리 방식, 재처리 및 장애 복구 전략을 명확히 설계해야 합니다.
- **인프라 및 기술 스택:**  
  - 이벤트 버스, 메시지 큐, 데이터베이스 선택 등, CQRS 구현에 적합한 기술 스택을 선정하고, 시스템 아키텍처에 통합하는 방안을 고려해야 합니다.

---

## 4. 실무 적용 사례

- **대규모 전자상거래 플랫폼:**  
  - 주문, 결제, 배송 등 복잡한 도메인 로직을 명령 모델로 처리하고, 고객 조회 및 통계 등 읽기 작업을 별도의 모델로 최적화하여 높은 성능을 달성합니다.
  
- **금융 거래 시스템:**  
  - 트랜잭션 처리와 감사 로그를 위해 이벤트 소싱과 결합된 CQRS 패턴을 도입하여, 높은 데이터 정합성과 빠른 조회 성능을 보장합니다.
  
- **마이크로서비스 기반 애플리케이션:**  
  - 각 서비스가 독립적으로 명령과 조회 모델을 운영하며, 서비스 간 이벤트 버스를 통해 데이터를 동기화함으로써, 전체 시스템의 확장성과 유연성을 강화합니다.

---

## 5. 참고 자료

- 📖 _Designing Data-Intensive Applications_ - Martin Kleppmann  
- 📖 _Building Event-Driven Microservices_ - Adam Bellemare  
- 📖 _Microservices Patterns: With examples in Java_ - Chris Richardson  
- 📌 [CQRS and Event Sourcing](https://microservices.io/patterns/data/cqrs.html)  
- 온라인 자료: 관련 블로그 포스트 및 기술 문서

---

## 6. 마무리

CQRS 패턴은 읽기와 쓰기 작업을 명확히 분리하여, 복잡한 도메인 로직을 단순화하고 시스템 성능을 극대화할 수 있는 강력한 아키텍처 패턴입니다.  
이 문서를 통해 CQRS의 기본 개념, 동작 원리, 구성 요소 및 장단점과 실무 적용 시 고려해야 할 사항들을 명확히 이해하고, 실제 시스템 설계에 효과적으로 반영할 수 있기를 바랍니다.