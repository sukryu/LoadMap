# 메시지 큐 (Message Queues)

> **목표:**  
> - 메시지 큐의 개념과 역할, 그리고 이벤트 기반 아키텍처에서의 활용 방식을 이해한다.  
> - Apache Kafka와 RabbitMQ와 같은 대표적인 메시지 큐 솔루션의 특징, 차이점, 장단점을 분석한다.  
> - 실무 환경에서 메시지 큐를 선택하고 적용할 때 고려해야 할 사항을 학습한다.

---

## 1. 개념 개요

> **메시지 큐는 시스템 구성 요소 간의 비동기 통신을 지원하는 미들웨어로, 데이터나 이벤트를 메시지 형태로 전송, 저장, 전달하여 서비스 간 결합도를 낮추고, 확장성과 내구성을 강화하는 역할을 수행한다.**

- **주요 역할:**  
  - **비동기 통신 지원:** 생산자(Producer)가 메시지를 큐에 발행하면, 소비자(Consumer)가 이를 필요할 때 읽어 처리할 수 있도록 함으로써, 시스템의 응답성과 확장성을 향상합니다.  
  - **부하 분산:** 메시지 큐를 통해 요청을 분산 처리함으로써, 트래픽 피크 시에도 안정적인 서비스 제공이 가능합니다.  
  - **내구성 및 재처리:** 메시지를 영속적으로 저장하고, 장애 발생 시 재처리할 수 있도록 지원하여 데이터 손실을 방지합니다.

---

## 2. Apache Kafka와 RabbitMQ 비교

### 2.1 Apache Kafka

- **개요:**  
  - Kafka는 높은 처리량과 확장성을 지닌 분산 메시징 시스템으로, 대규모 이벤트 스트리밍 및 로그 처리에 최적화되어 있습니다.
  
- **주요 특징:**  
  - **높은 처리량:** 수백만 건의 메시지를 초당 처리할 수 있는 성능을 보입니다.
  - **분산 아키텍처:** 클러스터 기반 설계로 노드를 추가하여 용량과 처리량을 손쉽게 확장할 수 있습니다.
  - **내구성:** 메시지를 디스크에 영속적으로 저장하며, 복제 메커니즘을 통해 데이터 손실을 방지합니다.
  - **구독 모델:** Pull 방식으로 소비자가 원하는 시점에 데이터를 가져올 수 있습니다.
  - **스트림 처리 지원:** Kafka Streams, ksqlDB 등과 함께 실시간 데이터 스트리밍 처리를 위한 생태계가 잘 구성되어 있습니다.

- **장점:**  
  - 높은 처리량과 확장성  
  - 내구성 및 데이터 복제 지원  
  - 실시간 스트림 처리 및 로그 분석에 유리

- **단점:**  
  - 초기 설정 및 운영 복잡성 (클러스터 구성, 파티셔닝, 복제 설정 등)  
  - 메시지 처리의 지연(latency)이 낮은 워크로드에는 오버헤드가 될 수 있음

### 2.2 RabbitMQ

- **개요:**  
  - RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 기반으로 한 메시지 브로커로, 신뢰성과 유연한 라우팅 기능에 중점을 둡니다.
  
- **주요 특징:**  
  - **다양한 메시징 패턴 지원:** 큐, 토픽, 라우팅, 팬아웃 등 다양한 교환(exchange) 모델을 지원하여, 복잡한 메시지 라우팅이 가능합니다.
  - **낮은 지연 시간:** 상대적으로 낮은 처리량이 요구되는 환경에서 빠른 응답성을 제공합니다.
  - **플러그인 시스템:** 다양한 확장 기능(예: 모니터링, 보안, 메시지 TTL 등)을 플러그인 형태로 쉽게 추가할 수 있습니다.
  - **Push 방식:** 메시지를 소비자에게 자동으로 푸시하여, 실시간 처리가 용이합니다.

- **장점:**  
  - 다양한 라우팅 옵션과 유연한 메시징 패턴 지원  
  - 사용이 비교적 간편하고 설정이 직관적임  
  - 낮은 지연 시간과 신뢰성 있는 메시지 전송

- **단점:**  
  - 높은 처리량이나 대규모 확장이 필요한 환경에서는 Kafka에 비해 성능이 제한적일 수 있음  
  - 클러스터링 및 복제 구성에 대한 관리가 Kafka만큼 강력하지 않을 수 있음

---

## 3. 실무 적용 및 고려 사항

- **시스템 요구사항 분석:**  
  - 대용량 스트리밍 데이터, 로그 처리, 이벤트 소싱 등 높은 처리량과 확장성이 필요한 경우에는 Kafka가 적합합니다.
  - 신뢰성이 중요한 메시징, 복잡한 라우팅, 낮은 지연이 요구되는 경우에는 RabbitMQ가 더 적합할 수 있습니다.

- **운영 및 모니터링:**  
  - Kafka와 RabbitMQ 모두 모니터링 도구(Prometheus, Grafana 등)를 통해 성능, 지연, 메시지 백로그 등을 실시간으로 모니터링할 수 있어야 합니다.
  - 메시지 내구성, 재시도 로직, 장애 복구 전략을 사전에 설계하여 데이터 손실 및 중복 처리를 방지합니다.

- **확장성 및 복제:**  
  - Kafka는 노드 추가를 통한 수평 확장이 용이하므로, 클러스터 환경에서 높은 처리량을 지원합니다.
  - RabbitMQ의 경우, 클러스터링과 Federation 기능을 통해 확장이 가능하지만, Kafka에 비해 상대적으로 설정과 관리가 복잡할 수 있습니다.

---

## 4. 코드 예시 (Kafka Producer 간단 예제)

```javascript
// Node.js Kafka Producer 예제 (kafkajs 라이브러리 사용)
const { Kafka } = require('kafkajs');

const kafka = new Kafka({
  clientId: 'my-app',
  brokers: ['kafka1:9092', 'kafka2:9092']
});

const producer = kafka.producer();

const run = async () => {
  // 프로듀서 시작
  await producer.connect();
  // 메시지 전송
  await producer.send({
    topic: 'test-topic',
    messages: [
      { value: 'Hello Kafka!' },
    ],
  });
  // 프로듀서 종료
  await producer.disconnect();
};

run().catch(console.error);
```

---

## 5. 마무리

메시지 큐는 이벤트 기반 아키텍처에서 핵심적인 역할을 하며, 시스템 간의 비동기 통신, 부하 분산, 내구성 있는 데이터 전송을 가능하게 합니다.  
Apache Kafka와 RabbitMQ는 각기 다른 장점과 사용 사례를 가지고 있으므로, 애플리케이션의 요구사항과 운영 환경에 따라 적절한 솔루션을 선택하는 것이 중요합니다.  
이 문서를 통해 메시지 큐의 기본 개념과 두 솔루션의 차이점을 명확히 이해하고, 실제 시스템 설계에 적용할 수 있기를 바랍니다.