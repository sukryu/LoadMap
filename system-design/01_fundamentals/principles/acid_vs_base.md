# ACID vs BASE 모델

ACID와 BASE는 데이터베이스 및 분산 시스템에서 데이터 일관성, 가용성, 성능 등을 보장하기 위한 두 가지 상반된 접근 방식입니다.  
전통적인 관계형 데이터베이스에서는 ACID를, 분산 환경이나 NoSQL 시스템에서는 BASE를 주로 채택합니다.  
이 문서에서는 두 모델의 개념, 특징, 사용 사례 및 트레이드오프를 초보자도 이해할 수 있도록 설명합니다.

---

## 1. 개념 개요

### 1.1. ACID 모델

ACID는 주로 전통적인 관계형 데이터베이스에서 채택하는 트랜잭션 처리 모델로, 네 가지 핵심 속성을 보장합니다.

- **Atomicity (원자성):**  
  하나의 트랜잭션 내의 모든 연산은 전부 실행되거나 전혀 실행되지 않아야 합니다.  
  예를 들어, 은행 이체 시 출금과 입금은 하나의 단위로 처리되어, 둘 중 하나만 수행되는 일이 없어야 합니다.

- **Consistency (일관성):**  
  트랜잭션 실행 전후에 데이터베이스는 항상 미리 정의된 규칙과 제약 조건을 만족해야 합니다.  
  이는 데이터 무결성을 보장하여, 잘못된 데이터가 저장되는 것을 방지합니다.

- **Isolation (격리성):**  
  동시에 실행되는 트랜잭션들은 서로의 작업에 영향을 주지 않아야 하며, 각 트랜잭션은 독립적으로 수행되어야 합니다.
  
- **Durability (지속성):**  
  트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 저장되어 시스템 장애가 발생해도 보존됩니다.

### 1.2. BASE 모델

BASE는 분산 시스템이나 NoSQL 데이터베이스에서 주로 사용하는 모델로, 높은 가용성과 확장성을 위해 일관성보다는 유연한 상태를 허용합니다.

- **Basically Available (기본적 가용성):**  
  시스템은 언제나 응답을 제공하도록 설계되지만, 그 응답이 최신 상태가 아닐 수 있습니다.
  
- **Soft state (유연한 상태):**  
  데이터 상태는 시간에 따라 변할 수 있으며, 즉각적인 일관성을 보장하지 않습니다.
  
- **Eventual consistency (최종적 일관성):**  
  시간이 지나면 데이터가 일관된 상태로 수렴하게 됩니다.  
  즉, 즉각적인 일관성은 포기하더라도, 최종적으로는 모든 노드가 동일한 데이터를 갖도록 합니다.

---

## 2. 문제 상황과 해결 방안

### 2.1. 문제 상황: ACID 모델의 한계와 BASE 모델의 필요성

- **ACID 모델의 한계:**  
  - **성능 저하:** 모든 트랜잭션이 원자성과 격리성을 보장하기 위해 락(lock)이나 동기화 작업이 필요하여, 높은 동시성 환경에서 성능 저하가 발생할 수 있습니다.
  - **확장성 문제:** 분산 환경에서는 강력한 일관성을 유지하는 것이 네트워크 지연 및 장애에 민감해, 시스템 확장이 어렵습니다.

- **BASE 모델의 필요성:**  
  - **높은 가용성:** 분산 시스템에서 네트워크 분할이나 일부 노드 장애가 발생하더라도, 시스템이 계속해서 응답할 수 있도록 설계합니다.
  - **유연한 확장:** 데이터를 즉각적으로 일관되게 유지하지 않고, 최종적으로 일관성을 맞추므로, 대규모 시스템에서도 높은 성능과 확장성을 제공합니다.

### 2.2. 해결 방안

- **트랜잭션의 성격에 따른 선택:**  
  - **금융, 회계 등** 높은 일관성과 무결성이 필요한 경우에는 ACID 모델이 적합합니다.
  - **소셜 미디어, 실시간 분석** 등 가용성과 확장성이 중요한 경우에는 BASE 모델(최종적 일관성)이 유리합니다.

- **혼합 접근법:**  
  일부 시스템은 중요한 데이터는 ACID 방식으로 관리하고, 비핵심 데이터나 캐시, 로그 등은 BASE 방식을 적용하는 등, 요구사항에 따라 혼합된 전략을 사용할 수 있습니다.

---

## 3. 구체적 구현 방법 및 베스트 프랙티스

### 3.1. ACID 모델 구현 예시

관계형 데이터베이스에서는 트랜잭션을 통해 ACID 속성을 보장합니다.

```sql
-- ACID 트랜잭션 예시 (SQL)
BEGIN TRANSACTION;

UPDATE account
SET balance = balance - 100
WHERE account_id = 'A';

UPDATE account
SET balance = balance + 100
WHERE account_id = 'B';

COMMIT;
```

- **원자성:** 모든 업데이트가 성공하거나, 문제가 발생하면 롤백(rollback)되어 전혀 반영되지 않습니다.
- **일관성:** 트랜잭션 전후에 계좌 잔액이 올바른 상태로 유지됩니다.
- **격리성 & 지속성:** 동시에 발생하는 트랜잭션 간 충돌을 방지하고, 커밋된 데이터는 영구적으로 저장됩니다.

### 3.2. BASE 모델 구현 예시

NoSQL 데이터베이스(예: Cassandra, DynamoDB)에서는 eventual consistency를 기본으로 하여 높은 가용성과 확장성을 제공합니다.

```python
# BASE 모델을 활용한 간단한 예시 (의사 코드)

def update_user_profile(user_id, new_profile):
    # 데이터를 빠르게 업데이트하고, 백그라운드에서 동기화 작업을 수행
    database.write(user_id, new_profile)
    # 즉시 응답을 반환하며, 실제 동기화는 시간이 지난 후 완료됨
    return "Profile update accepted. Changes will be visible eventually."

def get_user_profile(user_id):
    profile = database.read(user_id)
    # 데이터가 최신 상태가 아닐 수 있지만, 최종적으로 일관된 상태가 됩니다.
    return profile
```

- **기본적 가용성:** 사용자는 업데이트 요청 후 즉시 응답을 받고, 시스템은 높은 처리량을 유지합니다.
- **최종적 일관성:** 시간이 지나면 모든 노드가 동일한 사용자 정보를 갖게 됩니다.

---

## 4. 추가 고려 사항

- **성능 vs. 일관성:**  
  ACID 모델은 일관성을 최우선으로 하여 성능과 확장성에 영향을 줄 수 있지만, BASE 모델은 빠른 응답과 높은 가용성을 제공하는 대신 일관성이 지연될 수 있습니다.

- **비즈니스 요구사항 분석:**  
  시스템의 목적과 데이터의 중요도에 따라 어떤 모델을 선택할지 결정해야 합니다.  
  예를 들어, 금융 거래와 같은 핵심 비즈니스에서는 ACID가, 사용자 피드나 소셜 미디어와 같이 즉각적 일관성이 덜 중요한 경우 BASE가 적합할 수 있습니다.

- **혼합 전략 적용:**  
  일부 시스템에서는 핵심 트랜잭션에 ACID를, 부수적 기능에 BASE를 적용하는 등 혼합 전략을 고려할 수 있습니다.

- **모니터링 및 복구:**  
  BASE 모델에서는 eventual consistency를 보장하기 위해 데이터 동기화 및 충돌 해결 메커니즘, 모니터링 체계를 갖추어야 합니다.

---

## 5. 결론

ACID와 BASE 모델은 각기 다른 시스템 요구사항과 환경에 맞추어 설계된 데이터 처리 방식입니다.

- **ACID 모델**은 데이터 무결성과 일관성을 강하게 보장하며, 금융, 회계 등 높은 신뢰성이 필요한 시스템에 적합합니다.
- **BASE 모델**은 높은 가용성과 확장성을 제공하며, 분산 시스템이나 실시간 웹 서비스에서 빠른 응답을 필요로 하는 경우에 유리합니다.

두 모델의 특성과 트레이드오프를 이해하고, 시스템의 목적에 맞는 전략을 선택하는 것이 안정적이고 효율적인 소프트웨어 설계의 핵심입니다.