# SOLID 원칙

SOLID 원칙은 유지보수성과 확장성이 뛰어난 소프트웨어 시스템을 설계하기 위한 **객체지향 설계 5대 원칙**입니다. 이 디렉토리에서는 각 원칙의 개념과 실무 적용 방법에 대해 자세히 다룹니다.

---

## 목차

- [단일 책임 원칙 (SRP)](single_responsibility.md)
- [개방-폐쇄 원칙 (OCP)](open_closed.md)
- [리스코프 치환 원칙 (LSP)](liskov_substitution.md)
- [인터페이스 분리 원칙 (ISP)](interface_segregation.md)
- [의존성 역전 원칙 (DIP)](dependency_inversion.md)

---

## SOLID 원칙 개요

SOLID는 소프트웨어 설계 시 **코드의 가독성**, **유지보수성**, 그리고 **확장성**을 보장하기 위해 제시된 다섯 가지 기본 원칙을 의미합니다. 각각의 원칙은 다음과 같은 문제들을 해결하는 데 중점을 둡니다:

1. **단일 책임 원칙 (SRP)**
   - **문제 해결:** 하나의 클래스나 모듈이 하나의 책임만 가지도록 하여 변경 이유를 최소화합니다.
   - **핵심 아이디어:** 클래스는 단 하나의 역할만 수행해야 하며, 이를 통해 코드의 이해도와 재사용성을 높입니다.

2. **개방-폐쇄 원칙 (OCP)**
   - **문제 해결:** 기존 코드를 변경하지 않고 기능을 확장할 수 있도록 함으로써, 시스템의 안정성을 유지합니다.
   - **핵심 아이디어:** 소프트웨어 엔티티(클래스, 모듈 등)는 확장에는 열려 있고, 변경에는 닫혀 있어야 합니다.

3. **리스코프 치환 원칙 (LSP)**
   - **문제 해결:** 상속 관계에서 서브타입이 기반 타입과 교체 가능하도록 하여, 예측 가능한 행동을 보장합니다.
   - **핵심 아이디어:** 하위 클래스는 상위 클래스의 계약을 준수해야 하며, 이를 위반할 경우 코드의 안정성이 크게 저하됩니다.

4. **인터페이스 분리 원칙 (ISP)**
   - **문제 해결:** 클라이언트가 사용하지 않는 인터페이스에 의존하지 않도록 하여, 불필요한 의존성을 줄입니다.
   - **핵심 아이디어:** 인터페이스는 구체적이고 작은 단위로 분리하여, 클라이언트에게 꼭 필요한 기능만 제공해야 합니다.

5. **의존성 역전 원칙 (DIP)**
   - **문제 해결:** 고수준 모듈이 저수준 모듈에 직접 의존하는 것을 피하고, 추상화에 의존하도록 하여 유연한 구조를 만듭니다.
   - **핵심 아이디어:** 세부 사항보다는 추상화에 의존함으로써, 모듈 간의 결합도를 낮추고 테스트와 확장이 용이한 코드를 작성할 수 있습니다.

---

## 실무 적용 및 학습 포인트

- **객체지향 설계와의 조화:**  
  SOLID 원칙은 객체지향 프로그래밍(OOP)에서의 설계 철학을 구체화하여, 복잡한 비즈니스 로직을 단순화하고 관리하기 쉽게 만들어 줍니다.

- **테스트 주도 개발(TDD)과의 연계:**  
  SOLID 원칙을 적용하면 단위 테스트 작성이 쉬워지고, 리팩토링 시 부작용을 줄일 수 있어 안정적인 개발이 가능합니다.

- **리팩토링과 코드 유지보수:**  
  잘 설계된 코드는 변경에 유연하며, 새로운 기능 추가나 기존 기능 수정 시 최소한의 영향을 미치게 됩니다. SOLID 원칙을 통한 모듈화는 이러한 목표 달성에 크게 기여합니다.

---

## 참고 자료

- **Clean Code** - Robert C. Martin  
- **Agile Software Development, Principles, Patterns, and Practices** - Robert C. Martin  
- [SOLID 원칙 관련 블로그 포스트](https://example.com/solid-principles) *(참고용 링크)*

---

이 디렉토리 내 각 파일은 SOLID 원칙의 구체적인 내용을 다루며, 실무 사례와 코드 예제를 포함하고 있습니다. 먼저 각 원칙의 기본 개념을 이해한 후, 상세한 내용을 확인해보세요.
