# 단일 책임 원칙 (Single Responsibility Principle, SRP)

단일 책임 원칙은 **한 클래스나 모듈은 하나의 "변경 이유"만 가져야 한다**는 개념입니다. 즉, 하나의 클래스는 하나의 책임만을 가져야 하며, 그 책임과 관련된 모든 기능만 포함해야 합니다. 이를 통해 코드를 이해하기 쉽고, 유지보수와 확장이 용이해집니다.

---

## 1. SRP의 개념 이해

### 1.1. 책임(Responsibility)이란?
- **책임**은 클래스가 변경되어야 하는 **이유**를 의미합니다.
- 하나의 클래스가 여러 가지 역할(책임)을 가지게 되면, 그 중 하나의 변경이 다른 역할에도 영향을 미칠 수 있습니다.

### 1.2. 왜 SRP가 중요한가?
- **가독성**: 클래스가 한 가지 역할만 수행하면, 해당 클래스가 무엇을 하는지 쉽게 이해할 수 있습니다.
- **유지보수성**: 변경이 필요한 경우, 하나의 책임만 가진 클래스를 수정하면 되므로 부작용이 줄어듭니다.
- **테스트 용이성**: 책임이 분리되어 있으면, 단위 테스트를 작성하기 쉬워집니다.

---

## 2. 문제 상황과 해결 방안

### 2.1. 문제 상황: 여러 책임을 가진 클래스

예를 들어, 직원(Employee) 정보를 다루는 클래스가 여러 기능을 포함하고 있다고 가정해봅니다.

```python
# 문제 예시: 하나의 클래스가 여러 역할을 수행
class Employee:
    def __init__(self, name, emp_id):
        self.name = name
        self.emp_id = emp_id

    def calculate_pay(self):
        # 급여 계산 로직
        pass

    def save(self):
        # 데이터베이스에 직원 정보를 저장
        pass

    def generate_report(self):
        # 직원 정보를 기반으로 보고서 생성
        pass
```

위 코드에서 `Employee` 클래스는 **급여 계산**, **데이터 저장**, **보고서 생성**이라는 세 가지 서로 다른 책임을 가지고 있습니다. 이렇게 되면 한 기능의 변경이 다른 기능에 영향을 미치기 쉽습니다.

### 2.2. 해결 방안 1: 클래스 분리

각 책임을 별도의 클래스로 분리하면, 각 클래스는 하나의 역할만 담당하게 됩니다.

```python
# Employee 클래스는 직원의 기본 정보만 관리
class Employee:
    def __init__(self, name, emp_id):
        self.name = name
        self.emp_id = emp_id

# 급여 계산 책임을 별도의 클래스에서 처리
class PayCalculator:
    def calculate(self, employee):
        # 급여 계산 로직 구현
        print(f"Calculating pay for {employee.name}")
        # 예시: return 기본급 + 수당 등
        return 0

# 데이터 저장 책임을 별도의 클래스로 분리
class EmployeeRepository:
    def save(self, employee):
        # 데이터베이스에 저장하는 로직 구현
        print(f"Saving {employee.name} to the database")

# 보고서 생성 책임을 별도의 클래스로 분리
class ReportGenerator:
    def generate(self, employee):
        # 보고서 생성 로직 구현
        print(f"Generating report for {employee.name}")
```

**장점:**
- 각 클래스는 단 하나의 책임만 가지고 있어, 이해하기 쉽고 수정 시 다른 기능에 영향을 주지 않습니다.
- 변경이 발생할 때, 관련된 클래스만 수정하면 되므로 유지보수가 용이합니다.

**단점:**
- 클래스 수가 증가할 수 있으며, 이들 간의 관계를 관리하는 추가적인 설계가 필요할 수 있습니다.

### 2.3. 해결 방안 2: 함수 단위로 분리

클래스로 분리하는 대신, 함수 단위로 책임을 분리할 수도 있습니다.

```python
# 직원 정보 클래스 (책임 최소화)
class Employee:
    def __init__(self, name, emp_id):
        self.name = name
        self.emp_id = emp_id

# 각 기능을 독립적인 함수로 구현
def calculate_pay(employee):
    # 급여 계산 로직
    print(f"Calculating pay for {employee.name}")
    return 0

def save_employee(employee):
    # 데이터베이스 저장 로직
    print(f"Saving {employee.name} to the database")

def generate_report(employee):
    # 보고서 생성 로직
    print(f"Generating report for {employee.name}")
```

**장점:**
- 코드가 단순해지고, 작은 단위의 함수로 분리되어 가독성이 좋습니다.
- 간단한 책임을 처리할 때, 클래스보다 함수가 더 효율적일 수 있습니다.

**단점:**
- 상태 관리나 복잡한 로직이 필요한 경우에는 클래스를 사용하는 것이 더 적합할 수 있습니다.

---

## 3. 구체적 구현 방법 및 베스트 프랙티스

### 3.1. 설계 시 고려 사항
- **변경 이유(Responsibility)**를 명확히 파악하여 클래스를 설계합니다.
- 하나의 클래스가 너무 많은 역할을 하지 않도록 기능별로 분리합니다.
- 각 클래스나 함수는 한 가지 일만 하도록 작성하여, 추후에 테스트와 리팩토링이 용이하도록 합니다.

### 3.2. 테스트 전략
- 각 기능별로 단위 테스트를 작성하여, 변경 시 다른 기능에 영향이 없는지 검증합니다.
- 예를 들어, `PayCalculator` 클래스의 `calculate` 메서드만을 테스트하는 단위 테스트를 작성할 수 있습니다.

### 3.3. 엣지 케이스 고려
- **예외 상황 처리:** 각 클래스나 함수는 입력 값이 유효하지 않을 경우 예외를 발생시키거나, 에러 로그를 기록해야 합니다.
- **데이터 무결성:** 데이터 저장 기능을 구현할 때, 트랜잭션 관리와 같은 방법을 고려하여 데이터 무결성을 유지해야 합니다.

---

## 4. 추가 고려 사항

- **협업 및 코드 리뷰:** SRP를 준수한 모듈은 각 기능이 명확하게 분리되어 있기 때문에, 팀원 간 코드 리뷰가 용이합니다.
- **확장성:** 새로운 기능이 추가될 때, 기존 클래스를 수정하지 않고 새로운 클래스를 추가하여 기능을 확장할 수 있습니다.
- **유지보수:** 각 클래스나 함수가 단일 책임을 가지므로, 요구 사항 변경 시 해당 부분만 집중적으로 수정할 수 있습니다.
- **보안 및 모니터링:** 각 모듈의 로그와 에러 처리를 독립적으로 구현하여, 문제 발생 시 원인을 쉽게 추적할 수 있습니다.

---

## 5. 결론

단일 책임 원칙(SRP)은 초보자부터 숙련된 개발자까지 모두에게 중요한 설계 원칙입니다.  
- **한 클래스, 한 책임:** 코드를 단순하게 유지하고, 변경에 유연하게 대응할 수 있습니다.
- **유지보수와 테스트:** 각 기능이 분리되어 있어 테스트와 유지보수가 용이합니다.
- **실제 적용:** 클래스나 함수 분리 등 다양한 방식으로 SRP를 적용할 수 있으며, 프로젝트의 특성에 맞게 선택하면 됩니다.

SRP를 이해하고 적용함으로써, 보다 체계적이고 견고한 소프트웨어 시스템을 설계할 수 있습니다.