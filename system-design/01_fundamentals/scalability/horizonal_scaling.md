# 수평적 확장 (Horizontal Scaling)

---

## 1. 개념 개요

**수평적 확장**은 시스템에 부하가 증가할 때 **동일한 기능을 수행하는 서버(노드)를 추가하여 처리 능력을 확장**하는 방법입니다.  
즉, 단일 서버의 성능을 높이는 수직적 확장과는 달리, 여러 대의 서버를 병렬로 운영함으로써 전체 처리량을 증가시키는 방식입니다.

- **정의:**  
  - 동일한 역할을 수행하는 여러 서버 인스턴스를 추가하여, 트래픽이나 데이터 처리량이 증가해도 시스템의 성능을 유지하거나 향상시키는 방법.
  - 클러스터링, 서버 풀링, 컨테이너 오케스트레이션(Kubernetes 등)과 결합하여 구현됩니다.

- **특징:**  
  - **확장 용이성:**  
    - 추가 서버를 쉽게 투입하여 시스템의 처리 능력을 늘릴 수 있습니다.
  - **고가용성:**  
    - 여러 서버가 함께 운영되므로, 한 서버에 장애가 발생해도 나머지 서버가 정상적으로 서비스를 제공할 수 있습니다.
  - **부하 분산:**  
    - 로드 밸런서를 활용하여 클라이언트의 요청을 여러 서버에 분산시킵니다.
  - **탄력적 대응:**  
    - 트래픽 급증 시 자동 스케일링(Auto Scaling) 기능을 통해 필요에 따라 서버 인스턴스를 동적으로 추가할 수 있습니다.

---

## 2. 문제 상황과 해결 방안

### 2.1. 문제 상황

- **트래픽 급증 및 부하 증가:**  
  - 예상치 못한 사용자 증가, 이벤트 발생 등으로 인해 단일 서버가 감당할 수 없는 부하가 발생하는 경우.
  
- **단일 장애점(Single Point of Failure):**  
  - 한 대의 서버에 장애가 발생하면 전체 서비스가 중단될 위험이 있습니다.
  
- **자원 한계:**  
  - 단일 서버의 CPU, 메모리, 디스크 등의 자원은 물리적 한계가 있으므로, 성능 확장이 어려울 수 있습니다.

### 2.2. 해결 방안

- **서버 인스턴스 추가:**  
  - 동일한 기능을 수행하는 서버를 추가하여 트래픽을 분산시킵니다.
  
- **로드 밸런서 도입:**  
  - 로드 밸런서를 통해 클라이언트 요청을 여러 서버에 분산, 서버 간 부하를 고르게 유지합니다.
  
- **자동 스케일링:**  
  - 클라우드 서비스의 Auto Scaling 기능을 활용해, 트래픽 상황에 따라 서버 인스턴스를 자동으로 추가하거나 축소합니다.
  
- **데이터베이스 샤딩:**  
  - 데이터베이스의 경우에도 수평 분할(샤딩)을 통해 데이터를 여러 서버에 분산하여 처리 부하를 줄입니다.

---

## 3. 구체적 구현 방법 및 베스트 프랙티스

### 3.1. 기본 디렉토리 구조 예시

아래는 Node.js 기반의 간단한 애플리케이션을 수평적 확장 환경에서 운영할 때의 예시 디렉토리 구조입니다.

```plaintext
horizontal-scaling-app/
├── app.js             # 애플리케이션 진입점
├── controllers/       # 요청 처리 로직
├── services/          # 비즈니스 로직
├── models/            # 데이터 모델 및 DB 연동
├── routes/            # 라우팅 설정
├── config/            # 환경 설정 (예: 로드 밸런서, Auto Scaling 설정 등)
└── package.json
```

### 3.2. 코드 예시: 클러스터 모듈을 이용한 수평적 확장

Node.js의 `cluster` 모듈을 활용하면, 단일 서버 내에서 여러 워커 프로세스를 생성하여 CPU 코어를 모두 활용할 수 있습니다.  
아래는 간단한 클러스터 기반 서버 예시입니다.

*app.js*
```javascript
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`마스터 프로세스 PID: ${process.pid}`);
  
  // 워커 프로세스 생성: CPU 코어 수 만큼
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  // 워커가 종료될 경우 재시작
  cluster.on('exit', (worker, code, signal) => {
    console.log(`워커 ${worker.process.pid} 종료, 재시작 시도...`);
    cluster.fork();
  });
} else {
  // 워커 프로세스: HTTP 서버 실행
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`프로세스 PID: ${process.pid} - Hello, Horizontal Scaling!`);
  }).listen(3000);

  console.log(`워커 프로세스 PID: ${process.pid} 서버 실행 중`);
}
```

### 베스트 프랙티스

- **로드 밸런서와 함께 사용:**  
  - 클러스터 모듈과 함께 외부 로드 밸런서(NGINX, HAProxy 등)를 도입하여, 여러 서버(또는 클러스터)에 트래픽을 효과적으로 분산합니다.
  
- **자동 스케일링 정책:**  
  - 클라우드 환경(AWS, GCP, Azure)의 Auto Scaling 정책을 설정하여, 트래픽 변화에 따라 서버 인스턴스를 자동으로 추가/삭제합니다.
  
- **상태 공유 최소화:**  
  - 수평적 확장 시에는 각 서버 인스턴스가 독립적으로 동작할 수 있도록, 세션 및 상태 관리에 외부 스토어(예: Redis)를 사용합니다.
  
- **모니터링 및 로깅:**  
  - 확장된 시스템에서는 각 인스턴스의 상태 및 성능을 모니터링하고, 로그를 중앙 집중식으로 관리하는 도구(예: Prometheus, Grafana, ELK Stack)를 사용합니다.

---

## 4. 추가 고려 사항

- **데이터베이스 확장:**  
  - 애플리케이션 서버뿐만 아니라 데이터베이스도 수평적 확장이 가능하도록 샤딩이나 리플리케이션 전략을 함께 고려해야 합니다.
  
- **네트워크 부하 및 지연:**  
  - 서버 간 통신, 로드 밸런서의 성능, 네트워크 대역폭 등을 주기적으로 점검하여 병목 현상을 예방합니다.
  
- **비용 관리:**  
  - 서버 인스턴스의 추가는 비용 증가로 이어질 수 있으므로, 성능 요구사항과 비용 효율성을 면밀히 분석하여 적절한 인스턴스 수를 유지해야 합니다.

---

## 5. 결론

**수평적 확장**은 시스템이 증가하는 트래픽과 데이터 부하를 효율적으로 처리하기 위한 핵심 전략입니다.

- **장점:**  
  - 여러 서버를 통해 고가용성과 부하 분산을 구현할 수 있으며, 장애 시 복원력도 향상됩니다.
  - 클라우드의 Auto Scaling 기능과 결합하면, 트래픽 변화에 유연하게 대응할 수 있습니다.

- **단점:**  
  - 서버 간 상태 동기화, 네트워크 복잡성, 로드 밸런서 설정 등 추가적인 관리와 모니터링이 필요합니다.
  - 데이터베이스나 기타 공유 리소스의 확장도 함께 고려해야 합니다.

따라서, 수평적 확장을 도입할 때는 **로드 밸런싱, 자동 스케일링, 모니터링 및 상태 관리** 등 다양한 요소를 종합적으로 고려하여 설계해야 합니다.