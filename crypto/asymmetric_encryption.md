# 1. ë“¤ì–´ê°€ê¸° (Introduction)

ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ëŠ” í˜„ëŒ€ ì •ë³´ ë³´ì•ˆì˜ í•µì‹¬ ê¸°ìˆ ì´ë©°, ì¸í„°ë„· ì‹œëŒ€ì˜ ì•ˆì „í•œ í†µì‹ ê³¼ ì „ì ìƒê±°ë˜ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ê¸°ë°˜ì´ ë©ë‹ˆë‹¤. ë³¸ ë¬¸ì„œëŠ” ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ ê¸°ë³¸ ê°œë…ë¶€í„° ì‹¤ì œ êµ¬í˜„ê³¼ ìš´ì˜ê¹Œì§€, ê°œë°œìì™€ ë³´ì•ˆ ì „ë¬¸ê°€ë“¤ì´ ë°˜ë“œì‹œ ì•Œì•„ì•¼ í•  ë‚´ìš©ì„ ì²´ê³„ì ìœ¼ë¡œ ë‹¤ë£¹ë‹ˆë‹¤.

## 1.1 ë¬¸ì„œì˜ ëª©ì ê³¼ ì¤‘ìš”ì„±

### ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ í•„ìš”ì„± ğŸ¯

í˜„ëŒ€ ë””ì§€í„¸ í™˜ê²½ì—ì„œ ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ê°€ í•„ìš”í•œ ì´ìœ ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

1. **ì•ˆì „í•œ í‚¤ êµí™˜**
   - ëŒ€ì¹­ ì•”í˜¸í™”ì˜ í•œê³„ ê·¹ë³µ
   - ì‚¬ì „ ì ‘ì´‰ ì—†ëŠ” ì•ˆì „í•œ í†µì‹  ì„¤ì •
   - í™•ì¥ ê°€ëŠ¥í•œ í‚¤ ê´€ë¦¬ ì²´ê³„ êµ¬ì¶•

2. **ë””ì§€í„¸ ì‹ ì› ì¦ëª…**
   - ì „ì ì„œëª…ì„ í†µí•œ ë³¸ì¸ ì¸ì¦
   - ë¬¸ì„œì˜ ì§„ìœ„ ì—¬ë¶€ ê²€ì¦
   - ë¶€ì¸ ë°©ì§€ ê¸°ëŠ¥ ì œê³µ

3. **ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥**
   - ë©”ì‹œì§€ ë³€ì¡° íƒì§€
   - ì†Œí”„íŠ¸ì›¨ì–´ íŒ¨í‚¤ì§€ ê²€ì¦
   - ë³´ì•ˆ ì—…ë°ì´íŠ¸ ì¸ì¦

### í˜„ëŒ€ ë³´ì•ˆì—ì„œì˜ ì—­í•  ğŸ›¡ï¸

ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ëŠ” ë‹¤ìŒê³¼ ê°™ì€ í˜„ëŒ€ ë³´ì•ˆ ì¸í”„ë¼ì˜ ê·¼ê°„ì„ ì´ë£¹ë‹ˆë‹¤:

```mermaid
graph TD
    A[ë¹„ëŒ€ì¹­ ì•”í˜¸í™”] --> B[HTTPS/TLS]
    A --> C[ì „ìì„œëª…]
    A --> D[PKI]
    B --> E[ì›¹ ë³´ì•ˆ]
    C --> F[ì „ììƒê±°ë˜]
    D --> G[ì¸ì¦ì„œ ì²´ê³„]
```

ì£¼ìš” ì‘ìš© ë¶„ì•¼:
- ì›¹ ë³´ì•ˆ (HTTPS)
- ì´ë©”ì¼ ë³´ì•ˆ (S/MIME, PGP)
- ì½”ë“œ ì„œëª…
- ë¸”ë¡ì²´ì¸ê³¼ ì•”í˜¸í™”í
- IoT ë””ë°”ì´ìŠ¤ ì¸ì¦

### ì£¼ìš” ì‚¬ìš© ì‚¬ë¡€ ğŸ’¡

ì‹¤ì œ í™˜ê²½ì—ì„œì˜ ì ìš© ì˜ˆì‹œ:

```go
// RSA í‚¤ ìŒ ìƒì„± ì˜ˆì‹œ
package main

import (
    "crypto/rand"
    "crypto/rsa"
    "crypto/x509"
    "encoding/pem"
    "os"
)

func generateKeyPair(bits int) error {
    // ê°œì¸í‚¤ ìƒì„±
    privateKey, err := rsa.GenerateKey(rand.Reader, bits)
    if err != nil {
        return err
    }

    // ê°œì¸í‚¤ë¥¼ PEM í˜•ì‹ìœ¼ë¡œ ì €ì¥
    privateKeyBytes := x509.MarshalPKCS1PrivateKey(privateKey)
    privateKeyPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "RSA PRIVATE KEY",
        Bytes: privateKeyBytes,
    })

    // ê³µê°œí‚¤ ì¶”ì¶œ ë° ì €ì¥
    publicKey := &privateKey.PublicKey
    publicKeyBytes, err := x509.MarshalPKIXPublicKey(publicKey)
    if err != nil {
        return err
    }
    publicKeyPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "RSA PUBLIC KEY",
        Bytes: publicKeyBytes,
    })

    // íŒŒì¼ë¡œ ì €ì¥
    err = os.WriteFile("private.pem", privateKeyPEM, 0600)
    if err != nil {
        return err
    }
    return os.WriteFile("public.pem", publicKeyPEM, 0644)
}
```

## 1.2 ì ìš© ë²”ìœ„

ë³¸ ë¬¸ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë²”ìœ„ì˜ ì£¼ì œë¥¼ ë‹¤ë£¹ë‹ˆë‹¤:

### ê¸°ë³¸ ê°œë… í•™ìŠµ ğŸ“š

1. **ìˆ˜í•™ì  ê¸°ì´ˆ**
   - ì •ìˆ˜ë¡ ê³¼ ëª¨ë“ˆëŸ¬ ì—°ì‚°
   - íƒ€ì›ê³¡ì„  ì´ë¡ 
   - ì•”í˜¸í•™ì  ê¸°ë³¸ ì›ë¦¬

2. **ì•Œê³ ë¦¬ì¦˜ ì´í•´**
   - RSA ì•Œê³ ë¦¬ì¦˜
   - ECC (íƒ€ì›ê³¡ì„  ì•”í˜¸í™”)
   - ë””ì§€í„¸ ì„œëª… ì•Œê³ ë¦¬ì¦˜

### ì‹¤ì œ êµ¬í˜„ ë° ìš´ì˜ âš™ï¸

êµ¬í˜„ ì‹œ ê³ ë ¤í•´ì•¼ í•  ì£¼ìš” ì‚¬í•­:

1. **ì•Œê³ ë¦¬ì¦˜ ì„ íƒ**
   - ìš©ë„ì— ë”°ë¥¸ ì ì ˆí•œ ì•Œê³ ë¦¬ì¦˜ ì„ ì •
   - í‚¤ ê¸¸ì´ ê²°ì •
   - ì„±ëŠ¥ê³¼ ë³´ì•ˆì„± ê· í˜•

2. **í‚¤ ê´€ë¦¬**
   - ì•ˆì „í•œ í‚¤ ìƒì„±
   - í‚¤ ì €ì¥ì†Œ ê´€ë¦¬
   - í‚¤ ìˆ˜ëª…ì£¼ê¸° ê´€ë¦¬

3. **ìš´ì˜ ê´€ë¦¬**
   - ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
   - ë³´ì•ˆ ê°ì‚¬
   - ì¸ì‹œë˜íŠ¸ ëŒ€ì‘

### ë³´ì•ˆ ê³ ë ¤ì‚¬í•­ ğŸ”’

1. **ìœ„í˜‘ ëª¨ë¸**
   - ì•Œë ¤ì§„ ê³µê²© ìœ í˜•
   - ëŒ€ì‘ ë°©ì•ˆ
   - ë¦¬ìŠ¤í¬ í‰ê°€

2. **êµ¬í˜„ ë³´ì•ˆ**
   - ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±
   - ë©”ëª¨ë¦¬ ë³´ì•ˆ
   - ë¶€ì±„ë„ ê³µê²© ë°©ì§€

### ì„±ëŠ¥ ìµœì í™” ì „ëµ ğŸš€

ì‹œìŠ¤í…œ ìµœì í™”ë¥¼ ìœ„í•œ ì£¼ìš” ì „ëµ:

```go
// ë³‘ë ¬ ì²˜ë¦¬ë¥¼ í†µí•œ ì„±ëŠ¥ ìµœì í™” ì˜ˆì‹œ
func parallelEncrypt(messages [][]byte, publicKey *rsa.PublicKey) [][]byte {
    results := make([][]byte, len(messages))
    var wg sync.WaitGroup
    
    for i, msg := range messages {
        wg.Add(1)
        go func(index int, message []byte) {
            defer wg.Done()
            // ì‹¤ì œ ì•”í˜¸í™” ì‘ì—…
            encrypted, err := rsa.EncryptPKCS1v15(
                rand.Reader,
                publicKey,
                message,
            )
            if err == nil {
                results[index] = encrypted
            }
        }(i, msg)
    }
    
    wg.Wait()
    return results
}
```

## 1.3 ì‚¬ì „ ì§€ì‹

ë³¸ ë¬¸ì„œë¥¼ íš¨ê³¼ì ìœ¼ë¡œ í•™ìŠµí•˜ê¸° ìœ„í•´ í•„ìš”í•œ ê¸°ì´ˆ ì§€ì‹:

### ìˆ˜í•™ì  ê¸°ì´ˆ ğŸ”¢

1. **ì •ìˆ˜ë¡ **
   - ëª¨ë“ˆëŸ¬ ì—°ì‚°
   - ì†Œìˆ˜ì™€ ì¸ìˆ˜ë¶„í•´
   - ìœ í•œì²´

2. **íƒ€ì›ê³¡ì„ **
   - ê³¡ì„ ì˜ ìˆ˜í•™ì  ì •ì˜
   - ì  ì—°ì‚°
   - ì´ì‚°ë¡œê·¸ ë¬¸ì œ

### ê¸°ë³¸ ì•”í˜¸í™” ê°œë… ğŸ”

í•„ìˆ˜ ì•”í˜¸í™” ê°œë…:
- ëŒ€ì¹­/ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ ì°¨ì´
- í•´ì‹œ í•¨ìˆ˜ì˜ ì´í•´
- ë‚œìˆ˜ ìƒì„±ì˜ ì¤‘ìš”ì„±
- ì•”í˜¸í•™ì  ì›ì‹œ í•¨ìˆ˜

### ë³´ì•ˆ í”„ë¡œí† ì½œì˜ ì´í•´ ğŸ“¡

ì£¼ìš” ë³´ì•ˆ í”„ë¡œí† ì½œ:
- TLS/SSL
- SSH
- PGP
- X.509 ì¸ì¦ì„œ

## í•™ìŠµ ìˆœì„œ ë° ì ‘ê·¼ ë°©ë²•

ë³¸ ë¬¸ì„œì˜ ë‚´ìš©ì„ íš¨ê³¼ì ìœ¼ë¡œ í•™ìŠµí•˜ê¸° ìœ„í•œ ê¶Œì¥ ìˆœì„œ:

1. **ê¸°ì´ˆ ê°œë… í™•ë¦½**
   - ìˆ˜í•™ì  ê¸°ë°˜ ì´í•´
   - ê¸°ë³¸ ì•”í˜¸í™” ì›ë¦¬ í•™ìŠµ
   - ìš©ì–´ì™€ ê°œë… ìˆ™ì§€

2. **ì•Œê³ ë¦¬ì¦˜ í•™ìŠµ**
   - RSA ì•Œê³ ë¦¬ì¦˜ ì´í•´
   - ECC ê¸°ì´ˆ í•™ìŠµ
   - ë””ì§€í„¸ ì„œëª… ë§¤ì»¤ë‹ˆì¦˜

3. **ì‹¤ë¬´ ì ìš©**
   - êµ¬í˜„ ì‚¬ë¡€ ì—°êµ¬
   - ë³´ì•ˆ ê³ ë ¤ì‚¬í•­ ê²€í† 
   - ì„±ëŠ¥ ìµœì í™” ê¸°ë²•

4. **ê³ ê¸‰ ì£¼ì œ**
   - ìµœì‹  ì•”í˜¸í™” ë™í–¥
   - ì–‘ì ë‚´ì„± ì•”í˜¸
   - ì‹ ê¸°ìˆ  í†µí•©

## ëŒ€ìƒ ë…ì

ë³¸ ë¬¸ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë…ìë¥¼ ëŒ€ìƒìœ¼ë¡œ í•©ë‹ˆë‹¤:

### ê°œë°œì ğŸ‘¨â€ğŸ’»
- ë°±ì—”ë“œ ê°œë°œì
- ë³´ì•ˆ ì—”ì§€ë‹ˆì–´
- ì‹œìŠ¤í…œ ì•„í‚¤í…íŠ¸

### ë³´ì•ˆ ì „ë¬¸ê°€ ğŸ”
- ë³´ì•ˆ ê°ì‚¬ì
- ë³´ì•ˆ ì»¨ì„¤í„´íŠ¸
- ì¹¨íˆ¬ í…ŒìŠ¤í„°

### ì‹œìŠ¤í…œ ê´€ë¦¬ì âš™ï¸
- ì¸í”„ë¼ ì—”ì§€ë‹ˆì–´
- DevOps ì—”ì§€ë‹ˆì–´
- í´ë¼ìš°ë“œ ì•„í‚¤í…íŠ¸

## ë¬¸ì„œ ì‚¬ìš© ë°©ë²•

íš¨ê³¼ì ì¸ í•™ìŠµì„ ìœ„í•œ ê¶Œì¥ ì‚¬í•­:

1. **ë‹¨ê³„ì  í•™ìŠµ**
   - ê¸°ì´ˆë¶€í„° ì°¨ê·¼ì°¨ê·¼ í•™ìŠµ
   - ì‹¤ìŠµ ì˜ˆì œ ì§ì ‘ ìˆ˜í–‰
   - ê°œë… ì´í•´ í›„ ì‹¤ë¬´ ì ìš©

2. **ì°¸ê³  ìë£Œ í™œìš©**
   - ê³µì‹ ë¬¸ì„œ ì°¸ì¡°
   - ì¶”ê°€ í•™ìŠµ ìë£Œ í™œìš©
   - ì»¤ë®¤ë‹ˆí‹° ì°¸ì—¬

3. **ì‹¤ë¬´ ì ìš©**
   - í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œ ì‹¤ìŠµ
   - ì ì§„ì  ë„ì…
   - ì§€ì†ì ì¸ ê°œì„ 

---

# 2. ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ ê¸°ì´ˆ

## 2.1 ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ ê°œë…

ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ëŠ” í˜„ëŒ€ ì•”í˜¸í•™ì˜ í˜ì‹ ì ì¸ ë°œì „ì„ ëŒ€í‘œí•˜ëŠ” ê¸°ìˆ ì…ë‹ˆë‹¤. 1976ë…„ Whitfield Diffieì™€ Martin Hellmanì´ ì²˜ìŒ ì œì•ˆí•œ ì´ ê°œë…ì€, ê¸°ì¡´ ëŒ€ì¹­ ì•”í˜¸í™”ì˜ í•œê³„ë¥¼ ê·¹ë³µí•˜ê³  ì•ˆì „í•œ í‚¤ êµí™˜ ë¬¸ì œë¥¼ í•´ê²°í–ˆìŠµë‹ˆë‹¤.

### 2.1.1 ê³µê°œí‚¤ì™€ ê°œì¸í‚¤ì˜ ì´í•´

ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ í•µì‹¬ì€ ìˆ˜í•™ì ìœ¼ë¡œ ì—°ê´€ëœ ë‘ ê°œì˜ í‚¤ë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ì ì…ë‹ˆë‹¤:

1. **ê³µê°œí‚¤ (Public Key)**
   - ëˆ„êµ¬ë‚˜ ì ‘ê·¼ ê°€ëŠ¥í•œ ê³µê°œ ì •ë³´
   - ë©”ì‹œì§€ ì•”í˜¸í™”ì— ì‚¬ìš©
   - ë””ì§€í„¸ ì„œëª… ê²€ì¦ì— í™œìš©
   - ì¸ì¦ì„œì— í¬í•¨ë˜ì–´ ë°°í¬ ê°€ëŠ¥

2. **ê°œì¸í‚¤ (Private Key)**
   - ì ˆëŒ€ ê³µê°œë˜ì§€ ì•Šì•„ì•¼ í•¨
   - ì•”í˜¸í™”ëœ ë©”ì‹œì§€ ë³µí˜¸í™”ì— ì‚¬ìš©
   - ë””ì§€í„¸ ì„œëª… ìƒì„±ì— í™œìš©
   - ì•ˆì „í•œ ì €ì¥ì†Œì— ë³´ê´€ í•„ìˆ˜

```go
// ê³µê°œí‚¤/ê°œì¸í‚¤ ìŒ ìƒì„± ì˜ˆì‹œ
import (
    "crypto/rsa"
    "crypto/rand"
)

func generateKeyPair(bits int) (*rsa.PrivateKey, *rsa.PublicKey, error) {
    // ê°œì¸í‚¤ ìƒì„± (ê³µê°œí‚¤ í¬í•¨)
    privateKey, err := rsa.GenerateKey(rand.Reader, bits)
    if err != nil {
        return nil, nil, err
    }
    
    // ê³µê°œí‚¤ ì¶”ì¶œ
    publicKey := &privateKey.PublicKey
    
    return privateKey, publicKey, nil
}
```

### 2.1.2 ëŒ€ì¹­ ì•”í˜¸í™”ì™€ì˜ ì°¨ì´ì 

ë‘ ì•”í˜¸í™” ë°©ì‹ì˜ ì£¼ìš” ì°¨ì´ì ì„ ì´í•´í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤:

| íŠ¹ì„± | ëŒ€ì¹­ ì•”í˜¸í™” | ë¹„ëŒ€ì¹­ ì•”í˜¸í™” |
|------|------------|--------------|
| í‚¤ ê°œìˆ˜ | ë‹¨ì¼ í‚¤ | í‚¤ ìŒ (ê³µê°œí‚¤/ê°œì¸í‚¤) |
| ì†ë„ | ë¹ ë¦„ | ìƒëŒ€ì ìœ¼ë¡œ ëŠë¦¼ |
| í‚¤ ê¸¸ì´ | 128-256ë¹„íŠ¸ | 2048-4096ë¹„íŠ¸ |
| í‚¤ ê´€ë¦¬ | ë³µì¡í•¨ | ìƒëŒ€ì ìœ¼ë¡œ ë‹¨ìˆœ |
| ì£¼ìš” ìš©ë„ | ëŒ€ìš©ëŸ‰ ë°ì´í„° ì•”í˜¸í™” | í‚¤ êµí™˜, ì¸ì¦, ì„œëª… |

### 2.1.3 ì‘ë™ ì›ë¦¬ì™€ ìˆ˜í•™ì  ê¸°ë°˜

ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ ë³´ì•ˆì„±ì€ ìˆ˜í•™ì  ë‚œì œì— ê¸°ë°˜í•©ë‹ˆë‹¤:

1. **RSAì˜ ê²½ìš°**
   - í° ìˆ˜ì˜ ì¸ìˆ˜ë¶„í•´ ë¬¸ì œ
   - ëª¨ë“ˆëŸ¬ ì—°ì‚°ì˜ íŠ¹ì„± í™œìš©
   - ì˜¤ì¼ëŸ¬ í•¨ìˆ˜ì™€ í˜ë¥´ë§ˆì˜ ì†Œì •ë¦¬ ì‘ìš©

2. **ECCì˜ ê²½ìš°**
   - íƒ€ì›ê³¡ì„  ìƒì˜ ì´ì‚°ë¡œê·¸ ë¬¸ì œ
   - ì  ê³±ì…ˆ ì—°ì‚°ì˜ ë¹„ê°€ì—­ì„±
   - ìœ í•œì²´ ìƒì˜ ìˆ˜í•™ì  íŠ¹ì„±

## 2.2 ì£¼ìš” íŠ¹ì§•

### 2.2.1 ë³´ì•ˆì„±ê³¼ ì‹ ë¢°ì„±

ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ ë³´ì•ˆì„±ì€ ë‹¤ìŒ ìš”ì†Œë“¤ì— ì˜í•´ ë³´ì¥ë©ë‹ˆë‹¤:

1. **ìˆ˜í•™ì  ì•ˆì „ì„±**
   - ê³„ì‚°ì ìœ¼ë¡œ ì–´ë ¤ìš´ ë¬¸ì œì— ê¸°ë°˜
   - í˜„ì¬ ê¸°ìˆ ë¡œ í•´ê²° ë¶ˆê°€ëŠ¥í•œ ì‹œê°„ ë³µì¡ë„
   - ì–‘ì ì»´í“¨íŒ…ì— ëŒ€í•œ ê³ ë ¤ í•„ìš”

2. **í‚¤ ê´€ë¦¬ì˜ ì•ˆì „ì„±**
   ```go
   // ì•ˆì „í•œ í‚¤ ì €ì¥ ì˜ˆì‹œ
   func storePrivateKey(key *rsa.PrivateKey, filename string) error {
       // PEM í˜•ì‹ìœ¼ë¡œ ì¸ì½”ë”©
       keyBytes := x509.MarshalPKCS1PrivateKey(key)
       block := &pem.Block{
           Type:  "RSA PRIVATE KEY",
           Bytes: keyBytes,
       }
       
       // ì•”í˜¸í™”ëœ í˜•íƒœë¡œ ì €ì¥
       return ioutil.WriteFile(filename, pem.EncodeToMemory(block), 0600)
   }
   ```

3. **í”„ë¡œí† ì½œ ì•ˆì „ì„±**
   - ì ì ˆí•œ íŒ¨ë”© ì‚¬ìš©
   - ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±
   - ìµœì‹  ë³´ì•ˆ ê¶Œì¥ì‚¬í•­ ì¤€ìˆ˜

### 2.2.2 í‚¤ ê´€ë¦¬ì˜ ìš©ì´ì„±

íš¨ìœ¨ì ì¸ í‚¤ ê´€ë¦¬ë¥¼ ìœ„í•œ ì£¼ìš” ê³ ë ¤ì‚¬í•­:

1. **í‚¤ ìƒì„±**
   - ì¶©ë¶„í•œ ì—”íŠ¸ë¡œí”¼ í™•ë³´
   - ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±ê¸° ì‚¬ìš©
   - ì ì ˆí•œ í‚¤ ê¸¸ì´ ì„ íƒ

2. **í‚¤ ë°°í¬**
   - ê³µê°œí‚¤ ì¸ì¦ì„œ í™œìš©
   - ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì±„ë„ ì‚¬ìš©
   - í‚¤ ìœ íš¨ì„± ê²€ì¦

3. **í‚¤ ì €ì¥**
   - ì•ˆì „í•œ ì €ì¥ì†Œ ì‚¬ìš©
   - ì ‘ê·¼ ì œì–´ êµ¬í˜„
   - ì •ê¸°ì ì¸ ë°±ì—…

### 2.2.3 ì„±ëŠ¥ê³¼ ë¦¬ì†ŒìŠ¤ ìš”êµ¬ì‚¬í•­

ë¹„ëŒ€ì¹­ ì•”í˜¸í™” êµ¬í˜„ ì‹œ ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­:

1. **ì²˜ë¦¬ ì†ë„**
   - CPU ì§‘ì•½ì  ì—°ì‚°
   - í•˜ë“œì›¨ì–´ ê°€ì† í™œìš©
   - ë°°ì¹˜ ì²˜ë¦¬ ìµœì í™”

2. **ë©”ëª¨ë¦¬ ì‚¬ìš©**
   - í° í‚¤ í¬ê¸°ë¡œ ì¸í•œ ë©”ëª¨ë¦¬ ë¶€ë‹´
   - íš¨ìœ¨ì ì¸ ë©”ëª¨ë¦¬ ê´€ë¦¬ í•„ìš”
   - ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ì¤‘ìš”

```go
// ì„±ëŠ¥ ìµœì í™” ì˜ˆì‹œ
func optimizedEncryption(publicKey *rsa.PublicKey, messages [][]byte) [][]byte {
    results := make([][]byte, len(messages))
    var wg sync.WaitGroup
    
    // ì‘ì—…ì í’€ ìƒì„±
    workers := runtime.NumCPU()
    queue := make(chan int, len(messages))
    
    // ë³‘ë ¬ ì²˜ë¦¬
    for i := 0; i < workers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for idx := range queue {
                encrypted, err := rsa.EncryptPKCS1v15(
                    rand.Reader,
                    publicKey,
                    messages[idx],
                )
                if err == nil {
                    results[idx] = encrypted
                }
            }
        }()
    }
    
    // ì‘ì—… ë¶„ë°°
    for i := range messages {
        queue <- i
    }
    close(queue)
    wg.Wait()
    
    return results
}
```

## 2.3 ê¸°ë°˜ ìˆ˜í•™ ì´ë¡ 

### 2.3.1 ì •ìˆ˜ë¡ ê³¼ ëª¨ë“ˆëŸ¬ ì—°ì‚°

ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ ìˆ˜í•™ì  ê¸°ì´ˆ:

1. **ëª¨ë“ˆëŸ¬ ì—°ì‚°**
    - í•©ë™ ê´€ê³„: $a \equiv b \pmod{n}$ ëŠ” $n$ì´ $a-b$ë¥¼ ë‚˜ëˆˆë‹¤ëŠ” ì˜ë¯¸
    - ëª¨ë“ˆëŸ¬ ì—­ì›: $a \cdot a^{-1} \equiv 1 \pmod{n}$
    - ì˜¤ì¼ëŸ¬ í•¨ìˆ˜ $\phi(n)$: $n$ê³¼ ì„œë¡œì†Œì¸ ì–‘ì˜ ì •ìˆ˜ì˜ ê°œìˆ˜
    - í˜ë¥´ë§ˆì˜ ì†Œì •ë¦¬: ì†Œìˆ˜ $p$ì— ëŒ€í•´ $a^{p-1} \equiv 1 \pmod{p}$
    - ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬(ì—°ë¦½ í•­ë“±ì‹ í•´ê²°):
    $$
        \begin{align*}
        x &\equiv a_1 \pmod{m_1} \\
        x &\equiv a_2 \pmod{m_2} \\
        &\vdots \\
        x &\equiv a_n \pmod{m_n}
        \end{align*}
    $$
    - ì—¬ê¸°ì„œ $m_1, m_2, \ldots, m_n$ì€ ì„œë¡œì†Œì´ê³ , í•´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì£¼ì–´ì§:
    $$x \equiv \sum_{i=1}^n a_i M_i y_i \pmod{M}$$
    - ë‹¨, $M = m_1 m_2 \cdots m_n$ì´ê³ , $M_i = M/m_i$ì´ë©°,
    $y_i$ëŠ” $M_i y_i \equiv 1 \pmod{m_i}$ë¥¼ ë§Œì¡±í•˜ëŠ” ê°’

2. **ì†Œìˆ˜ ì´ë¡ **
   - ì†Œìˆ˜ íŒë³„
   - ì†Œì¸ìˆ˜ë¶„í•´
   - ì†Œìˆ˜ ìƒì„±

```go
// ì†Œìˆ˜ íŒë³„ ì˜ˆì‹œ
func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}
```

### 2.3.2 íƒ€ì›ê³¡ì„  ìˆ˜í•™

ECCì˜ ìˆ˜í•™ì  ê¸°ë°˜:

1. **íƒ€ì›ê³¡ì„ ì˜ ì •ì˜**
   - ë°”ì´ì–´ìŠ¤íŠ¸ë¼ìŠ¤ ë°©ì •ì‹: $y^2 = x^3 + ax + b$
   - íŒë³„ì‹: $\Delta = -16(4a^3 + 27b^2)$
   - ì ì˜ ë§ì…ˆ ì—°ì‚°:
     - $P_1(x_1,y_1)$ì™€ $P_2(x_2,y_2)$ì— ëŒ€í•´
     - ê¸°ìš¸ê¸° $s = \frac{y_2-y_1}{x_2-x_1}$ (ë‘ ì ì´ ë‹¤ë¥¸ ê²½ìš°)
     - ê¸°ìš¸ê¸° $s = \frac{3x_1^2 + a}{2y_1}$ (ë‘ ì ì´ ê°™ì€ ê²½ìš°)
     - ìƒˆë¡œìš´ ì  $P_3(x_3,y_3)$:
       $x_3 = s^2 - x_1 - x_2$
       $y_3 = s(x_1 - x_3) - y_1$
   - ë¬´í•œì›ì  $\mathcal{O}$ (êµ°ì˜ í•­ë“±ì›)

2. **ìœ í•œì²´ ìƒì˜ ì—°ì‚°**
   - ì²´ì˜ íŠ¹ì„±: ì†Œìˆ˜ $p$ì— ëŒ€í•œ ìœ í•œì²´ $\mathbb{F}_p$
   - ìŠ¤ì¹¼ë¼ ê³±ì…ˆ: $k$ íšŸìˆ˜ë§Œí¼ì˜ ì  ë§ì…ˆ $kP = P + P + \cdots + P$
   - ì´ì‚°ë¡œê·¸ ë¬¸ì œ: $Q = kP$ì¼ ë•Œ $k$ ì°¾ê¸°
   - íƒ€ì›ê³¡ì„  ì´ì‚°ë¡œê·¸ ë¬¸ì œ(ECDLP):
     ì£¼ì–´ì§„ ì  $P$ì™€ $Q = kP$ì— ëŒ€í•´ $k$ ì°¾ê¸°ê°€ ì–´ë ¤ì›€
   - ì  ì••ì¶•: $(x,y)$ ì¢Œí‘œì—ì„œ $x$ì™€ $y$ì˜ ë¶€í˜¸ë§Œ ì €ì¥
     $y^2 \equiv x^3 + ax + b \pmod{p}$

### 2.3.3 ì•”í˜¸í•™ì  ì•ˆì „ì„±

ë³´ì•ˆ ê°•ë„ëŠ” ìˆ˜í•™ì  ë¬¸ì œì˜ ì–´ë ¤ì›€ì— ê¸°ë°˜í•©ë‹ˆë‹¤:

1. **RSA ë³´ì•ˆì„±**
   - ì¸ìˆ˜ë¶„í•´ ë¬¸ì œ: $n = p \cdot q$ ì—ì„œ $p$, $q$ ì°¾ê¸°
   - ê³µê°œí‚¤: $(n,e)$, ê°œì¸í‚¤: $d$
   - ì•”í˜¸í™”: $c = m^e \bmod n$
   - ë³µí˜¸í™”: $m = c^d \bmod n$
   - $ed \equiv 1 \pmod{\phi(n)}$ ê´€ê³„ ì„±ë¦½

2. **ECC ë³´ì•ˆì„±**
   - ì  ê³±ì…ˆì˜ ì¼ë°©í–¥ì„±: $Q = kP$
   - $k$ì˜ ë¹„íŠ¸ ê¸¸ì´ê°€ ì•ˆì „ì„± ê²°ì •
   - ê¶Œì¥ ë¹„íŠ¸ ê¸¸ì´: $\geq 256$ bits

ë³´ì•ˆ ê°•ë„ í‰ê°€ ê¸°ì¤€:

1. **ê³„ì‚°ì  ë³µì¡ë„**
   - ìµœì„ ì˜ ì•Œë ¤ì§„ ê³µê²© ì•Œê³ ë¦¬ì¦˜
   - í•„ìš”í•œ ê³„ì‚° ìì›
   - ì‹¤í˜„ ê°€ëŠ¥í•œ ê³µê²© ì‹œê°„

2. **ê¶Œì¥ í‚¤ ê¸¸ì´**
   - ìš©ë„ë³„ ìµœì†Œ í‚¤ ê¸¸ì´
   - ë¯¸ë˜ ë³´ì•ˆì„± ê³ ë ¤
   - ì •ê¸°ì ì¸ ê°±ì‹  ê³„íš

## ì‘ìš© ë° ì‹¤ì œ êµ¬í˜„

### êµ¬í˜„ ì‹œ ê³ ë ¤ì‚¬í•­

1. **ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„ íƒ**
   - ê²€ì¦ëœ ì•”í˜¸í™” ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
   - ìµœì‹  ë²„ì „ ìœ ì§€
   - ë³´ì•ˆ ì—…ë°ì´íŠ¸ ê´€ë¦¬

2. **ì˜¤ë¥˜ ì²˜ë¦¬**
   ```go
   // ì•ˆì „í•œ ì˜¤ë¥˜ ì²˜ë¦¬ ì˜ˆì‹œ
   func secureEncrypt(publicKey *rsa.PublicKey, message []byte) ([]byte, error) {
       if len(message) > maxMessageLength {
           return nil, errors.New("ë©”ì‹œì§€ê°€ ë„ˆë¬´ ê¹ë‹ˆë‹¤")
       }
       
       encrypted, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey, message)
       if err != nil {
           // êµ¬ì²´ì ì¸ ì˜¤ë¥˜ ì •ë³´ ë…¸ì¶œ ë°©ì§€
           return nil, errors.New("ì•”í˜¸í™” ì‘ì—… ì‹¤íŒ¨")
       }
       
       return encrypted, nil
   }
   ```

3. **ë³´ì•ˆ ëª¨ë‹ˆí„°ë§**
   - ì‘ì—… ë¡œê¹…
   - ì´ìƒ ì§•í›„ íƒì§€
   - ê°ì‚¬ ì¶”ì  ìœ ì§€

## ë§ˆë¬´ë¦¬

ë¹„ëŒ€ì¹­ ì•”í˜¸í™”ì˜ ê¸°ì´ˆë¥¼ ì´í•´í•˜ëŠ” ê²ƒì€ í˜„ëŒ€ ë³´ì•ˆ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ê³  ìš´ì˜í•˜ëŠ”ë° í•„ìˆ˜ì ì…ë‹ˆë‹¤. ì´ì–´ì§€ëŠ” ì¥ì—ì„œëŠ” RSAì™€ ECC ê°™ì€ êµ¬ì²´ì ì¸ ì•Œê³ ë¦¬ì¦˜ê³¼ ê·¸ êµ¬í˜„ì— ëŒ€í•´ ìì„¸íˆ ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤.

### ë‹¤ìŒ í•™ìŠµ ì£¼ì œ
- RSA ì•Œê³ ë¦¬ì¦˜ ìƒì„¸ ë¶„ì„
- ECC êµ¬í˜„ê³¼ ì‘ìš©
- ë””ì§€í„¸ ì„œëª… í”„ë¡œí† ì½œ
- í‚¤ êµí™˜ ë©”ì»¤ë‹ˆì¦˜

---

# 3. RSA (Rivest-Shamir-Adleman)

RSAëŠ” 1977ë…„ Ron Rivest, Adi Shamir, Leonard Adlemanì´ ê°œë°œí•œ ìµœì´ˆì˜ ì‹¤ìš©ì ì¸ ê³µê°œí‚¤ ì•”í˜¸ ì‹œìŠ¤í…œì…ë‹ˆë‹¤. í° ìˆ˜ì˜ ì¸ìˆ˜ë¶„í•´ ë¬¸ì œì˜ ì–´ë ¤ì›€ì— ê¸°ë°˜í•˜ì—¬ ì„¤ê³„ë˜ì—ˆìœ¼ë©°, í˜„ì¬ê¹Œì§€ë„ ê°€ì¥ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ë¹„ëŒ€ì¹­ ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.

## 3.1 RSA ì•Œê³ ë¦¬ì¦˜ ì´í•´

### 3.1.1 ê¸°ë³¸ ì›ë¦¬ì™€ ìˆ˜í•™ì  ë°°ê²½

RSAì˜ ì•ˆì „ì„±ì€ ë‹¤ìŒê³¼ ê°™ì€ ìˆ˜í•™ì  ì›ë¦¬ì— ê¸°ë°˜í•©ë‹ˆë‹¤:

1. **ì†Œì¸ìˆ˜ë¶„í•´ì˜ ì–´ë ¤ì›€**
   - ë‘ í° ì†Œìˆ˜ì˜ ê³± $n = p \cdot q$ì—ì„œ $p$ì™€ $q$ë¥¼ ì°¾ëŠ” ê²ƒì´ ì–´ë ¤ì›€
   - $n$ì´ ì»¤ì§ˆìˆ˜ë¡ ì¸ìˆ˜ë¶„í•´ëŠ” ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ì–´ë ¤ì›Œì§
   - í˜„ì¬ ì•Œë ¤ì§„ ìµœì„ ì˜ ì•Œê³ ë¦¬ì¦˜ë„ ì¤€ì§€ìˆ˜ ì‹œê°„ í•„ìš”

2. **ì˜¤ì¼ëŸ¬ í•¨ìˆ˜ì™€ ëª¨ë“ˆëŸ¬ ì—°ì‚°**
   - ì˜¤ì¼ëŸ¬ í•¨ìˆ˜ $\phi(n) = (p-1)(q-1)$
   - $\phi(n)$ì„ ì•Œë©´ ê°œì¸í‚¤ë¥¼ ê³„ì‚°í•  ìˆ˜ ìˆìŒ
   - ëª¨ë“ˆëŸ¬ ì—°ì‚°ì˜ íŠ¹ì„±: $(m^e)^d \equiv m \pmod{n}$

3. **í˜ë¥´ë§ˆì˜ ì†Œì •ë¦¬ ì‘ìš©**
   - ì†Œìˆ˜ $p$ì— ëŒ€í•´ $a^{p-1} \equiv 1 \pmod{p}$
   - RSAì—ì„œ ë©”ì‹œì§€ ë³µêµ¬ì˜ ìˆ˜í•™ì  ê¸°ë°˜
   - $ed \equiv 1 \pmod{\phi(n)}$ ê´€ê³„ í™œìš©

### 3.1.2 í‚¤ ìƒì„± ê³¼ì •

RSA í‚¤ ìƒì„±ì€ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤:

1. **ì†Œìˆ˜ ìƒì„±**
   ```go
   func generateLargePrime(bits int) (*big.Int, error) {
       for {
           // ì§€ì •ëœ ë¹„íŠ¸ ìˆ˜ì˜ ì†Œìˆ˜ í›„ë³´ ìƒì„±
           n, err := rand.Prime(rand.Reader, bits)
           if err != nil {
               return nil, err
           }
           
           // ì¶”ê°€ ê²€ì¦
           if n.ProbablyPrime(20) {
               return n, nil
           }
       }
   }
   ```

2. **ê³µê°œí‚¤ì™€ ê°œì¸í‚¤ ê³„ì‚°**
   - $n = p \cdot q$ ê³„ì‚°
   - $\phi(n) = (p-1)(q-1)$ ê³„ì‚°
   - ê³µê°œ ì§€ìˆ˜ $e$ ì„ íƒ (ì¼ë°˜ì ìœ¼ë¡œ 65537)
   - ê°œì¸ ì§€ìˆ˜ $d$ ê³„ì‚°: $d \cdot e \equiv 1 \pmod{\phi(n)}$

```go
func generateRSAKey(bits int) (*rsa.PrivateKey, error) {
    // ë‘ ì†Œìˆ˜ ìƒì„±
    p, err := generateLargePrime(bits / 2)
    if err != nil {
        return nil, err
    }
    q, err := generateLargePrime(bits / 2)
    if err != nil {
        return nil, err
    }
    
    // nê³¼ Ï†(n) ê³„ì‚°
    n := new(big.Int).Mul(p, q)
    phi := new(big.Int).Mul(
        new(big.Int).Sub(p, big.NewInt(1)),
        new(big.Int).Sub(q, big.NewInt(1)),
    )
    
    // ê³µê°œ ì§€ìˆ˜ e ì„¤ì •
    e := big.NewInt(65537)
    
    // ê°œì¸ ì§€ìˆ˜ d ê³„ì‚°
    d := new(big.Int).ModInverse(e, phi)
    
    return &rsa.PrivateKey{
        PublicKey: rsa.PublicKey{N: n, E: 65537},
        D: d,
        Primes: []*big.Int{p, q},
    }, nil
}
```

### 3.1.3 ì•”í˜¸í™”/ë³µí˜¸í™” ê³¼ì •

RSA ì—°ì‚°ì˜ í•µì‹¬ ìˆ˜ì‹:

1. **ì•”í˜¸í™”**
   - í‰ë¬¸ $m$ì— ëŒ€í•´: $c = m^e \bmod n$
   - ê³µê°œí‚¤ $(n,e)$ ì‚¬ìš©

2. **ë³µí˜¸í™”**
   - ì•”í˜¸ë¬¸ $c$ì— ëŒ€í•´: $m = c^d \bmod n$
   - ê°œì¸í‚¤ $d$ ì‚¬ìš©

```go
func RSAEncrypt(publicKey *rsa.PublicKey, message []byte) ([]byte, error) {
    // PKCS#1 v1.5 íŒ¨ë”© ì‚¬ìš©
    return rsa.EncryptPKCS1v15(rand.Reader, publicKey, message)
}

func RSADecrypt(privateKey *rsa.PrivateKey, ciphertext []byte) ([]byte, error) {
    return rsa.DecryptPKCS1v15(rand.Reader, privateKey, ciphertext)
}
```

## 3.2 RSA êµ¬í˜„

### 3.2.1 ì•ˆì „í•œ êµ¬í˜„ì„ ìœ„í•œ ê³ ë ¤ì‚¬í•­

1. **ì ì ˆí•œ í‚¤ ê¸¸ì´ ì„ íƒ**
   - 2024ë…„ ê¸°ì¤€ ìµœì†Œ 2048ë¹„íŠ¸ ê¶Œì¥
   - ì¥ê¸° ë³´ì•ˆì€ 4096ë¹„íŠ¸ ê³ ë ¤
   - í‚¤ ê¸¸ì´ì™€ ì„±ëŠ¥ ê°„ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„

2. **íŒ¨ë”© schemes**
   - PKCS#1 v1.5: ë ˆê±°ì‹œ ì‹œìŠ¤í…œ
   - OAEP (Optimal Asymmetric Encryption Padding):
     $EM = maskedSeed || maskedDB$
     ì—¬ê¸°ì„œ $DB = lHash || PS || 01 || M$

3. **ë‚œìˆ˜ ìƒì„±**
   ```go
   func generateRandomBytes(size int) ([]byte, error) {
       buf := make([]byte, size)
       _, err := rand.Read(buf)
       if err != nil {
           return nil, err
       }
       return buf, nil
   }
   ```

### 3.2.2 ì‹¤ì œ êµ¬í˜„ ì˜ˆì‹œ

ë©”ì‹œì§€ ì„œëª…ê³¼ ê²€ì¦ êµ¬í˜„:

```go
// RSA ì„œëª… ìƒì„±
func SignMessage(privateKey *rsa.PrivateKey, message []byte) ([]byte, error) {
    // SHA-256 í•´ì‹œ ê³„ì‚°
    hashed := sha256.Sum256(message)
    
    // PSS íŒ¨ë”©ì„ ì‚¬ìš©í•œ ì„œëª…
    signature, err := rsa.SignPSS(
        rand.Reader,
        privateKey,
        crypto.SHA256,
        hashed[:],
        nil,
    )
    return signature, err
}

// RSA ì„œëª… ê²€ì¦
func VerifySignature(
    publicKey *rsa.PublicKey,
    message []byte,
    signature []byte,
) error {
    hashed := sha256.Sum256(message)
    return rsa.VerifyPSS(
        publicKey,
        crypto.SHA256,
        hashed[:],
        signature,
        nil,
    )
}
```

## 3.3 RSA ìµœì í™”

### 3.3.1 ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬(CRT) í™œìš©

CRTë¥¼ ì´ìš©í•œ RSA ë³µí˜¸í™” ìµœì í™”:

$m_p = c^d \bmod p$
$m_q = c^d \bmod q$

ìµœì¢… ë©”ì‹œì§€ ë³µì›:
$m = (((m_p - m_q) \cdot q_{inv} \bmod p) \cdot q + m_q)$

ì—¬ê¸°ì„œ $q_{inv}$ëŠ” $q$ì˜ $p$ì— ëŒ€í•œ ëª¨ë“ˆëŸ¬ ì—­ì›

```go
func DecryptCRT(privateKey *rsa.PrivateKey, ciphertext []byte) []byte {
    c := new(big.Int).SetBytes(ciphertext)
    p := privateKey.Primes[0]
    q := privateKey.Primes[1]
    
    // dp = d mod (p-1)
    dp := new(big.Int).Mod(privateKey.D, new(big.Int).Sub(p, big.NewInt(1)))
    // dq = d mod (q-1)
    dq := new(big.Int).Mod(privateKey.D, new(big.Int).Sub(q, big.NewInt(1)))
    
    // mp = c^dp mod p
    mp := new(big.Int).Exp(c, dp, p)
    // mq = c^dq mod q
    mq := new(big.Int).Exp(c, dq, q)
    
    // h = qinv * (mp - mq) mod p
    h := new(big.Int).Sub(mp, mq)
    h.Mul(h, privateKey.Precomputed.Qinv)
    h.Mod(h, p)
    
    // m = h * q + mq
    m := new(big.Int).Mul(h, q)
    m.Add(m, mq)
    
    return m.Bytes()
}
```

### 3.3.2 ë©€í‹°í”„ë¼ì„ RSA

ì„¸ ê°œ ì´ìƒì˜ ì†Œìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ë³€í˜•:

$n = p_1 \cdot p_2 \cdot p_3 \cdot ... \cdot p_k$

$\phi(n) = (p_1-1)(p_2-1)(p_3-1)...(p_k-1)$

ì¥ì ê³¼ ì£¼ì˜ì‚¬í•­:
- CRTë¥¼ í†µí•œ ë” ë¹ ë¥¸ ë³µí˜¸í™”
- ì†Œìˆ˜ ê°œìˆ˜ ì¦ê°€ì— ë”°ë¥¸ ë³´ì•ˆì„± ê°ì†Œ
- ì¼ë°˜ì ìœ¼ë¡œ 3-4ê°œ ì†Œìˆ˜ ì‚¬ìš© ê¶Œì¥

### 3.3.3 í•˜ë“œì›¨ì–´ ê°€ì†

1. **ì „ìš© ì•”í˜¸í™” ì¹©**
   - TPM (Trusted Platform Module)
   - HSM (Hardware Security Module)
   - ì•”í˜¸í™” ê°€ì† ëª…ë ¹ì–´ ì„¸íŠ¸

2. **ë³‘ë ¬ ì²˜ë¦¬**
   ```go
   func ParallelRSAEncrypt(
       publicKey *rsa.PublicKey,
       messages [][]byte,
   ) [][]byte {
       results := make([][]byte, len(messages))
       var wg sync.WaitGroup
       
       workers := runtime.NumCPU()
       for i := 0; i < workers; i++ {
           wg.Add(1)
           go func(start int) {
               defer wg.Done()
               for j := start; j < len(messages); j += workers {
                   encrypted, _ := RSAEncrypt(publicKey, messages[j])
                   results[j] = encrypted
               }
           }(i)
       }
       
       wg.Wait()
       return results
   }
   ```

## 3.4 RSA ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 3.4.1 ì•Œë ¤ì§„ ê³µê²©ê³¼ ëŒ€ì‘

1. **ì„ íƒ ì•”í˜¸ë¬¸ ê³µê²© (CCA)**
   - PKCS#1 v1.5 íŒ¨ë”©ì˜ ì·¨ì•½ì 
   - OAEP íŒ¨ë”© ì‚¬ìš© ê¶Œì¥
   - íŒ¨ë”© ì˜¤ë¼í´ ê³µê²© ì£¼ì˜

2. **íƒ€ì´ë° ê³µê²©**
   - ì¼ì • ì‹œê°„ ì—°ì‚° êµ¬í˜„
   - ë¸”ë¼ì¸ë”© ê¸°ë²• ì‚¬ìš©
   - í•˜ë“œì›¨ì–´ ë ˆë²¨ ë³´í˜¸

3. **ê³µí†µ ëª¨ë“ˆëŸ¬ìŠ¤ ê³µê²©**
   - ì„œë¡œ ë‹¤ë¥¸ ì‚¬ìš©ìê°„ $n$ ê³µìœ  ê¸ˆì§€
   - ë…ë¦½ì ì¸ í‚¤ ìŒ ìƒì„±
   - ì•ˆì „í•œ ì†Œìˆ˜ ìƒì„± ê²€ì¦

### 3.4.2 ì•ˆì „í•œ êµ¬í˜„ ì§€ì¹¨

1. **í‚¤ ê´€ë¦¬**
   - ì•ˆì „í•œ í‚¤ ì €ì¥ì†Œ ì‚¬ìš©
   - ì •ê¸°ì ì¸ í‚¤ ê°±ì‹ 
   - ë°±ì—… ë° ë³µêµ¬ ì ˆì°¨

2. **ì˜¤ë¥˜ ì²˜ë¦¬**
   ```go
   func SafeRSADecrypt(
       privateKey *rsa.PrivateKey,
       ciphertext []byte,
   ) ([]byte, error) {
       if len(ciphertext) != privateKey.Size() {
           return nil, errors.New("ì˜ëª»ëœ ì•”í˜¸ë¬¸ í¬ê¸°")
       }
       
       plaintext, err := RSADecrypt(privateKey, ciphertext)
       if err != nil {
           // êµ¬ì²´ì ì¸ ì˜¤ë¥˜ ì •ë³´ ë…¸ì¶œ ë°©ì§€
           return nil, errors.New("ë³µí˜¸í™” ì‹¤íŒ¨")
       }
       
       return plaintext, nil
   }
   ```

## ë§ˆë¬´ë¦¬

RSAëŠ” ìˆ˜í•™ì ìœ¼ë¡œ ì¦ëª…ëœ ì•ˆì „ì„±ê³¼ ì‹¤ìš©ì„±ì„ ê²¸ë¹„í•œ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ì˜¬ë°”ë¥¸ êµ¬í˜„ê³¼ ìš´ì˜ì„ ìœ„í•´ì„œëŠ” ë§ì€ ë³´ì•ˆ ê³ ë ¤ì‚¬í•­ë“¤ì„ ìˆ™ì§€í•˜ê³  ì ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

### ì¶”ê°€ í•™ìŠµ ì£¼ì œ
- ì–‘ì ë‚´ì„± ì•”í˜¸í™”ë¡œì˜ ì „í™˜ ì¤€ë¹„
- RSA ê¸°ë°˜ í”„ë¡œí† ì½œ ë¶„ì„
- í•˜ì´ë¸Œë¦¬ë“œ ì•”í˜¸í™” ì‹œìŠ¤í…œ ì„¤ê³„
- ì„±ëŠ¥ ìµœì í™” ê¸°ë²• ì—°êµ¬

---

# 4. ECC (Elliptic Curve Cryptography)

íƒ€ì›ê³¡ì„  ì•”í˜¸í™”(ECC)ëŠ” í˜„ëŒ€ ì•”í˜¸í•™ì˜ í•µì‹¬ ê¸°ìˆ ë¡œ, RSAì— ë¹„í•´ ì§§ì€ í‚¤ ê¸¸ì´ë¡œë„ ë™ë“±í•œ ë³´ì•ˆ ìˆ˜ì¤€ì„ ì œê³µí•  ìˆ˜ ìˆëŠ” íš¨ìœ¨ì ì¸ ì•”í˜¸í™” ë°©ì‹ì…ë‹ˆë‹¤. ë³¸ ë¬¸ì„œì—ì„œëŠ” ECCì˜ ìˆ˜í•™ì  ê¸°ì´ˆë¶€í„° ì‹¤ì œ êµ¬í˜„ê¹Œì§€ ìƒì„¸íˆ ë‹¤ë£¹ë‹ˆë‹¤.

## 4.1 íƒ€ì›ê³¡ì„  ì•”í˜¸í™” ê¸°ì´ˆ

### 4.1.1 íƒ€ì›ê³¡ì„ ì˜ ìˆ˜í•™ì  ì´í•´

íƒ€ì›ê³¡ì„ ì€ ë‹¤ìŒê³¼ ê°™ì€ ë°”ì´ì–´ìŠ¤íŠ¸ë¼ìŠ¤ ë°©ì •ì‹ìœ¼ë¡œ ì •ì˜ë©ë‹ˆë‹¤:

$y^2 = x^3 + ax + b$

ì—¬ê¸°ì„œ $a$ì™€ $b$ëŠ” ê³¡ì„ ì˜ íŠ¹ì„±ì„ ê²°ì •í•˜ëŠ” ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤. ì•”í˜¸í™”ì— ì‚¬ìš©ë˜ëŠ” íƒ€ì›ê³¡ì„ ì€ ë‹¤ìŒ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•©ë‹ˆë‹¤:

1. **ë¹„íŠ¹ì´ì„± ì¡°ê±´**
   - íŒë³„ì‹ $\Delta = -16(4a^3 + 27b^2) \neq 0$
   - ì¤‘ë³µë˜ëŠ” ê·¼ì´ ì—†ì–´ì•¼ í•¨

2. **ìœ í•œì²´ ìƒì˜ ì •ì˜**
   - ì†Œìˆ˜ $p$ì— ëŒ€í•œ ìœ í•œì²´ $\mathbb{F}_p$ ìœ„ì—ì„œ ì •ì˜
   - ëª¨ë“  ì—°ì‚°ì€ ëª¨ë“ˆë¡œ $p$ë¡œ ìˆ˜í–‰
   - ë°©ì •ì‹: $y^2 \equiv x^3 + ax + b \pmod{p}$

### 4.1.2 ì  ì—°ì‚°ì˜ ê¸°í•˜í•™ì  ì˜ë¯¸

íƒ€ì›ê³¡ì„  ìƒì˜ ê¸°ë³¸ ì—°ì‚°ë“¤ì€ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë©ë‹ˆë‹¤:

1. **ì  ë§ì…ˆ**
   ë‘ ì  $P_1(x_1,y_1)$ì™€ $P_2(x_2,y_2)$ì˜ ë§ì…ˆ:
   ```
   ì ˆì°¨:
   1. ë‘ ì ì„ ì§€ë‚˜ëŠ” ì§ì„  ê³„ì‚°
   2. ì§ì„ ê³¼ ê³¡ì„ ì˜ ì„¸ ë²ˆì§¸ êµì  ì°¾ê¸°
   3. xì¶•ì— ëŒ€í•´ ëŒ€ì¹­ì´ë™
   ```

   ìˆ˜ì‹ìœ¼ë¡œëŠ”:
   $\lambda = \frac{y_2-y_1}{x_2-x_1}$ (ë‘ ì ì´ ë‹¤ë¥¸ ê²½ìš°)
   $\lambda = \frac{3x_1^2 + a}{2y_1}$ (ë‘ ì ì´ ê°™ì€ ê²½ìš°)

   $x_3 = \lambda^2 - x_1 - x_2$
   $y_3 = \lambda(x_1 - x_3) - y_1$

2. **ì  ë°°ìˆ˜**
   í•œ ì  $P$ë¥¼ $k$ë²ˆ ë”í•˜ëŠ” ì—°ì‚°: $Q = kP$
   ì´ëŠ” ECCì˜ í•µì‹¬ ë‹¨ë°©í–¥ í•¨ìˆ˜ì…ë‹ˆë‹¤.

```go
// íƒ€ì›ê³¡ì„  ì  êµ¬ì¡°ì²´
type ECPoint struct {
    X, Y *big.Int
    Curve *elliptic.Curve
}

// ì  ë§ì…ˆ êµ¬í˜„
func (p *ECPoint) Add(q *ECPoint) *ECPoint {
    if p.IsInfinity() {
        return q
    }
    if q.IsInfinity() {
        return p
    }

    // x1 â‰  x2 ì¸ ê²½ìš°ì˜ ë§ì…ˆ
    if p.X.Cmp(q.X) != 0 {
        slope := new(big.Int).Sub(q.Y, p.Y)
        temp := new(big.Int).Sub(q.X, p.X)
        slope.Mul(slope, new(big.Int).ModInverse(temp, p.Curve.P))
        
        x3 := new(big.Int).Mul(slope, slope)
        x3.Sub(x3, p.X)
        x3.Sub(x3, q.X)
        x3.Mod(x3, p.Curve.P)
        
        y3 := new(big.Int).Sub(p.X, x3)
        y3.Mul(y3, slope)
        y3.Sub(y3, p.Y)
        y3.Mod(y3, p.Curve.P)
        
        return &ECPoint{X: x3, Y: y3, Curve: p.Curve}
    }
    
    // ì ì˜ ë°°ê°€(Doubling)
    if p.X.Cmp(q.X) == 0 && p.Y.Cmp(q.Y) == 0 {
        slope := new(big.Int).Mul(p.X, p.X)
        slope.Mul(slope, big.NewInt(3))
        slope.Add(slope, p.Curve.A)
        temp := new(big.Int).Mul(p.Y, big.NewInt(2))
        slope.Mul(slope, new(big.Int).ModInverse(temp, p.Curve.P))
        
        x3 := new(big.Int).Mul(slope, slope)
        x3.Sub(x3, new(big.Int).Mul(p.X, big.NewInt(2)))
        x3.Mod(x3, p.Curve.P)
        
        y3 := new(big.Int).Sub(p.X, x3)
        y3.Mul(y3, slope)
        y3.Sub(y3, p.Y)
        y3.Mod(y3, p.Curve.P)
        
        return &ECPoint{X: x3, Y: y3, Curve: p.Curve}
    }
    
    return &ECPoint{X: big.NewInt(0), Y: big.NewInt(0), Curve: p.Curve}
}
```

### 4.1.3 ì£¼ìš” ì—°ì‚°ê³¼ íŠ¹ì„±

1. **ìŠ¤ì¹¼ë¼ ê³±ì…ˆ**
   ì  $P$ë¥¼ $k$ë²ˆ ë”í•˜ëŠ” ì—°ì‚°ì€ ë‹¤ìŒê³¼ ê°™ì´ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```go
// ì´ì¤‘ê³¼ ë§ì…ˆ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œ ìŠ¤ì¹¼ë¼ ê³±ì…ˆ
func (p *ECPoint) ScalarMult(k *big.Int) *ECPoint {
    result := &ECPoint{X: big.NewInt(0), Y: big.NewInt(0), Curve: p.Curve}
    temp := p
    
    // kì˜ ë¹„íŠ¸ë¥¼ ìˆœíšŒí•˜ë©° ê³„ì‚°
    for i := k.BitLen() - 1; i >= 0; i-- {
        result = result.Add(result)  // ì´ì¤‘
        if k.Bit(i) == 1 {
            result = result.Add(temp)  // ë§ì…ˆ
        }
    }
    
    return result
}
```

## 4.2 ECC êµ¬í˜„

### 4.2.1 í‚¤ ìŒ ìƒì„±

ECC í‚¤ ìŒ ìƒì„± ê³¼ì •:

1. ë„ë©”ì¸ ë§¤ê°œë³€ìˆ˜ ì„ íƒ:
   - íƒ€ì›ê³¡ì„  $E: y^2 = x^3 + ax + b$
   - ìœ í•œì²´ì˜ ìœ„ìˆ˜ $p$
   - ê¸°ì €ì  $G$ì™€ ê·¸ ìœ„ìˆ˜ $n$

2. ê°œì¸í‚¤/ê³µê°œí‚¤ ìƒì„±:
   - ê°œì¸í‚¤ $d$: $[1, n-1]$ ë²”ìœ„ì˜ ë¬´ì‘ìœ„ ì •ìˆ˜
   - ê³µê°œí‚¤ $Q = dG$

```go
func GenerateKeyPair(curve elliptic.Curve) (*PrivateKey, *PublicKey) {
    // ê°œì¸í‚¤ ìƒì„±
    privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)
    if err != nil {
        panic(err)
    }
    
    // ê³µê°œí‚¤ ì¶”ì¶œ
    publicKey := &privateKey.PublicKey
    
    return privateKey, publicKey
}
```

### 4.2.2 ECDH (Elliptic Curve Diffie-Hellman)

ECDHëŠ” í‚¤ êµí™˜ í”„ë¡œí† ì½œì˜ ECC ë²„ì „ì…ë‹ˆë‹¤:

1. **Aliceì˜ ê³¼ì •**:
   - ê°œì¸í‚¤ $d_A$ ì„ íƒ
   - ê³µê°œí‚¤ $Q_A = d_A G$ ê³„ì‚°
   - ê³µìœ  ë¹„ë°€ $S = d_A Q_B$ ê³„ì‚°

2. **Bobì˜ ê³¼ì •**:
   - ê°œì¸í‚¤ $d_B$ ì„ íƒ
   - ê³µê°œí‚¤ $Q_B = d_B G$ ê³„ì‚°
   - ê³µìœ  ë¹„ë°€ $S = d_B Q_A$ ê³„ì‚°

ê²°ê³¼ì ìœ¼ë¡œ $S = d_A d_B G$ê°€ ê³µìœ  ë¹„ë°€ì´ ë©ë‹ˆë‹¤.

```go
func GenerateSharedSecret(privateKey *ecdsa.PrivateKey, peerPublicKey *ecdsa.PublicKey) []byte {
    x, _ := curve25519.X25519(privateKey.D.Bytes(), peerPublicKey.X.Bytes())
    return x
}
```

### 4.2.3 ECDSA (Elliptic Curve Digital Signature Algorithm)

ECDSAëŠ” ë””ì§€í„¸ ì„œëª…ì„ ìœ„í•œ ECC ê¸°ë°˜ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤:

1. **ì„œëª… ìƒì„±**:
   - ì„ì‹œ í‚¤ $k$ ìƒì„±
   - $r = (kG)_x \bmod n$
   - $s = k^{-1}(H(m) + dr) \bmod n$
   ì—¬ê¸°ì„œ $H(m)$ì€ ë©”ì‹œì§€ì˜ í•´ì‹œê°’

2. **ì„œëª… ê²€ì¦**:
   - $w = s^{-1} \bmod n$
   - $u_1 = H(m)w \bmod n$
   - $u_2 = rw \bmod n$
   - $(x,y) = u_1G + u_2Q$
   - ê²€ì¦: $r \equiv x \pmod{n}$

```go
func SignMessage(privateKey *ecdsa.PrivateKey, message []byte) ([]byte, error) {
    // ë©”ì‹œì§€ í•´ì‹œ ê³„ì‚°
    hash := sha256.Sum256(message)
    
    // ECDSA ì„œëª… ìƒì„±
    r, s, err := ecdsa.Sign(rand.Reader, privateKey, hash[:])
    if err != nil {
        return nil, err
    }
    
    // ì„œëª… ì§ë ¬í™”
    signature := append(r.Bytes(), s.Bytes()...)
    return signature, nil
}
```

## 4.3 ECC vs RSA

### 4.3.1 ì„±ëŠ¥ ë¹„êµ

ë‹¤ìŒì€ ECCì™€ RSAì˜ ì£¼ìš” ì„±ëŠ¥ ì§€í‘œ ë¹„êµì…ë‹ˆë‹¤:

| ë³´ì•ˆ ìˆ˜ì¤€ | ECC í‚¤ ê¸¸ì´ | RSA í‚¤ ê¸¸ì´ | ìƒëŒ€ì  ì„±ëŠ¥ |
|----------|------------|------------|------------|
| 128ë¹„íŠ¸ | 256 | 3072 | ECC ì•½ 10ë°° ë¹ ë¦„ |
| 192ë¹„íŠ¸ | 384 | 7680 | ECC ì•½ 15ë°° ë¹ ë¦„ |
| 256ë¹„íŠ¸ | 512 | 15360 | ECC ì•½ 20ë°° ë¹ ë¦„ |

### 4.3.2 ë³´ì•ˆì„± ë¹„êµ

ECCì˜ ë³´ì•ˆ ê°•ë„ëŠ” íƒ€ì›ê³¡ì„  ì´ì‚°ë¡œê·¸ ë¬¸ì œ(ECDLP)ì˜ ì–´ë ¤ì›€ì— ê¸°ë°˜í•©ë‹ˆë‹¤:

$Q = kP$ ì—ì„œ $k$ë¥¼ ì°¾ëŠ” ë¬¸ì œ

ìµœì„ ì˜ ì•Œë ¤ì§„ ê³µê²© ì•Œê³ ë¦¬ì¦˜ì˜ ë³µì¡ë„:
- ECC: $O(\sqrt{n})$ (Pollard's rho)
- RSA: $O(e^{(\frac{64}{9}\log n)^{\frac{1}{3}}(\log \log n)^{\frac{2}{3}}})$ (GNFS)

### 4.3.3 ì‚¬ìš© ì‚¬ë¡€ë³„ ì„ íƒ ê¸°ì¤€

1. **ëª¨ë°”ì¼/IoT í™˜ê²½**
   - ì œí•œëœ ë¦¬ì†ŒìŠ¤
   - ì§§ì€ í‚¤ ê¸¸ì´ ì„ í˜¸
   - ECC ê¶Œì¥

2. **ì›¹ ì„œë²„ í™˜ê²½**
   - ì¶©ë¶„í•œ ì»´í“¨íŒ… íŒŒì›Œ
   - ë ˆê±°ì‹œ ì‹œìŠ¤í…œ í˜¸í™˜ì„±
   - RSA/ECC í˜¼ìš© ê°€ëŠ¥

3. **ì•”í˜¸í™” í†µì‹ **
   - ë¹ ë¥¸ í‚¤ êµí™˜ í•„ìš”
   - ë‚®ì€ ëŒ€ì—­í­ ì‚¬ìš©
   - ECDH ê¶Œì¥

## 4.4 ì•ˆì „í•œ êµ¬í˜„ê³¼ ìš´ì˜

### 4.4.1 ë³´ì•ˆ ë§¤ê°œë³€ìˆ˜ ì„ íƒ

ì•ˆì „í•œ ECC êµ¬í˜„ì„ ìœ„í•œ ê³ ë ¤ì‚¬í•­:

1. **í‘œì¤€ ê³¡ì„  ì„ íƒ**
   - NIST P-256 (secp256r1)
   - Curve25519
   - brainpoolP256r1

2. **ë„ë©”ì¸ ë§¤ê°œë³€ìˆ˜ ê²€ì¦**
   - ê³¡ì„  íŒë³„ì‹ í™•ì¸
   - ê¸°ì €ì  ìœ„ìˆ˜ ê²€ì¦
   - MOV ì¡°ê±´ í™•ì¸

### 4.4.2 êµ¬í˜„ ì‹œ ì£¼ì˜ì‚¬í•­

1. **ë¬´ì‘ìœ„ì„± ë³´ì¥**
   ```go
   func generateSecureRandom(bits int) (*big.Int, error) {
       bytes := make([]byte, (bits+7)/8)
       if _, err := rand.Read(bytes); err != nil {
           return nil, err
       }
       return new(big.Int).SetBytes(bytes), nil
   }
   ```

2. **ë¶€ì±„ë„ ê³µê²© ë°©ì§€**
   - ìƒìˆ˜ ì‹œê°„ êµ¬í˜„
   - ë©”ëª¨ë¦¬ íŒ¨í„´ ë³´í˜¸
   - íƒ€ì´ë° ê³µê²© ë°©ì§€

3. **ì˜ˆì™¸ ì²˜ë¦¬**
   - ë¬´í•œì›ì  ê²€ì‚¬
   - ê³¡ì„  ìƒì˜ ì  ê²€ì¦
   - í‚¤ ìœ íš¨ì„± ê²€ì‚¬

## ë§ˆë¬´ë¦¬

ECCëŠ” í˜„ëŒ€ ì•”í˜¸í™” ì‹œìŠ¤í…œì˜ í•µì‹¬ ìš”ì†Œë¡œì„œ, RSAë³´ë‹¤ ì§§ì€ í‚¤ ê¸¸ì´ë¡œ ë™ë“±í•œ ë³´ì•ˆì„±ì„ ì œê³µí•˜ëŠ” íš¨ìœ¨ì ì¸ ì•”í˜¸í™” ë°©ì‹ì…ë‹ˆë‹¤. ìˆ˜í•™ì  ìš°ì•„í•¨ê³¼ ì‹¤ìš©ì„±ì„ ê²¸ë¹„í•œ ECCëŠ” íŠ¹íˆ ëª¨ë°”ì¼ê³¼ IoT í™˜ê²½ì—ì„œ ê·¸ ê°€ì¹˜ë¥¼ ë°œíœ˜í•˜ê³  ìˆìŠµë‹ˆë‹¤.

### ì£¼ìš” ì´ì  ì •ë¦¬

1. **íš¨ìœ¨ì„±**
   - ì§§ì€ í‚¤ ê¸¸ì´
   - ë¹ ë¥¸ ì—°ì‚° ì†ë„
   - ë‚®ì€ ëŒ€ì—­í­ ì‚¬ìš©
   - ì ì€ ë©”ëª¨ë¦¬ ìš”êµ¬ëŸ‰

2. **ë³´ì•ˆì„±**
   - ì–‘ì ì»´í“¨í„°ì— ëŒ€í•œ ìƒëŒ€ì  ê°•ì 
   - ECDLPì˜ ìˆ˜í•™ì  ì–´ë ¤ì›€
   - ë‹¤ì–‘í•œ í‘œì¤€ ê³¡ì„  ì˜µì…˜

3. **ìœ ì—°ì„±**
   - ë‹¤ì–‘í•œ ì‘ìš© í”„ë¡œí† ì½œ ì§€ì›
   - ê¸°ì¡´ ì‹œìŠ¤í…œê³¼ì˜ í†µí•© ìš©ì´
   - í™•ì¥ ê°€ëŠ¥í•œ êµ¬í˜„

### í–¥í›„ ë°œì „ ë°©í–¥

1. **í¬ìŠ¤íŠ¸ ì–‘ì ì•”í˜¸í™” ëŒ€ë¹„**
   - ì–‘ì ë‚´ì„± ê³¡ì„  ì—°êµ¬
   - í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ ì„¤ê³„
   - ì „í™˜ ì „ëµ ìˆ˜ë¦½

2. **í‘œì¤€í™” ë™í–¥**
   - ìƒˆë¡œìš´ í‘œì¤€ ê³¡ì„  ê°œë°œ
   - ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ ê°•í™”
   - ìƒí˜¸ìš´ìš©ì„± ê°œì„ 

3. **ì‘ìš© ë¶„ì•¼ í™•ëŒ€**
   - ë¸”ë¡ì²´ì¸/ì•”í˜¸í™”í
   - ì˜ì§€ì‹ ì¦ëª…
   - ë™í˜• ì•”í˜¸í™” í†µí•©

### ì‹¤ë¬´ ì ìš© ì‹œ ê³ ë ¤ì‚¬í•­

1. **êµ¬í˜„ ë³´ì•ˆ**
   ```go
   // ì•ˆì „í•œ ECC êµ¬í˜„ì„ ìœ„í•œ ì²´í¬ë¦¬ìŠ¤íŠ¸
   type ECCSecurityCheck struct {
       // ê³¡ì„  ë§¤ê°œë³€ìˆ˜ ê²€ì¦
       ValidateCurveParameters func() error
       
       // ì  ê²€ì¦
       ValidatePoint func(p *ECPoint) error
       
       // í‚¤ ìœ íš¨ì„± ê²€ì‚¬
       ValidatePrivateKey func(d *big.Int) error
       
       // ìƒìˆ˜ ì‹œê°„ êµ¬í˜„ í™•ì¸
       ConstantTimeOperations func() bool
   }
   ```

2. **ì„±ëŠ¥ ìµœì í™”**
   - íš¨ìœ¨ì ì¸ ì  ì—°ì‚° êµ¬í˜„
   - ë©”ëª¨ë¦¬ ì‚¬ìš© ìµœì í™”
   - ë³‘ë ¬ ì²˜ë¦¬ í™œìš©

3. **ìš´ì˜ ê´€ë¦¬**
   - í‚¤ ìˆ˜ëª…ì£¼ê¸° ê´€ë¦¬
   - ë³´ì•ˆ ê°ì‚¬ ì²´ê³„
   - ì¸ì‹œë˜íŠ¸ ëŒ€ì‘ ê³„íš

### í•™ìŠµ ë° ì°¸ê³  ìë£Œ

1. **í‘œì¤€ ë¬¸ì„œ**
   - SEC (Standards for Efficient Cryptography)
   - NIST SP 800-56A
   - ANSI X9.62/X9.63

2. **êµ¬í˜„ ê°€ì´ë“œ**
   - SafeCurves (https://safecurves.cr.yp.to)
   - BSI TR-03111
   - FIPS 186-4

3. **ì—°êµ¬ ìë£Œ**
   - ìµœì‹  ì•”í˜¸í•´ë… ë™í–¥
   - ì„±ëŠ¥ ìµœì í™” ê¸°ë²•
   - ë³´ì•ˆ ì·¨ì•½ì  ë¶„ì„

---

# 5. ë””ì§€í„¸ ì„œëª…

### ì‹¤ë¬´ ì ìš© ì‹œ ì²´í¬ë¦¬ìŠ¤íŠ¸

1. **ì•Œê³ ë¦¬ì¦˜ ì„ íƒ**
   ```go
   type SignatureAlgorithmCheck struct {
       // ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ ê²€ì¦
       SecurityLevel func() int
       
       // ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­ ê²€ì¦
       PerformanceCheck func() bool
       
       // ê·œì œ ì¤€ìˆ˜ ì—¬ë¶€ í™•ì¸
       ComplianceCheck func() error
       
       // ìƒí˜¸ìš´ìš©ì„± ê²€ì¦
       InteroperabilityTest func() error
   }
   ```

2. **êµ¬í˜„ ë³´ì•ˆ**
   - ì•ˆì „í•œ í‚¤ ìƒì„± ë° ê´€ë¦¬
   - ì ì ˆí•œ í•´ì‹œ í•¨ìˆ˜ ì„ íƒ
   - ìƒìˆ˜ ì‹œê°„ êµ¬í˜„ í™•ì¸
   - ë©”ëª¨ë¦¬ ë³´ì•ˆ ê³ ë ¤

3. **ìš´ì˜ ê´€ë¦¬**
   - í‚¤ ìˆ˜ëª…ì£¼ê¸° ê´€ë¦¬
   - ì¸ì¦ì„œ ê´€ë¦¬
   - ê°ì‚¬ ë¡œê·¸ ìœ ì§€
   - ë¹„ìƒ ê³„íš ìˆ˜ë¦½

### ì°¸ê³  ìë£Œ ë° í‘œì¤€

1. **êµ­ì œ í‘œì¤€**
   - FIPS 186-4 (ë””ì§€í„¸ ì„œëª… í‘œì¤€)
   - X.509 (ê³µê°œí‚¤ ì¸ì¦ì„œ í‘œì¤€)
   - RFC 3279 (ì•Œê³ ë¦¬ì¦˜ ì‹ë³„ì)

2. **êµ¬í˜„ ê°€ì´ë“œ**
   - NIST SP 800-57 (í‚¤ ê´€ë¦¬ ì§€ì¹¨)
   - ETSI TS 119 312 (ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ ì§€ì¹¨)
   - BSI TR-03111 (íƒ€ì›ê³¡ì„  ì•”í˜¸í™” ì§€ì¹¨)

3. **ë³´ì•ˆ ê¶Œê³ ì‚¬í•­**
   - ìµœì†Œ í‚¤ ê¸¸ì´ ê¶Œì¥ì‚¬í•­
   - ì•Œê³ ë¦¬ì¦˜ ìˆ˜ëª… ì˜ˆì¸¡
   - ì–‘ì ë‚´ì„± ì „í™˜ ê³„íš

ë””ì§€í„¸ ì„œëª…ì€ ì „ì ê±°ë˜ì™€ í†µì‹ ì˜ ì‹ ë¢°ì„±ì„ ë³´ì¥í•˜ëŠ” í•µì‹¬ ê¸°ìˆ ë¡œì„œ, ê·¸ ì¤‘ìš”ì„±ì€ ì•ìœ¼ë¡œë„ ê³„ì† ì¦ê°€í•  ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤. ë”°ë¼ì„œ ì‹¤ë¬´ìë“¤ì€ ìµœì‹  ë³´ì•ˆ ë™í–¥ì„ íŒŒì•…í•˜ê³ , ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ êµ¬í˜„ì„ ìœ„í•´ ì§€ì†ì ì¸ í•™ìŠµê³¼ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.

ë‹¤ìŒ ì¥ì—ì„œëŠ” í‚¤ êµí™˜ í”„ë¡œí† ì½œì— ëŒ€í•´ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ì„œëª…

ë””ì§€í„¸ ì„œëª…ì€ ì „ì ë¬¸ì„œì˜ ì§„ì •ì„±, ë¬´ê²°ì„±, ë¶€ì¸ë°©ì§€ë¥¼ ë³´ì¥í•˜ëŠ” í•µì‹¬ ê¸°ìˆ ì…ë‹ˆë‹¤. ë³¸ ë¬¸ì„œì—ì„œëŠ” ë””ì§€í„¸ ì„œëª…ì˜ ê¸°ë³¸ ì›ë¦¬ë¶€í„° ì‹¤ì œ êµ¬í˜„ê¹Œì§€ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

## 5.1 ë””ì§€í„¸ ì„œëª…ì˜ ê¸°ì´ˆ

### 5.1.1 ì„œëª…ì˜ ëª©ì ê³¼ ì¤‘ìš”ì„±

ë””ì§€í„¸ ì„œëª…ì€ ë‹¤ìŒê³¼ ê°™ì€ í•µì‹¬ ë³´ì•ˆ ì†ì„±ì„ ì œê³µí•©ë‹ˆë‹¤:

1. **ì¸ì¦(Authentication)**
   - ì„œëª…ìì˜ ì‹ ì› í™•ì¸
   - ë¬¸ì„œ ì¶œì²˜ ê²€ì¦
   - ê¶Œí•œ í™•ì¸

2. **ë¬´ê²°ì„±(Integrity)**
   - ë¬¸ì„œ ë³€ì¡° ê°ì§€
   - ë°ì´í„° ì¼ê´€ì„± ê²€ì¦
   - ì „ì†¡ ì˜¤ë¥˜ í™•ì¸

3. **ë¶€ì¸ë°©ì§€(Non-repudiation)**
   - ì„œëª… í–‰ìœ„ ì¦ëª…
   - ë²•ì  êµ¬ì†ë ¥ ì œê³µ
   - ì±…ì„ ì†Œì¬ ëª…í™•í™”

### 5.1.2 ìˆ˜í•™ì  ê¸°ë°˜

ë””ì§€í„¸ ì„œëª…ì˜ ìˆ˜í•™ì  ì›ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

1. **RSA ê¸°ë°˜ ì„œëª…**
   ì„œëª… ìƒì„± ê³¼ì •:
   $s = m^d \bmod n$
   ì—¬ê¸°ì„œ $m$ì€ ë©”ì‹œì§€ í•´ì‹œ, $d$ëŠ” ê°œì¸í‚¤, $n$ì€ ëª¨ë“ˆëŸ¬ìŠ¤

   ì„œëª… ê²€ì¦:
   $m \equiv s^e \pmod{n}$
   ì—¬ê¸°ì„œ $e$ëŠ” ê³µê°œí‚¤

2. **ECDSA**
   ì„œëª… ìƒì„± ê³¼ì •:
   - ì„ì‹œ í‚¤ $k$ ì„ íƒ
   - $r = (kG)_x \bmod n$
   - $s = k^{-1}(H(m) + dr) \bmod n$

   ì„œëª… ê²€ì¦:
   - $u_1 = s^{-1}H(m) \bmod n$
   - $u_2 = s^{-1}r \bmod n$
   - $(x,y) = u_1G + u_2Q$
   - í™•ì¸: $r \equiv x \pmod{n}$

### 5.1.3 ì„œëª… í”„ë¡œì„¸ìŠ¤

```go
// ë””ì§€í„¸ ì„œëª… ìƒì„± í”„ë¡œì„¸ìŠ¤
func CreateDigitalSignature(message []byte, privateKey interface{}) ([]byte, error) {
    // ë©”ì‹œì§€ í•´ì‹œ ê³„ì‚°
    hash := sha256.Sum256(message)
    
    switch key := privateKey.(type) {
    case *rsa.PrivateKey:
        // RSA ì„œëª…
        signature, err := rsa.SignPKCS1v15(
            rand.Reader,
            key,
            crypto.SHA256,
            hash[:],
        )
        return signature, err
        
    case *ecdsa.PrivateKey:
        // ECDSA ì„œëª…
        r, s, err := ecdsa.Sign(rand.Reader, key, hash[:])
        if err != nil {
            return nil, err
        }
        
        // ASN.1 ì¸ì½”ë”©
        signature, err := asn1.Marshal(struct {
            R, S *big.Int
        }{r, s})
        return signature, err
    }
    
    return nil, errors.New("ì§€ì›í•˜ì§€ ì•ŠëŠ” í‚¤ íƒ€ì…")
}
```

## 5.2 ì„œëª… ì•Œê³ ë¦¬ì¦˜

### 5.2.1 RSA ê¸°ë°˜ ì„œëª…

RSA ë””ì§€í„¸ ì„œëª…ì˜ ì„¸ë¶€ êµ¬í˜„:

```go
func RSASign(privateKey *rsa.PrivateKey, message []byte) ([]byte, error) {
    // PKCS #1 v1.5 íŒ¨ë”© ì‚¬ìš©
    hashed := sha256.Sum256(message)
    
    signature, err := rsa.SignPKCS1v15(
        rand.Reader,
        privateKey,
        crypto.SHA256,
        hashed[:],
    )
    
    if err != nil {
        return nil, fmt.Errorf("ì„œëª… ìƒì„± ì‹¤íŒ¨: %v", err)
    }
    
    return signature, nil
}

func RSAVerify(
    publicKey *rsa.PublicKey,
    message []byte,
    signature []byte,
) error {
    hashed := sha256.Sum256(message)
    
    return rsa.VerifyPKCS1v15(
        publicKey,
        crypto.SHA256,
        hashed[:],
        signature,
    )
}
```

RSA ì„œëª…ì˜ ìˆ˜í•™ì  íŠ¹ì„±:

1. **ì„œëª… ìƒì„±**
   $s = (H(m))^d \bmod n$
   ì—¬ê¸°ì„œ $H(m)$ì€ ë©”ì‹œì§€ í•´ì‹œê°’

2. **ì„œëª… ê²€ì¦**
   $(s^e \bmod n) \stackrel{?}{=} H(m)$

### 5.2.2 DSA (Digital Signature Algorithm)

DSAì˜ í•µì‹¬ ë§¤ê°œë³€ìˆ˜:
- ì†Œìˆ˜ $p$, $q$ (ì—¬ê¸°ì„œ $q$ëŠ” $p-1$ì˜ ì†Œì¸ìˆ˜)
- ìƒì„±ì› $g$
- ê°œì¸í‚¤ $x$
- ê³µê°œí‚¤ $y = g^x \bmod p$

ì„œëª… ê³¼ì •:
1. ì„ì‹œ í‚¤ $k$ ìƒì„±
2. $r = (g^k \bmod p) \bmod q$
3. $s = k^{-1}(H(m) + xr) \bmod q$

ê²€ì¦ ê³¼ì •:
1. $w = s^{-1} \bmod q$
2. $u_1 = H(m)w \bmod q$
3. $u_2 = rw \bmod q$
4. $v = (g^{u_1}y^{u_2} \bmod p) \bmod q$
5. í™•ì¸: $v = r$

### 5.2.3 ECDSA ìƒì„¸ êµ¬í˜„

```go
type ECDSASignature struct {
    R, S *big.Int
}

func ECDSASign(
    privateKey *ecdsa.PrivateKey,
    message []byte,
) (*ECDSASignature, error) {
    // ë©”ì‹œì§€ í•´ì‹œ
    hash := sha256.Sum256(message)
    
    // ì„œëª… ìƒì„±
    r, s, err := ecdsa.Sign(rand.Reader, privateKey, hash[:])
    if err != nil {
        return nil, err
    }
    
    return &ECDSASignature{R: r, S: s}, nil
}

func (sig *ECDSASignature) Verify(
    publicKey *ecdsa.PublicKey,
    message []byte,
) bool {
    hash := sha256.Sum256(message)
    return ecdsa.Verify(publicKey, hash[:], sig.R, sig.S)
}
```

### 5.2.4 EdDSA (Edwards-curve Digital Signature Algorithm)

EdDSAì˜ íŠ¹ì§•:
- íƒ€ì›ê³¡ì„  $E: -x^2 + y^2 = 1 + dx^2y^2$
- ê²°ì •ì  ì„œëª… ìƒì„±
- ë‚´ì¥ëœ í‚¤ ìƒì„±
- ë” ë¹ ë¥¸ ì—°ì‚° ì†ë„

```go
func Ed25519Sign(privateKey ed25519.PrivateKey, message []byte) []byte {
    return ed25519.Sign(privateKey, message)
}

func Ed25519Verify(
    publicKey ed25519.PublicKey,
    message, signature []byte,
) bool {
    return ed25519.Verify(publicKey, message, signature)
}
```

## 5.3 ì„œëª… êµ¬í˜„ê³¼ ì‘ìš©

### 5.3.1 ë¬¸ì„œ ì„œëª…

ì „ì ë¬¸ì„œ ì„œëª… ì‹œìŠ¤í…œ êµ¬í˜„:

```go
type DocumentSigner struct {
    privateKey interface{}
    algorithm  string
    metadata   map[string]string
}

func (ds *DocumentSigner) SignDocument(doc []byte) (*SignedDocument, error) {
    // ë¬¸ì„œ í•´ì‹œ ê³„ì‚°
    hash := sha256.Sum256(doc)
    
    // íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±
    timestamp := time.Now().UTC()
    
    // ì„œëª… ìƒì„±
    signature, err := CreateDigitalSignature(hash[:], ds.privateKey)
    if err != nil {
        return nil, err
    }
    
    return &SignedDocument{
        Document:    doc,
        Signature:   signature,
        Algorithm:   ds.algorithm,
        Timestamp:   timestamp,
        Metadata:    ds.metadata,
    }, nil
}
```

### 5.3.2 ì½”ë“œ ì„œëª…

ì‹¤í–‰ íŒŒì¼ê³¼ íŒ¨í‚¤ì§€ì˜ ë¬´ê²°ì„± ë³´ì¥:

```go
type CodeSignature struct {
    Digest    []byte
    Signature []byte
    CertChain [][]byte
    Timestamp time.Time
}

func SignExecutable(
    file string,
    privateKey *ecdsa.PrivateKey,
    cert *x509.Certificate,
) (*CodeSignature, error) {
    // íŒŒì¼ í•´ì‹œ ê³„ì‚°
    digest, err := calculateFileDigest(file)
    if err != nil {
        return nil, err
    }
    
    // ì„œëª… ìƒì„±
    signature, err := ECDSASign(privateKey, digest)
    if err != nil {
        return nil, err
    }
    
    return &CodeSignature{
        Digest:    digest,
        Signature: signature.Serialize(),
        CertChain: [][]byte{cert.Raw},
        Timestamp: time.Now().UTC(),
    }, nil
}
```

### 5.3.3 ì¸ì¦ì„œ ì„œëª…

X.509 ì¸ì¦ì„œ ì„œëª… êµ¬í˜„:

```go
func SignCertificate(
    template *x509.Certificate,
    parent *x509.Certificate,
    publicKey interface{},
    privateKey interface{},
) (*x509.Certificate, error) {
    certBytes, err := x509.CreateCertificate(
        rand.Reader,
        template,
        parent,
        publicKey,
        privateKey,
    )
    if err != nil {
        return nil, err
    }
    
    return x509.ParseCertificate(certBytes)
}
```

### 5.3.4 íƒ€ì„ìŠ¤íƒ¬í”„

ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” íƒ€ì„ìŠ¤íƒ¬í”„ ì„œë¹„ìŠ¤:

```go
type TimeStampAuthority struct {
    privateKey *ecdsa.PrivateKey
    cert       *x509.Certificate
}

func (tsa *TimeStampAuthority) CreateTimestamp(data []byte) (*TimeStampToken, error) {
    // ë°ì´í„° í•´ì‹œ
    hash := sha256.Sum256(data)
    
    // íƒ€ì„ìŠ¤íƒ¬í”„ í† í° ìƒì„±
    token := &TimeStampToken{
        Hash:      hash[:],
        Timestamp: time.Now().UTC(),
    }
    
    // í† í° ì„œëª…
    signature, err := ECDSASign(tsa.privateKey, token.Serialize())
    if err != nil {
        return nil, err
    }
    
    token.Signature = signature
    return token, nil
}
```

## 5.4 ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 5.4.1 í‚¤ ê´€ë¦¬

ì•ˆì „í•œ í‚¤ ê´€ë¦¬ë¥¼ ìœ„í•œ ì§€ì¹¨:

1. **í‚¤ ìƒì„±**
   - ì¶©ë¶„í•œ ì—”íŠ¸ë¡œí”¼ í™•ë³´
   - ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±ê¸° ì‚¬ìš©
   - ì ì ˆí•œ í‚¤ ê¸¸ì´ ì„ íƒ

2. **í‚¤ ë³´ê´€**
   - HSM í™œìš©
   - ì ‘ê·¼ ì œì–´ êµ¬í˜„
   - ë°±ì—… ë° ë³µêµ¬ ì ˆì°¨

3. **í‚¤ ê°±ì‹ **
   - ì •ê¸°ì ì¸ í‚¤ êµì²´
   - í‚¤ ìˆ˜ëª…ì£¼ê¸° ê´€ë¦¬
   - íê¸° ì ˆì°¨ ìˆ˜ë¦½

### 5.4.2 ì•Œê³ ë¦¬ì¦˜ ì„ íƒ

ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ì‹œ ê³ ë ¤ì‚¬í•­:

1. **ë³´ì•ˆ ê°•ë„**
   - RSA: ìµœì†Œ 3072ë¹„íŠ¸
   - ECDSA: ìµœì†Œ 256ë¹„íŠ¸
   - EdDSA: Ed25519 (256ë¹„íŠ¸)

2. **ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­**
   - ì„œëª… ìƒì„± ì†ë„
   - ê²€ì¦ ì†ë„
   - ì €ì¥ ê³µê°„

3. **í‘œì¤€ ì¤€ìˆ˜**
   - FIPS 186-4
   - ETSI í‘œì¤€
   - êµ­ê°€ë³„ ê·œì œ

### 5.4.3 êµ¬í˜„ ë³´ì•ˆ

ì•ˆì „í•œ êµ¬í˜„ì„ ìœ„í•œ ì§€ì¹¨:

```go
// ìƒìˆ˜ ì‹œê°„ ë¹„êµ êµ¬í˜„
func ConstantTimeCompare(a, b []byte) bool {
    if len(a) != len(b) {
        return false
    }
    
    var result byte
    for i := 0; i < len(a); i++ {
        result |= a[i] ^ b[i]
    }
    return result == 0
}

// ì•ˆì „í•œ í•´ì‹œ í•¨ìˆ˜ ì„ íƒ
func SecureHash(data []byte) []byte {
    hash := sha256.New()
    hash.Write(data)
    return hash.Sum(nil)
}
```

## ë§ˆë¬´ë¦¬

ë””ì§€í„¸ ì„œëª…ì€ í˜„ëŒ€ ì „ì ê±°ë˜ì™€ í†µì‹ ì˜ í•µì‹¬ ë³´ì•ˆ ê¸°ìˆ ì…ë‹ˆë‹¤. ì˜¬ë°”ë¥¸ êµ¬í˜„ê³¼ ìš´ì˜ì„ ìœ„í•´ì„œëŠ” ë‹¤ìŒ ì‚¬í•­ë“¤ì„ ì§€ì†ì ìœ¼ë¡œ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤:

1. ì ì ˆí•œ ì•Œê³ ë¦¬ì¦˜ê³¼ í‚¤ ê¸¸ì´ ì„ íƒ
2. ì•ˆì „í•œ í‚¤ ê´€ë¦¬ ì²´ê³„ êµ¬ì¶•
3. ì •ê¸°ì ì¸ ë³´ì•ˆ ê°ì‚¬ ì‹¤ì‹œ
4. ìµœì‹  ë³´ì•ˆ ë™í–¥ ëª¨ë‹ˆí„°ë§

### í–¥í›„ ë°œì „ ë°©í–¥

1. **ì–‘ì ë‚´ì„± ì„œëª…**
   - ê²©ì ê¸°ë°˜ ì„œëª…
   - ë‹¤ë³€ìˆ˜ ì„œëª…
   - í•´ì‹œ ê¸°ë°˜ ì„œëª…

2. **ìƒˆë¡œìš´ ì‘ìš© ë¶„ì•¼**
   - ë¸”ë¡ì²´ì¸ ì„œëª…
   - IoT ë””ë°”ì´ìŠ¤ ì¸ì¦
   - ì˜ì§€ì‹ ì¦ëª… í†µí•©

3. **í‘œì¤€í™” ë™í–¥**
   - NIST í‘œì¤€í™”
   - êµ­ì œ í‘œì¤€ ë°œì „
   - ìƒí˜¸ìš´ìš©ì„± ê°œì„ 

ê¸°ìˆ ì€ ê³„ì†í•´ì„œ ë°œì „í•˜ê³  ìˆìœ¼ë©°, íŠ¹íˆ ì–‘ì ì»´í“¨í„° ì‹œëŒ€ë¥¼ ëŒ€ë¹„í•œ ìƒˆë¡œìš´ ì„œëª… ì•Œê³ ë¦¬ì¦˜ì˜ ê°œë°œì´ í™œë°œíˆ ì§„í–‰ë˜ê³  ìˆìŠµë‹ˆë‹¤. ì‹¤ë¬´ìë“¤ì€ ì´ëŸ¬í•œ ë°œì „ ë™í–¥ì„ ì£¼ì‹œí•˜ë©´ì„œ, ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ê³¼ ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­ì˜ ê· í˜•ì„ ë§ì¶”ì–´ ì ì ˆí•œ ì„œëª… ì•Œê³ ë¦¬ì¦˜ì„ ì„ íƒí•˜ê³  êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.

---

# 6. í‚¤ êµí™˜ í”„ë¡œí† ì½œ

í‚¤ êµí™˜ í”„ë¡œí† ì½œì€ ì•ˆì „í•˜ì§€ ì•Šì€ í†µì‹  ì±„ë„ì„ í†µí•´ ë‘ ë‹¹ì‚¬ìê°€ ê³µìœ  ë¹„ë°€í‚¤ë¥¼ ì•ˆì „í•˜ê²Œ ì„¤ì •í•  ìˆ˜ ìˆê²Œ í•˜ëŠ” í•µì‹¬ ì•”í˜¸í™” ê¸°ìˆ ì…ë‹ˆë‹¤. ë³¸ ë¬¸ì„œì—ì„œëŠ” ë‹¤ì–‘í•œ í‚¤ êµí™˜ í”„ë¡œí† ì½œì˜ ì›ë¦¬ì™€ êµ¬í˜„ ë°©ë²•ì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

## 6.1 Diffie-Hellman í‚¤ êµí™˜

### 6.1.1 ê¸°ë³¸ ì›ë¦¬

Diffie-Hellman í‚¤ êµí™˜ì€ ì´ì‚°ë¡œê·¸ ë¬¸ì œì˜ ì–´ë ¤ì›€ì— ê¸°ë°˜í•œ ìµœì´ˆì˜ ê³µê°œí‚¤ í”„ë¡œí† ì½œì…ë‹ˆë‹¤. ê·¸ ì‘ë™ ì›ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

1. **ì´ˆê¸° ë§¤ê°œë³€ìˆ˜**
   - ì†Œìˆ˜ $p$ (ëª¨ë“ˆëŸ¬ìŠ¤)
   - ìƒì„±ì› $g$ (ì›ì‹œê·¼)
   ì´ ê°’ë“¤ì€ ê³µê°œë©ë‹ˆë‹¤.

2. **í‚¤ êµí™˜ ê³¼ì •**
   Aliceì™€ Bobì˜ í‚¤ êµí™˜:
   - Alice: ë¹„ë°€ê°’ $a$ ì„ íƒ, $A = g^a \bmod p$ ê³„ì‚°
   - Bob: ë¹„ë°€ê°’ $b$ ì„ íƒ, $B = g^b \bmod p$ ê³„ì‚°
   - ê³µìœ  ë¹„ë°€: $K = g^{ab} \bmod p$

```go
type DHExchange struct {
    P *big.Int // ëª¨ë“ˆëŸ¬ìŠ¤
    G *big.Int // ìƒì„±ì›
}

func NewDHExchange(bits int) (*DHExchange, error) {
    // ì•ˆì „í•œ ì†Œìˆ˜ ìƒì„±
    p, err := rand.Prime(rand.Reader, bits)
    if err != nil {
        return nil, err
    }
    
    // ìƒì„±ì› ì°¾ê¸°
    g := findGenerator(p)
    
    return &DHExchange{
        P: p,
        G: g,
    }, nil
}

func (dh *DHExchange) GenerateKeyPair() (*big.Int, *big.Int, error) {
    // ê°œì¸í‚¤ ìƒì„±
    privateKey, err := rand.Int(rand.Reader, dh.P)
    if err != nil {
        return nil, nil, err
    }
    
    // ê³µê°œí‚¤ ê³„ì‚°
    publicKey := new(big.Int).Exp(dh.G, privateKey, dh.P)
    
    return privateKey, publicKey, nil
}

func (dh *DHExchange) ComputeSharedSecret(
    privateKey, peerPublicKey *big.Int,
) *big.Int {
    return new(big.Int).Exp(peerPublicKey, privateKey, dh.P)
}
```

### 6.1.2 êµ¬í˜„ ë°©ë²•

ì•ˆì „í•œ DH êµ¬í˜„ì„ ìœ„í•œ ê³ ë ¤ì‚¬í•­:

1. **ë§¤ê°œë³€ìˆ˜ ì„ íƒ**
   - ì¶©ë¶„í•œ í‚¤ ê¸¸ì´ (ìµœì†Œ 2048ë¹„íŠ¸)
   - ì•ˆì „í•œ ì†Œìˆ˜ ì‚¬ìš©
   - ì ì ˆí•œ ìƒì„±ì› ì„ íƒ

2. **ìœ íš¨ì„± ê²€ì¦**
   ```go
   func validateDHParameters(p, g *big.Int) error {
       // ì†Œìˆ˜ ê²€ì¦
       if !p.ProbablyPrime(20) {
           return errors.New("pëŠ” ì†Œìˆ˜ì—¬ì•¼ í•¨")
       }
       
       // ìƒì„±ì› ê²€ì¦
       if g.Cmp(big.NewInt(1)) <= 0 || g.Cmp(p) >= 0 {
           return errors.New("ë¶€ì ì ˆí•œ ìƒì„±ì›")
       }
       
       return nil
   }
   ```

3. **ì¤‘ê°„ì ê³µê²© ë°©ì§€**
   - ê³µê°œí‚¤ ì¸ì¦ í•„ìš”
   - ì„¸ì…˜ ë°”ì¸ë”©
   - í”„ë¡œí† ì½œ ìƒíƒœ ê´€ë¦¬

### 6.1.3 ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

DH í”„ë¡œí† ì½œì˜ ë³´ì•ˆ ê°•ë„ëŠ” ë‹¤ìŒ ìš”ì†Œë“¤ì— ì˜í•´ ê²°ì •ë©ë‹ˆë‹¤:

1. **ì´ì‚°ë¡œê·¸ ë¬¸ì œì˜ ì–´ë ¤ì›€**
   $g^x \bmod p$ ì—ì„œ $x$ë¥¼ ì°¾ëŠ” ë¬¸ì œì˜ ë³µì¡ë„:
   $O(e^{(\frac{64}{9}\log p)^{\frac{1}{3}}(\log \log p)^{\frac{2}{3}}})$

2. **ì†Œìˆ˜ ì„ íƒ**
   ì•ˆì „í•œ ì†Œìˆ˜ $p = 2q + 1$ (ì—¬ê¸°ì„œ $q$ë„ ì†Œìˆ˜)

## 6.2 í‚¤ êµí™˜ í”„ë¡œí† ì½œì˜ ì§„í™”

### 6.2.1 ê¸°ë³¸ DHì—ì„œ ECDHë¡œ

íƒ€ì›ê³¡ì„  Diffie-Hellman (ECDH)ì€ DHì˜ íƒ€ì›ê³¡ì„  ë²„ì „ì…ë‹ˆë‹¤:

1. **ECDH ë™ì‘ ì›ë¦¬**
   - í•©ì˜ëœ íƒ€ì›ê³¡ì„  $E$ì™€ ê¸°ì €ì  $G$
   - Alice: ë¹„ë°€ê°’ $a$, ê³µê°œí‚¤ $A = aG$
   - Bob: ë¹„ë°€ê°’ $b$, ê³µê°œí‚¤ $B = bG$
   - ê³µìœ  ë¹„ë°€: $K = abG$

```go
func GenerateECDHKeyPair(curve elliptic.Curve) (*ecdsa.PrivateKey, error) {
    return ecdsa.GenerateKey(curve, rand.Reader)
}

func ComputeECDHSharedSecret(
    privateKey *ecdsa.PrivateKey,
    peerPublicKey *ecdsa.PublicKey,
) []byte {
    x, _ := curve25519.X25519(
        privateKey.D.Bytes(),
        peerPublicKey.X.Bytes(),
    )
    return x
}
```

### 6.2.2 Perfect Forward Secrecy

PFSëŠ” ê³¼ê±° í†µì‹ ì˜ ê¸°ë°€ì„±ì„ ë³´ì¥í•˜ëŠ” ì†ì„±ì…ë‹ˆë‹¤:

1. **ì„¸ì…˜í‚¤ ìƒì„±**
   ```go
   type SessionKeyGenerator struct {
       curve elliptic.Curve
   }

   func (skg *SessionKeyGenerator) GenerateSessionKey() ([]byte, error) {
       // ì„ì‹œ í‚¤ ìŒ ìƒì„±
       ephemeralKey, err := ecdsa.GenerateKey(skg.curve, rand.Reader)
       if err != nil {
           return nil, err
       }
       
       // ì„¸ì…˜í‚¤ ìœ ë„
       return deriveSessionKey(ephemeralKey)
   }
   ```

2. **í‚¤ ê°±ì‹  ì •ì±…**
   - ì •ê¸°ì ì¸ í‚¤ êµì²´
   - ì„¸ì…˜ë³„ ìƒˆë¡œìš´ í‚¤ ì‚¬ìš©
   - ì´ì „ í‚¤ì˜ ì•ˆì „í•œ íê¸°

### 6.2.3 ì–‘ì ë‚´ì„± í‚¤ êµí™˜

ì–‘ì ì»´í“¨í„° ìœ„í˜‘ì— ëŒ€ë¹„í•œ ìƒˆë¡œìš´ í”„ë¡œí† ì½œ:

1. **ê²©ì ê¸°ë°˜ í‚¤ êµí™˜**
   - NTRU
   - LWE (Learning With Errors)
   - Ring-LWE

2. **ì´ˆë™í˜• ì•”í˜¸í™” ê¸°ë°˜**
   - BGV ìŠ¤í‚¤ë§ˆ
   - FHE ê¸°ë°˜ í”„ë¡œí† ì½œ

## 6.3 ì‹¤ì œ ì‘ìš©

### 6.3.1 TLS/SSLì—ì„œì˜ í‚¤ êµí™˜

TLS 1.3ì˜ í‚¤ êµí™˜ ê³¼ì •:

```go
type TLSKeyExchange struct {
    curve          elliptic.Curve
    privateKey     *ecdsa.PrivateKey
    peerPublicKey  *ecdsa.PublicKey
    sessionKeys    map[string][]byte
}

func (tke *TLSKeyExchange) HandleClientHello(
    clientRandom []byte,
    supportedGroups []uint16,
) (*ServerHello, error) {
    // ì ì ˆí•œ íƒ€ì›ê³¡ì„  ì„ íƒ
    selectedCurve := selectCurve(supportedGroups)
    
    // ì„ì‹œ í‚¤ ìŒ ìƒì„±
    ephemeralKey, err := ecdsa.GenerateKey(selectedCurve, rand.Reader)
    if err != nil {
        return nil, err
    }
    
    // ì„œë²„ hello êµ¬ì„±
    return &ServerHello{
        ServerRandom:    generateRandom(),
        SelectedCipher:  selectCipherSuite(),
        ServerKeyShare: ephemeralKey.PublicKey,
    }, nil
}
```

### 6.3.2 SSH í‚¤ êµí™˜

SSH í”„ë¡œí† ì½œì˜ í‚¤ êµí™˜ êµ¬í˜„:

```go
type SSHKeyExchange struct {
    hostKey     ssh.Signer
    sessionID   []byte
    algorithms  []string
}

func (ske *SSHKeyExchange) NegotiateKeys(
    clientKexInit []byte,
) (*ssh.KexResult, error) {
    // ì•Œê³ ë¦¬ì¦˜ í˜‘ìƒ
    kexAlgo := negotiateAlgorithm(ske.algorithms, clientKexInit)
    
    // DH ë˜ëŠ” ECDH í‚¤ êµí™˜ ìˆ˜í–‰
    sharedSecret, err := performKeyExchange(kexAlgo)
    if err != nil {
        return nil, err
    }
    
    // ì„¸ì…˜ í‚¤ ìœ ë„
    return deriveSSHKeys(sharedSecret, ske.sessionID)
}
```

### 6.3.3 ë©”ì‹œì§• ì•±ì˜ í‚¤ êµí™˜

Signal í”„ë¡œí† ì½œ ìŠ¤íƒ€ì¼ì˜ í‚¤ êµí™˜:

```go
type SignalProtocol struct {
    identityKey    *ecdsa.PrivateKey
    signedPreKey   *ecdsa.PrivateKey
    oneTimePreKeys map[string]*ecdsa.PrivateKey
}

func (sp *SignalProtocol) InitiateSession(
    recipientIdentity *ecdsa.PublicKey,
) (*SessionKeys, error) {
    // X3DH í‚¤ êµí™˜ ìˆ˜í–‰
    ephemeralKey, err := GenerateECDHKeyPair(curve25519.P256())
    if err != nil {
        return nil, err
    }
    
    // í‚¤ ë²ˆë“¤ êµ¬ì„±
    bundle := &KeyBundle{
        IdentityKey:     &sp.identityKey.PublicKey,
        SignedPreKey:    &sp.signedPreKey.PublicKey,
        EphemeralKey:    &ephemeralKey.PublicKey,
    }
    
    // ì„¸ì…˜ í‚¤ ì„¤ì •
    return establishSession(bundle, recipientIdentity)
}
```

### 6.3.4 IoT ë””ë°”ì´ìŠ¤ í‚¤ êµí™˜

ë¦¬ì†ŒìŠ¤ ì œì•½ì ì¸ í™˜ê²½ì„ ìœ„í•œ ê²½ëŸ‰ í‚¤ êµí™˜:

```go
type LightweightKeyExchange struct {
    psk        []byte    // Pre-Shared Key
    deviceID   string
    sequence   uint32
}

func (lke *LightweightKeyExchange) GenerateSessionKey() ([]byte, error) {
    // íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ë…¼ìŠ¤ ìƒì„±
    nonce := generateNonce(time.Now())
    
    // HMAC ê¸°ë°˜ í‚¤ ìœ ë„
    return hkdf.New(
        sha256.New,
        lke.psk,
        nonce,
        []byte(lke.deviceID),
    ).Expand(nil, 32)
}
```

## 6.4 êµ¬í˜„ ëª¨ë²” ì‚¬ë¡€

### 6.4.1 ì•ˆì „í•œ ë§¤ê°œë³€ìˆ˜ ì„ íƒ

í‚¤ êµí™˜ êµ¬í˜„ ì‹œ ê¶Œì¥ë˜ëŠ” ë§¤ê°œë³€ìˆ˜:

1. **íƒ€ì›ê³¡ì„  ì„ íƒ**
   - P-256 (secp256r1)
   - Curve25519
   - brainpoolP256r1

2. **DH ë§¤ê°œë³€ìˆ˜**
   - ì†Œìˆ˜ í¬ê¸°: ìµœì†Œ 2048ë¹„íŠ¸
   - ì•ˆì „í•œ ì†Œìˆ˜ ì‚¬ìš©
   - ê²€ì¦ëœ ìƒì„±ì›

### 6.4.2 ì˜¤ë¥˜ ì²˜ë¦¬

ì•ˆì „í•œ ì˜¤ë¥˜ ì²˜ë¦¬ êµ¬í˜„:

```go
func handleKeyExchangeError(err error) error {
    switch err := err.(type) {
    case *ValidationError:
        // ë§¤ê°œë³€ìˆ˜ ê²€ì¦ ì‹¤íŒ¨
        logSecurityEvent("í‚¤ êµí™˜ ë§¤ê°œë³€ìˆ˜ ê²€ì¦ ì‹¤íŒ¨", err)
        return ErrInvalidParameters
        
    case *ProtocolError:
        // í”„ë¡œí† ì½œ ì˜¤ë¥˜
        logSecurityEvent("í‚¤ êµí™˜ í”„ë¡œí† ì½œ ì˜¤ë¥˜", err)
        return ErrProtocolFailure
        
    default:
        // ì¼ë°˜ì ì¸ ì˜¤ë¥˜
        logSecurityEvent("í‚¤ êµí™˜ ì‹¤íŒ¨", err)
        return ErrKeyExchangeFailed
    }
}
```

### 6.4.3 ì„±ëŠ¥ ìµœì í™”

ë¦¬ì†ŒìŠ¤ íš¨ìœ¨ì ì¸ êµ¬í˜„:

```go
type KeyExchangeOptimizer struct {
    precomputedTables map[string][]Point
    cache            *lru.Cache
}

func (keo *KeyExchangeOptimizer) PrecomputePoints(
    curve elliptic.Curve,
) error {
    // ìœˆë„ìš° ë°©ì‹ì˜ ìŠ¤ì¹¼ë¼ ê³±ì…ˆ í…Œì´ë¸” ê³„ì‚°
    basePoint := curve.Params().Gx
    windowSize := 4
    
    for i := 0; i < (1 << windowSize); i++ {
        point := multiplyPoint(basePoint, big.NewInt(int64(i)))
        keo.precomputedTables[string(i)] = point
    }
    
    return nil
}
```

## ë§ˆë¬´ë¦¬

í‚¤ êµí™˜ í”„ë¡œí† ì½œì€ í˜„ëŒ€ ì•”í˜¸í™” ì‹œìŠ¤í…œì˜ í•µì‹¬ ìš”ì†Œë¡œì„œ, ì•ˆì „í•œ í†µì‹  ì±„ë„ ì„¤ì •ì˜ ê¸°ë°˜ì´ ë©ë‹ˆë‹¤. ì˜¬ë°”ë¥¸ êµ¬í˜„ê³¼ ìš´ì˜ì„ ìœ„í•´ì„œëŠ” ë‹¤ìŒ ì‚¬í•­ë“¤ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤:

1. ì ì ˆí•œ ì•Œê³ ë¦¬ì¦˜ê³¼ ë§¤ê°œë³€ìˆ˜ ì„ íƒ
2. ì•ˆì „í•œ êµ¬í˜„ê³¼ ì˜¤ë¥˜ ì²˜ë¦¬
3. ì„±ëŠ¥ ìµœì í™”ì™€ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
4. ì–‘ì ì»´í“¨íŒ… ì‹œëŒ€ ëŒ€ë¹„

---

# 7. ì¸ì¦ì„œì™€ PKI

ê³µê°œí‚¤ ê¸°ë°˜êµ¬ì¡°(Public Key Infrastructure, PKI)ëŠ” ë””ì§€í„¸ ì¸ì¦ì„œì˜ ìƒì„±, ê´€ë¦¬, ë°°í¬, ì‚¬ìš©, ì €ì¥ ë° íê¸°ë¥¼ í¬í•¨í•˜ëŠ” ì¢…í•©ì ì¸ ì²´ê³„ì…ë‹ˆë‹¤. ë³¸ ë¬¸ì„œì—ì„œëŠ” PKIì˜ êµ¬ì„± ìš”ì†Œì™€ ìš´ì˜ ë°©ì‹, ê·¸ë¦¬ê³  ì‹¤ì œ êµ¬í˜„ ë°©ë²•ì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

## 7.1 PKI ê¸°ì´ˆ

### 7.1.1 X.509 ì¸ì¦ì„œ êµ¬ì¡°

X.509 ì¸ì¦ì„œëŠ” ê³µê°œí‚¤ ì¸ì¦ì„œì˜ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ, ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ë¥¼ ê°€ì§‘ë‹ˆë‹¤:

```
Certificate
|-- Version
|-- Serial Number
|-- Signature Algorithm
|-- Issuer
|-- Validity Period
|   |-- Not Before
|   `-- Not After
|-- Subject
|-- Subject Public Key Info
|   |-- Algorithm
|   `-- Subject Public Key
|-- Extensions
`-- Certificate Signature
```

ìˆ˜í•™ì ìœ¼ë¡œ ì¸ì¦ì„œ ì„œëª…ì€ ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ë©ë‹ˆë‹¤:

$Signature = Sign_{CA_{private}}(Hash(TBS))$

ì—¬ê¸°ì„œ $TBS$ (To Be Signed)ëŠ” ì„œëª…ë  ì¸ì¦ì„œ ë³¸ë¬¸ì´ë©°, $Hash$ëŠ” í•´ì‹œ í•¨ìˆ˜, $Sign_{CA_{private}}$ëŠ” CAì˜ ê°œì¸í‚¤ë¡œ ì„œëª…í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.

```go
// X.509 ì¸ì¦ì„œ ìƒì„±
func CreateCertificate(
    template *x509.Certificate,
    parent *x509.Certificate,
    publicKey interface{},
    privateKey interface{},
) ([]byte, error) {
    // ì¸ì¦ì„œ ìƒì„±
    certDER, err := x509.CreateCertificate(
        rand.Reader,
        template,
        parent,
        publicKey,
        privateKey,
    )
    if err != nil {
        return nil, fmt.Errorf("ì¸ì¦ì„œ ìƒì„± ì‹¤íŒ¨: %v", err)
    }
    
    return certDER, nil
}

// PEM í˜•ì‹ìœ¼ë¡œ ì¸ì½”ë”©
func EncodeCertificatePEM(certDER []byte) []byte {
    return pem.EncodeToMemory(&pem.Block{
        Type:  "CERTIFICATE",
        Bytes: certDER,
    })
}
```

### 7.1.2 ì¸ì¦ê¸°ê´€(CA)ì˜ ì—­í• 

CAëŠ” PKIì˜ ì‹ ë¢° ì•µì»¤ë¡œì„œ ë‹¤ìŒê³¼ ê°™ì€ ì±…ì„ì„ ê°€ì§‘ë‹ˆë‹¤:

1. **ì¸ì¦ì„œ ë°œê¸‰**
   - ì‹ ì› í™•ì¸
   - í‚¤ ìŒ ê²€ì¦
   - ì¸ì¦ì„œ ì„œëª…

2. **ì¸ì¦ì„œ ê´€ë¦¬**
   - ìœ íš¨ì„± ê²€ì‚¬
   - ìƒíƒœ ì¶”ì 
   - íê¸° ê´€ë¦¬

```go
type CertificateAuthority struct {
    RootCert    *x509.Certificate
    PrivateKey  *rsa.PrivateKey
    SerialCount *big.Int
    CRLList     map[string]time.Time
}

func (ca *CertificateAuthority) IssueCertificate(
    csr *x509.CertificateRequest,
    validity time.Duration,
) (*x509.Certificate, error) {
    // CSR ê²€ì¦
    if err := csr.CheckSignature(); err != nil {
        return nil, fmt.Errorf("CSR ì„œëª… ê²€ì¦ ì‹¤íŒ¨: %v", err)
    }
    
    // ì‹œë¦¬ì–¼ ë²ˆí˜¸ ìƒì„±
    serialNumber := new(big.Int).Add(ca.SerialCount, big.NewInt(1))
    
    // ì¸ì¦ì„œ í…œí”Œë¦¿ ìƒì„±
    template := &x509.Certificate{
        SerialNumber: serialNumber,
        Subject:      csr.Subject,
        NotBefore:    time.Now(),
        NotAfter:     time.Now().Add(validity),
        KeyUsage:     x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
        ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
    }
    
    // ì¸ì¦ì„œ ìƒì„± ë° ì„œëª…
    certDER, err := CreateCertificate(
        template,
        ca.RootCert,
        csr.PublicKey,
        ca.PrivateKey,
    )
    if err != nil {
        return nil, err
    }
    
    return x509.ParseCertificate(certDER)
}
```

### 7.1.3 ì¸ì¦ì„œ ì²´ì¸

ì¸ì¦ì„œ ì²´ì¸ì€ ë£¨íŠ¸ CAë¡œë¶€í„° ìµœì¢… ì—”í‹°í‹° ì¸ì¦ì„œê¹Œì§€ì˜ ì‹ ë¢° ê²½ë¡œë¥¼ í˜•ì„±í•©ë‹ˆë‹¤:

$Root \rightarrow Intermediate_1 \rightarrow ... \rightarrow Intermediate_n \rightarrow EndEntity$

```go
func VerifyCertificateChain(
    cert *x509.Certificate,
    intermediates []*x509.Certificate,
    roots *x509.CertPool,
) error {
    // ì¸ì¦ì„œ ì²´ì¸ êµ¬ì„±
    opts := x509.VerifyOptions{
        Roots:         roots,
        Intermediates: x509.NewCertPool(),
    }
    
    // ì¤‘ê°„ ì¸ì¦ì„œ ì¶”ê°€
    for _, intermediate := range intermediates {
        opts.Intermediates.AddCert(intermediate)
    }
    
    // ì²´ì¸ ê²€ì¦
    chains, err := cert.Verify(opts)
    if err != nil {
        return fmt.Errorf("ì¸ì¦ì„œ ì²´ì¸ ê²€ì¦ ì‹¤íŒ¨: %v", err)
    }
    
    return nil
}
```

## 7.2 ì¸ì¦ì„œ ê´€ë¦¬

### 7.2.1 ì¸ì¦ì„œ ë°œê¸‰ í”„ë¡œì„¸ìŠ¤

ì¸ì¦ì„œ ë°œê¸‰ì€ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰ë©ë‹ˆë‹¤:

1. **CSR (Certificate Signing Request) ìƒì„±**
   ```go
   func GenerateCSR(
       privateKey *rsa.PrivateKey,
       subject pkix.Name,
   ) ([]byte, error) {
       template := &x509.CertificateRequest{
           Subject:            subject,
           SignatureAlgorithm: x509.SHA256WithRSA,
       }
       
       csrDER, err := x509.CreateCertificateRequest(
           rand.Reader,
           template,
           privateKey,
       )
       if err != nil {
           return nil, err
       }
       
       return pem.EncodeToMemory(&pem.Block{
           Type:  "CERTIFICATE REQUEST",
           Bytes: csrDER,
       }), nil
   }
   ```

2. **ì¸ì¦ì„œ ë°œê¸‰**
   - CSR ê²€ì¦
   - ì •ì±… í™•ì¸
   - ì¸ì¦ì„œ ìƒì„±

3. **ì¸ì¦ì„œ ë°°í¬**
   - ì•ˆì „í•œ ì „ë‹¬
   - ì„¤ì¹˜ í™•ì¸
   - ë°±ì—… ì €ì¥

### 7.2.2 ì¸ì¦ì„œ ìˆ˜ëª…ì£¼ê¸° ê´€ë¦¬

ì¸ì¦ì„œì˜ ìˆ˜ëª…ì£¼ê¸°ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë‹¨ê³„ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:

1. **ë°œê¸‰ (Issuance)**
   - ì‹ ì› í™•ì¸
   - í‚¤ ìŒ ìƒì„±
   - ì¸ì¦ì„œ ì„œëª…

2. **ìš´ì˜ (Operation)**
   - ìƒíƒœ ëª¨ë‹ˆí„°ë§
   - ê°±ì‹  ê³„íš
   - ì‚¬ìš© ê°ì‚¬

3. **íê¸° (Revocation)**
   - íê¸° ì‚¬ìœ  í™•ì¸
   - CRL ì—…ë°ì´íŠ¸
   - OCSP ì‘ë‹µ ê°±ì‹ 

```go
type CertificateLifecycleManager struct {
    CA           *CertificateAuthority
    CRLUpdater   *CRLManager
    OCSPServer   *OCSPResponder
    Database     *CertificateDB
}

func (clm *CertificateLifecycleManager) RevokeCertificate(
    serialNumber *big.Int,
    reason int,
) error {
    // ì¸ì¦ì„œ ìƒíƒœ ì—…ë°ì´íŠ¸
    if err := clm.Database.MarkAsRevoked(serialNumber, reason); err != nil {
        return err
    }
    
    // CRL ì—…ë°ì´íŠ¸
    if err := clm.CRLUpdater.UpdateCRL(); err != nil {
        return err
    }
    
    // OCSP ìƒíƒœ ì—…ë°ì´íŠ¸
    if err := clm.OCSPServer.UpdateStatus(serialNumber, reason); err != nil {
        return err
    }
    
    return nil
}
```

### 7.2.3 CRLê³¼ OCSP

ì¸ì¦ì„œ ìƒíƒœ ê²€ì¦ ë©”ì»¤ë‹ˆì¦˜:

1. **CRL (Certificate Revocation List)**
   ìˆ˜í•™ì  í‘œí˜„:
   $CRL_{signature} = Sign_{CA_{private}}(Hash(RevocationList))$

   ```go
   type CRLManager struct {
       CA          *CertificateAuthority
       RevokedCerts map[string]*RevokedCert
   }

   func (cm *CRLManager) GenerateCRL() ([]byte, error) {
       template := &x509.RevocationList{
           Number:     big.NewInt(time.Now().Unix()),
           ThisUpdate: time.Now(),
           NextUpdate: time.Now().Add(24 * time.Hour),
       }
       
       for _, cert := range cm.RevokedCerts {
           template.RevokedCertificates = append(
               template.RevokedCertificates,
               cert.ToCRLEntry(),
           )
       }
       
       return x509.CreateRevocationList(
           rand.Reader,
           template,
           cm.CA.RootCert,
           cm.CA.PrivateKey,
       )
   }
   ```

2. **OCSP (Online Certificate Status Protocol)**
   ```go
   type OCSPResponder struct {
       CA      *CertificateAuthority
       Cache   *OCSPResponseCache
   }

   func (or *OCSPResponder) HandleRequest(
       req *ocsp.Request,
   ) (*ocsp.Response, error) {
       // ìºì‹œëœ ì‘ë‹µ í™•ì¸
       if response := or.Cache.Get(req.SerialNumber); response != nil {
           return response, nil
       }
       
       // ì¸ì¦ì„œ ìƒíƒœ ì¡°íšŒ
       status, err := or.CheckCertStatus(req.SerialNumber)
       if err != nil {
           return nil, err
       }
       
       // OCSP ì‘ë‹µ ìƒì„±
       template := &ocsp.Response{
           Status:       status,
           ThisUpdate:   time.Now(),
           NextUpdate:   time.Now().Add(time.Hour),
           SerialNumber: req.SerialNumber,
       }
       
       return ocsp.CreateResponse(
           or.CA.RootCert,
           or.CA.RootCert,
           template,
           or.CA.PrivateKey,
       )
   }
   ```

## 7.3 ì›¹ PKI

### 7.3.1 SSL/TLS ì¸ì¦ì„œ

ì›¹ ì„œë²„ ì¸ì¦ì„œì˜ êµ¬ì„±ê³¼ ê²€ì¦:

```go
type WebServerCertificate struct {
    Certificate  *x509.Certificate
    PrivateKey   *rsa.PrivateKey
    Intermediates []*x509.Certificate
}

func (wsc *WebServerCertificate) ValidateForTLS() error {
    // í‚¤ ì‚¬ìš©ë„ í™•ì¸
    if wsc.Certificate.KeyUsage&x509.KeyUsageKeyEncipherment == 0 {
        return errors.New("í‚¤ ì‚¬ìš©ë„ê°€ TLSì— ì í•©í•˜ì§€ ì•ŠìŒ")
    }
    
    // í™•ì¥ í‚¤ ì‚¬ìš©ë„ í™•ì¸
    hasServerAuth := false
    for _, usage := range wsc.Certificate.ExtKeyUsage {
        if usage == x509.ExtKeyUsageServerAuth {
            hasServerAuth = true
            break
        }
    }
    if !hasServerAuth {
        return errors.New("ì„œë²„ ì¸ì¦ ì‚¬ìš©ë„ê°€ ì—†ìŒ")
    }
    
    // ìœ íš¨ê¸°ê°„ í™•ì¸
    now := time.Now()
    if now.Before(wsc.Certificate.NotBefore) || 
       now.After(wsc.Certificate.NotAfter) {
        return errors.New("ì¸ì¦ì„œê°€ ìœ íš¨í•˜ì§€ ì•Šì€ ê¸°ê°„")
    }
    
    return nil
}
```

### 7.3.2 Let's Encrypt

ìë™í™”ëœ ì¸ì¦ì„œ ë°œê¸‰ í”„ë¡œì„¸ìŠ¤:

```go
type ACMEClient struct {
    Account     *ACMEAccount
    Directory   *ACMEDirectory
    Challenges  map[string]*Challenge
}

func (ac *ACMEClient) ObtainCertificate(
    domains []string,
) (*x509.Certificate, error) {
    // ì£¼ë¬¸ ìƒì„±
    order, err := ac.CreateOrder(domains)
    if err != nil {
        return nil, err
    }
    
    // ë„ë©”ì¸ ê²€ì¦
    for _, authzURL := range order.Authorizations {
        if err := ac.ValidateDomain(authzURL); err != nil {
            return nil, err
        }
    }
    
    // CSR ìƒì„± ë° ì œì¶œ
    csr, err := ac.GenerateCSR(domains)
    if err != nil {
        return nil, err
    }
    
    // ì¸ì¦ì„œ ë°œê¸‰ ì™„ë£Œ
    return ac.FinalizeCertificate(order.Finalize, csr)
}
```

### 7.3.3 ë¸Œë¼ìš°ì € ì‹ ë¢° ì €ì¥ì†Œ

ë¸Œë¼ìš°ì €ì˜ ì¸ì¦ì„œ ê²€ì¦ í”„ë¡œì„¸ìŠ¤:

```go
type CertificateVerifier struct {
    TrustStore  *x509.CertPool
    CRLChecker  *CRLChecker
    OCSPChecker *OCSPChecker
}

func (cv *CertificateVerifier) VerifyServerCertificate(
    chains [][]*x509.Certificate,
    serverName string,
) error {
    for _, chain := range chains {
        // ì²´ì¸ ê²€ì¦
        if err := cv.VerifyChain(chain); err != nil {
            continue
        }
        
        // í˜¸ìŠ¤íŠ¸ëª… ê²€ì¦
        if err := cv.VerifyHostname(chain[0], serverName); err != nil {
            continue
        }
        
        // ì¸ì¦ì„œ ìƒíƒœ ê²€ì¦
        if err := cv.CheckRevocationStatus(chain); err != nil {
            continue
        }
        
        // ëª¨ë“  ê²€ì¦ í†µê³¼
        return nil
    }
    
    return errors.New("ìœ íš¨í•œ ì¸ì¦ì„œ ì²´ì¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
}

func (cv *CertificateVerifier) VerifyChain(
    chain []*x509.Certificate,
) error {
    opts := x509.VerifyOptions{
        Roots:         cv.TrustStore,
        Intermediates: x509.NewCertPool(),
        CurrentTime:   time.Now(),
    }
    
    // ì¤‘ê°„ ì¸ì¦ì„œ ì¶”ê°€
    for i := 1; i < len(chain); i++ {
        opts.Intermediates.AddCert(chain[i])
    }
    
    _, err := chain[0].Verify(opts)
    return err
}
```

### 7.3.4 HSTSì™€ DANE

1. **HSTS (HTTP Strict Transport Security)**
   ì›¹ì‚¬ì´íŠ¸ì˜ HTTPS ê°•ì œ ì ìš©:

```go
type HSTSManager struct {
    MaxAge     int64
    Subdomains bool
    Preload    bool
}

func (hm *HSTSManager) GenerateHeader() string {
    header := fmt.Sprintf("max-age=%d", hm.MaxAge)
    
    if hm.Subdomains {
        header += "; includeSubDomains"
    }
    
    if hm.Preload {
        header += "; preload"
    }
    
    return header
}
```

2. **DANE (DNS-based Authentication of Named Entities)**
   DNSë¥¼ í†µí•œ ì¸ì¦ì„œ ê²€ì¦:

```go
type DANEVerifier struct {
    DNSSECResolver *DNSSECResolver
}

func (dv *DANEVerifier) VerifyTLSA(
    domain string,
    cert *x509.Certificate,
) error {
    // TLSA ë ˆì½”ë“œ ì¡°íšŒ
    tlsaRecords, err := dv.DNSSECResolver.QueryTLSA(
        fmt.Sprintf("_%d._tcp.%s", 443, domain),
    )
    if err != nil {
        return err
    }
    
    // ì¸ì¦ì„œ í•´ì‹œ ê³„ì‚°
    certHash := sha256.Sum256(cert.Raw)
    
    // TLSA ë ˆì½”ë“œì™€ ë¹„êµ
    for _, record := range tlsaRecords {
        if record.MatchesCertificate(certHash[:]) {
            return nil
        }
    }
    
    return errors.New("ì¼ì¹˜í•˜ëŠ” TLSA ë ˆì½”ë“œ ì—†ìŒ")
}
```

## 7.4 ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 7.4.1 í‚¤ ê´€ë¦¬

ì•ˆì „í•œ í‚¤ ê´€ë¦¬ êµ¬í˜„:

```go
type KeyManager struct {
    HSM         *HSMInterface
    KeyStore    *SecureKeyStore
    AccessLog   *AuditLogger
}

func (km *KeyManager) GenerateKeyPair(
    keyType string,
    keySize int,
) (interface{}, interface{}, error) {
    // HSMì—ì„œ í‚¤ ìƒì„±
    privateKey, publicKey, err := km.HSM.GenerateKeyPair(keyType, keySize)
    if err != nil {
        return nil, nil, err
    }
    
    // í‚¤ ì €ì¥
    if err := km.KeyStore.StoreKey(privateKey); err != nil {
        return nil, nil, err
    }
    
    // ê°ì‚¬ ë¡œê·¸ ê¸°ë¡
    km.AccessLog.LogKeyGeneration(keyType, keySize)
    
    return privateKey, publicKey, nil
}
```

### 7.4.2 ì¸ì¦ì„œ ì •ì±…

ì¸ì¦ì„œ ì •ì±… êµ¬í˜„ ë° ì ìš©:

```go
type CertificatePolicy struct {
    MinKeySize        int
    MaxValidityPeriod time.Duration
    AllowedKeyUsages  []x509.KeyUsage
    RequiredExtensions []string
}

func (cp *CertificatePolicy) ValidateCSR(
    csr *x509.CertificateRequest,
) error {
    // í‚¤ í¬ê¸° ê²€ì¦
    if keySize := GetKeySize(csr.PublicKey); keySize < cp.MinKeySize {
        return fmt.Errorf(
            "í‚¤ í¬ê¸°ê°€ ë„ˆë¬´ ì‘ìŒ: %d < %d",
            keySize,
            cp.MinKeySize,
        )
    }
    
    // ê¸°íƒ€ ì •ì±… ê²€ì¦
    return cp.validateExtensions(csr)
}
```

### 7.4.3 ê°ì‚¬ì™€ ëª¨ë‹ˆí„°ë§

PKI ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§:

```go
type PKIMonitor struct {
    MetricsCollector *MetricsCollector
    AlertSystem     *AlertManager
    AuditLogger     *AuditLogger
}

func (pm *PKIMonitor) MonitorCertificateOperations() {
    // ë©”íŠ¸ë¦­ ìˆ˜ì§‘
    metrics := pm.MetricsCollector.CollectMetrics()
    
    // ì„ê³„ê°’ í™•ì¸
    if metrics.FailedIssuanceRate > 0.05 {
        pm.AlertSystem.SendAlert(
            "ë†’ì€ ì¸ì¦ì„œ ë°œê¸‰ ì‹¤íŒ¨ìœ¨",
            metrics.FailedIssuanceRate,
        )
    }
    
    // ê°ì‚¬ ë¡œê·¸ ë¶„ì„
    pm.AuditLogger.AnalyzeLogs()
}
```

## ë§ˆë¬´ë¦¬

PKIëŠ” í˜„ëŒ€ ì¸í„°ë„· ë³´ì•ˆì˜ ê·¼ê°„ì„ ì´ë£¨ëŠ” í•µì‹¬ ì¸í”„ë¼ì…ë‹ˆë‹¤. ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ PKI êµ¬í˜„ì„ ìœ„í•´ì„œëŠ” ë‹¤ìŒ ì‚¬í•­ë“¤ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤:

1. **ë³´ì•ˆì„±**
   - ê°•ë ¥í•œ ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
   - ì•ˆì „í•œ í‚¤ ê´€ë¦¬
   - ì² ì €í•œ ì¸ì¦ì„œ ì •ì±…

2. **í™•ì¥ì„±**
   - íš¨ìœ¨ì ì¸ ì¸ì¦ì„œ ê´€ë¦¬
   - ìë™í™”ëœ ìš´ì˜
   - ë¶„ì‚° ì‹œìŠ¤í…œ ì§€ì›

3. **ì‹ ë¢°ì„±**
   - ê°ì‚¬ ë° ëª¨ë‹ˆí„°ë§
   - ì¬í•´ ë³µêµ¬ ê³„íš
   - ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘

### í–¥í›„ ë°œì „ ë°©í–¥

1. **ìë™í™”**
   - ìë™í™”ëœ ì¸ì¦ì„œ ê´€ë¦¬
   - DevOps í†µí•©
   - ìë™ ê°±ì‹  ì‹œìŠ¤í…œ

2. **ìƒˆë¡œìš´ ê¸°ìˆ **
   - ì–‘ì ë‚´ì„± ì•”í˜¸í™”
   - ë¸”ë¡ì²´ì¸ í†µí•©
   - ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì•„í‚¤í…ì²˜

3. **í‘œì¤€í™”**
   - êµ­ì œ í‘œì¤€ ë°œì „
   - ìƒí˜¸ìš´ìš©ì„± ê°œì„ 
   - ê·œì œ ì¤€ìˆ˜ ê°•í™”

PKI ì‹œìŠ¤í…œì€ ì§€ì†ì ìœ¼ë¡œ ë°œì „í•˜ê³  ìˆìœ¼ë©°, íŠ¹íˆ ìë™í™”ì™€ ìƒˆë¡œìš´ ë³´ì•ˆ ìœ„í˜‘ì— ëŒ€í•œ ëŒ€ì‘ì´ ì¤‘ìš”í•œ ê³¼ì œë¡œ ëŒ€ë‘ë˜ê³  ìˆìŠµë‹ˆë‹¤. ì‹¤ë¬´ìë“¤ì€ ì´ëŸ¬í•œ ë³€í™”ì— ëŒ€ì‘í•˜ë©´ì„œ ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ PKI ìš´ì˜ì„ ìœ„í•´ ì§€ì†ì ì¸ í•™ìŠµê³¼ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.

---

# 8. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

ì•”í˜¸í™” ì‹œìŠ¤í…œì˜ ì•ˆì „ì„±ì€ ì•Œê³ ë¦¬ì¦˜ ìì²´ì˜ ë³´ì•ˆì„±ë¿ë§Œ ì•„ë‹ˆë¼ êµ¬í˜„ê³¼ ìš´ì˜ ë°©ì‹ì— í¬ê²Œ ì˜ì¡´í•©ë‹ˆë‹¤. ë³¸ ë¬¸ì„œì—ì„œëŠ” ì•”í˜¸í™” ì‹œìŠ¤í…œ êµ¬í˜„ê³¼ ìš´ì˜ì— ìˆì–´ ê³ ë ¤í•´ì•¼ í•  ì£¼ìš” ë³´ì•ˆ ì‚¬í•­ë“¤ì„ ìƒì„¸íˆ ë‹¤ë£¹ë‹ˆë‹¤.

## 8.1 ì•Œê³ ë¦¬ì¦˜ ì„ íƒ

ì•ˆì „í•œ ì•”í˜¸í™” ì‹œìŠ¤í…œ êµ¬ì¶•ì„ ìœ„í•œ ì²« ë‹¨ê³„ëŠ” ì ì ˆí•œ ì•Œê³ ë¦¬ì¦˜ì˜ ì„ íƒì…ë‹ˆë‹¤.

### 8.1.1 ìš©ë„ë³„ ì í•©í•œ ì•Œê³ ë¦¬ì¦˜

ê° ì‚¬ìš© ì‚¬ë¡€ë³„ ê¶Œì¥ ì•Œê³ ë¦¬ì¦˜ê³¼ ì„¤ì •:

1. **ë°ì´í„° ì•”í˜¸í™”**
   - ëŒ€ì¹­í‚¤: AES-256 (GCM ëª¨ë“œ)
   - ë¹„ëŒ€ì¹­í‚¤: RSA-3072 ë˜ëŠ” ECC P-256
   - í•´ì‹œ: SHA-256 ì´ìƒ

ìˆ˜í•™ì  ë³´ì•ˆ ê°•ë„ëŠ” ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ë©ë‹ˆë‹¤:

$SecurityStrength_{bits} = \min(KeySize, BlockSize, HashSize)$

```go
type AlgorithmSelector struct {
    SecurityLevel int
    Performance  bool
    Compliance   map[string]bool
}

func (as *AlgorithmSelector) SelectEncryptionAlgorithm() Algorithm {
    if as.SecurityLevel >= 256 {
        if as.Performance {
            return Algorithm{
                Type:      "AES",
                KeySize:   256,
                Mode:      "GCM",
                IVSize:    96,
                TagSize:   128,
            }
        }
        return Algorithm{
            Type:    "ChaCha20",
            KeySize: 256,
            Nonce:   96,
        }
    }
    return DefaultAlgorithm()
}
```

### 8.1.2 í‚¤ ê¸¸ì´ ì„ íƒ

í‚¤ ê¸¸ì´ëŠ” ë³´ì•ˆ ìˆ˜ì¤€ê³¼ ì§ì ‘ì ì¸ ê´€ë ¨ì´ ìˆìŠµë‹ˆë‹¤:

$WorkFactor_{classical} = 2^{SecurityLevel}$
$WorkFactor_{quantum} = 2^{SecurityLevel/2}$ (Grover's Algorithm)

```go
func CalculateKeySize(
    securityLevel int,
    algorithmType string,
    quantumResistant bool,
) int {
    switch algorithmType {
    case "RSA":
        // RSAëŠ” ë” ê¸´ í‚¤ê°€ í•„ìš”
        return securityLevel * 4
    case "ECC":
        // ECCëŠ” ë” ì§§ì€ í‚¤ë¡œ ë™ë“±í•œ ë³´ì•ˆì„± ì œê³µ
        return securityLevel * 2
    case "AES":
        if quantumResistant {
            // ì–‘ì ì»´í“¨í„° ëŒ€ë¹„
            return securityLevel * 2
        }
        return securityLevel
    default:
        return securityLevel
    }
}
```

### 8.1.3 ë³´ì•ˆ ë ˆë²¨ ê²°ì •

ì‹œìŠ¤í…œì˜ ë³´ì•ˆ ë ˆë²¨ì€ ë‹¤ìŒ ìš”ì†Œë“¤ì„ ê³ ë ¤í•˜ì—¬ ê²°ì •ë©ë‹ˆë‹¤:

1. **ìœ„í˜‘ ëª¨ë¸ ë¶„ì„**
   ```go
   type ThreatModel struct {
       AttackerCapabilities struct {
           ComputationalPower float64  // MIPS
           TimeLimit         time.Duration
           Budget           float64    // USD
       }
       AssetValue          float64    // USD
       RiskTolerance       float64    // 0-1
   }

   func (tm *ThreatModel) RequiredSecurityLevel() int {
       // ìœ„í˜‘ ìˆ˜ì¤€ì— ë”°ë¥¸ í•„ìš” ë³´ì•ˆ ê°•ë„ ê³„ì‚°
       securityBits := math.Ceil(
           math.Log2(
               tm.AttackerCapabilities.ComputationalPower *
               tm.AttackerCapabilities.TimeLimit.Hours() *
               tm.AttackerCapabilities.Budget /
               tm.AssetValue,
           ),
       )
       return int(securityBits)
   }
   ```

2. **ê·œì œ ìš”êµ¬ì‚¬í•­**
   - FIPS 140-2/3
   - PCI DSS
   - GDPR

## 8.2 êµ¬í˜„ ë³´ì•ˆ

### 8.2.1 ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±

ì•”í˜¸í•™ì ìœ¼ë¡œ ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±ì€ í•„ìˆ˜ì ì…ë‹ˆë‹¤:

```go
type SecureRandomGenerator struct {
    EntropySource io.Reader
    StateSize     int
}

func (srg *SecureRandomGenerator) GenerateKey(size int) ([]byte, error) {
    // ì¶©ë¶„í•œ ì—”íŠ¸ë¡œí”¼ í™•ì¸
    entropyAvailable, err := checkEntropyAvailable(srg.EntropySource)
    if err != nil || !entropyAvailable {
        return nil, errors.New("ì¶©ë¶„í•œ ì—”íŠ¸ë¡œí”¼ ì—†ìŒ")
    }
    
    key := make([]byte, size)
    _, err = io.ReadFull(srg.EntropySource, key)
    if err != nil {
        return nil, fmt.Errorf("í‚¤ ìƒì„± ì‹¤íŒ¨: %v", err)
    }
    
    return key, nil
}
```

### 8.2.2 ë¶€ì±„ë„ ê³µê²© ë°©ì§€

ë¶€ì±„ë„ ê³µê²©ì— ëŒ€í•œ ëŒ€ì‘:

1. **íƒ€ì´ë° ê³µê²© ë°©ì§€**
   ```go
   func ConstantTimeCompare(a, b []byte) bool {
       if len(a) != len(b) {
           return false
       }
       
       var result byte
       for i := 0; i < len(a); i++ {
           result |= a[i] ^ b[i]
       }
       return result == 0
   }
   ```

2. **ìºì‹œ ê³µê²© ë°©ì§€**
   ```go
   type SecureCache struct {
       data map[string][]byte
       mu   sync.RWMutex
   }

   func (sc *SecureCache) Get(key string) ([]byte, bool) {
       sc.mu.RLock()
       defer sc.mu.RUnlock()
       
       // ëª¨ë“  í‚¤ì— ëŒ€í•´ ë™ì¼í•œ ì‹œê°„ ì†Œìš”
       result := make([]byte, 0)
       found := false
       
       for k, v := range sc.data {
           if ConstantTimeCompare([]byte(k), []byte(key)) {
               result = make([]byte, len(v))
               copy(result, v)
               found = true
           }
       }
       
       return result, found
   }
   ```

### 8.2.3 ë©”ëª¨ë¦¬ ë³´ì•ˆ

ë¯¼ê°í•œ ë°ì´í„°ì˜ ì•ˆì „í•œ ë©”ëª¨ë¦¬ ê´€ë¦¬:

```go
type SecureMemory struct {
    data   []byte
    locked bool
}

func NewSecureMemory(size int) (*SecureMemory, error) {
    // ë©”ëª¨ë¦¬ í˜ì´ì§€ ì ê¸ˆ
    data := make([]byte, size)
    if err := mlock(data); err != nil {
        return nil, err
    }
    
    return &SecureMemory{
        data:   data,
        locked: true,
    }, nil
}

func (sm *SecureMemory) Clear() {
    if sm.locked {
        // ë©”ëª¨ë¦¬ ì œë¡œí™”
        for i := range sm.data {
            sm.data[i] = 0
        }
        // ë©”ëª¨ë¦¬ ì ê¸ˆ í•´ì œ
        munlock(sm.data)
        sm.locked = false
    }
}
```

## 8.3 ìš´ì˜ ë³´ì•ˆ

### 8.3.1 í‚¤ ê´€ë¦¬ ì •ì±…

ì•ˆì „í•œ í‚¤ ê´€ë¦¬ë¥¼ ìœ„í•œ ì •ì±…:

```go
type KeyManagementPolicy struct {
    RotationPeriod    time.Duration
    BackupStrategy    BackupConfig
    AccessControl     AccessPolicy
}

func (kmp *KeyManagementPolicy) EnforceRotation(key *CryptoKey) error {
    if time.Since(key.CreationTime) > kmp.RotationPeriod {
        // í‚¤ êµì²´ í•„ìš”
        newKey, err := GenerateNewKey(key.Algorithm, key.Size)
        if err != nil {
            return err
        }
        
        // ë°ì´í„° ì¬ì•”í˜¸í™”
        if err := ReencryptData(key, newKey); err != nil {
            return err
        }
        
        // ì´ì „ í‚¤ ì•ˆì „í•˜ê²Œ íê¸°
        return SecurelyDestroyKey(key)
    }
    return nil
}
```

### 8.3.2 ê°ì‚¬ì™€ ëª¨ë‹ˆí„°ë§

ë³´ì•ˆ ê°ì‚¬ êµ¬í˜„:

```go
type SecurityAuditor struct {
    Logger    *log.Logger
    Alerts    *AlertSystem
    Metrics   *MetricsCollector
}

func (sa *SecurityAuditor) AuditCryptoOperation(
    operation string,
    params map[string]interface{},
) {
    // ì‘ì—… ë¡œê¹…
    logEntry := SecurityLogEntry{
        Timestamp:  time.Now(),
        Operation: operation,
        Params:    params,
        UserID:    getCurrentUser(),
        SourceIP:  getSourceIP(),
    }
    
    sa.Logger.Log(logEntry)
    
    // ì´ìƒ ì§•í›„ íƒì§€
    if sa.detectAnomaly(logEntry) {
        sa.Alerts.SendAlert(
            "ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ì•”í˜¸í™” ì‘ì—… ê°ì§€",
            logEntry,
        )
    }
    
    // ë©”íŠ¸ë¦­ ìˆ˜ì§‘
    sa.Metrics.RecordOperation(operation)
}
```

### 8.3.3 ì¸ì‹œë˜íŠ¸ ëŒ€ì‘

ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘ ê³„íš:

```go
type IncidentResponse struct {
    Timeline     []IncidentEvent
    Severity     int
    Status       string
    Responders   []Responder
}

func (ir *IncidentResponse) HandleKeyCompromise(key *CryptoKey) error {
    // 1. ì¦‰ì‹œ í‚¤ ë¹„í™œì„±í™”
    if err := DisableKey(key); err != nil {
        return err
    }
    
    // 2. ì˜í–¥ í‰ê°€
    affectedData := AssessCompromiseScope(key)
    
    // 3. ìƒˆ í‚¤ ìƒì„±
    newKey, err := GenerateNewKey(key.Algorithm, key.Size)
    if err != nil {
        return err
    }
    
    // 4. ë°ì´í„° ì¬ì•”í˜¸í™”
    for _, data := range affectedData {
        if err := ReencryptData(data, newKey); err != nil {
            ir.LogFailure(data, err)
        }
    }
    
    // 5. ì‚¬ê³  ë³´ê³ 
    return ir.ReportIncident(key, affectedData)
}
```

## 8.4 ê·œì œ ì¤€ìˆ˜

### 8.4.1 ì£¼ìš” ê·œì œ ìš”êµ¬ì‚¬í•­

ë‹¤ì–‘í•œ ê·œì œ í‘œì¤€ì˜ ì•”í˜¸í™” ìš”êµ¬ì‚¬í•­:

```go
type ComplianceChecker struct {
    Standards map[string]ComplianceStandard
}

func (cc *ComplianceChecker) ValidateEncryption(
    algorithm Algorithm,
    keySize int,
    usage string,
) []ComplianceIssue {
    var issues []ComplianceIssue
    
    for name, standard := range cc.Standards {
        if !standard.ValidateAlgorithm(algorithm) {
            issues = append(issues, ComplianceIssue{
                Standard: name,
                Message:  "ì•Œê³ ë¦¬ì¦˜ ë¯¸ì¤€ìˆ˜",
            })
        }
        
        if !standard.ValidateKeySize(keySize) {
            issues = append(issues, ComplianceIssue{
                Standard: name,
                Message:  "í‚¤ ê¸¸ì´ ë¯¸ì¤€ìˆ˜",
            })
        }
    }
    
    return issues
}
```

### 8.4.2 ê°ì‚¬ ì¶”ì 

ê·œì œ ì¤€ìˆ˜ë¥¼ ìœ„í•œ ê°ì‚¬ ì¶”ì  êµ¬í˜„:

```go
type AuditTrail struct {
    Storage    AuditStorage
    Retention  time.Duration
    Encryption *EncryptionConfig
}

func (at *AuditTrail) RecordEvent(event AuditEvent) error {
    // ì´ë²¤íŠ¸ ë¬´ê²°ì„± ë³´ì¥
    event.Hash = calculateEventHash(event)
    
    // ì´ë²¤íŠ¸ ì•”í˜¸í™”
    encryptedEvent, err := at.Encryption.EncryptEvent(event)
    if err != nil {
        return err
    }
    
    // ì €ì¥ì†Œì— ê¸°ë¡
    return at.Storage.Store(encryptedEvent)
}
```

## ë§ˆë¬´ë¦¬

ì•”í˜¸í™” ì‹œìŠ¤í…œì˜ ë³´ì•ˆì€ ì§€ì†ì ì¸ ê´€ë¦¬ì™€ ê°œì„ ì´ í•„ìš”í•œ ê³¼ì •ì…ë‹ˆë‹¤. ë‹¤ìŒ ì‚¬í•­ë“¤ì„ í•­ìƒ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤:

1. ì•Œê³ ë¦¬ì¦˜ê³¼ í‚¤ ê¸¸ì´ì˜ ì ì ˆí•œ ì„ íƒ
2. ì•ˆì „í•œ êµ¬í˜„ê³¼ ìš´ì˜ ë°©ì•ˆ
3. ì§€ì†ì ì¸ ëª¨ë‹ˆí„°ë§ê³¼ ê°ì‚¬
4. ì‹ ì†í•œ ì¸ì‹œë˜íŠ¸ ëŒ€ì‘

### í–¥í›„ ê³ ë ¤ì‚¬í•­

1. **ì–‘ì ì»´í“¨íŒ… ëŒ€ë¹„**
   - ì–‘ì ë‚´ì„± ì•Œê³ ë¦¬ì¦˜ ë„ì…
   - í•˜ì´ë¸Œë¦¬ë“œ ì•”í˜¸í™” ì‹œìŠ¤í…œ
   - ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš

2. **ìƒˆë¡œìš´ ìœ„í˜‘ ëŒ€ì‘**
   - AI ê¸°ë°˜ ê³µê²© ëŒ€ë¹„
   - ì œë¡œë°ì´ ì·¨ì•½ì  ëŒ€ì‘
   - ì§€ì†ì ì¸ ë³´ì•ˆ í‰ê°€

3. **ê·œì œ ë³€í™” ëŒ€ì‘**
   - ìƒˆë¡œìš´ ê·œì œ ì¤€ìˆ˜
   - êµ­ì œ í‘œì¤€ ì ìš©
   - ë¬¸ì„œí™”ì™€ ì¦ê±° ê´€ë¦¬

ì•”í˜¸í™” ì‹œìŠ¤í…œì˜ ë³´ì•ˆì€ ê¸°ìˆ ì  ì¸¡ë©´ë¿ë§Œ ì•„ë‹ˆë¼ ìš´ì˜ì , ê´€ë¦¬ì  ì¸¡ë©´ì—ì„œë„ ì¢…í•©ì ì¸ ì ‘ê·¼ì´ í•„ìš”í•©ë‹ˆë‹¤. ì§€ì†ì ì¸ ìœ„í˜‘ í‰ê°€ì™€ ëŒ€ì‘ ì²´ê³„ ê°œì„ ì„ í†µí•´ ì‹œìŠ¤í…œì˜ ì•ˆì „ì„±ì„ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤.

---

# 9. ì„±ëŠ¥ê³¼ ìµœì í™”

ì•”í˜¸í™” ì‹œìŠ¤í…œì˜ ì„±ëŠ¥ì€ ì „ì²´ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì‘ë‹µì„±ê³¼ ì²˜ë¦¬ëŸ‰ì— ì§ì ‘ì ì¸ ì˜í–¥ì„ ë¯¸ì¹©ë‹ˆë‹¤. ë³¸ ë¬¸ì„œì—ì„œëŠ” ì•”í˜¸í™” ì‘ì—…ì˜ ì„±ëŠ¥ ìµœì í™” ë°©ë²•ê³¼ êµ¬í˜„ ì „ëµì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

## 9.1 í•˜ë“œì›¨ì–´ ê°€ì†

### 9.1.1 ì•”í˜¸í™” ì „ìš© ì¹©

í˜„ëŒ€ í”„ë¡œì„¸ì„œì˜ ì•”í˜¸í™” ê°€ì† ê¸°ëŠ¥ì„ í™œìš©í•œ ìµœì í™”:

1. **AES-NI (Advanced Encryption Standard New Instructions)**
   Intel/AMD CPUì˜ AES ì „ìš© ëª…ë ¹ì–´ í™œìš©:

   ```go
   type AESAccelerator struct {
       HasAESNI bool
       Fallback AESImplementation
   }

   func (aa *AESAccelerator) Encrypt(data []byte) ([]byte, error) {
       if aa.HasAESNI {
           // AES-NI ì‚¬ìš©
           return aa.encryptWithAESNI(data)
       }
       // ì†Œí”„íŠ¸ì›¨ì–´ êµ¬í˜„ ì‚¬ìš©
       return aa.Fallback.Encrypt(data)
   }
   ```

   ì„±ëŠ¥ ë¹„êµ:
   $Throughput_{AES-NI} \approx k \cdot Throughput_{Software}$
   ì—¬ê¸°ì„œ $k$ëŠ” ì¼ë°˜ì ìœ¼ë¡œ 3-10 ë²”ìœ„ì˜ ê°’

2. **SIMD (Single Instruction Multiple Data)**
   ë³‘ë ¬ ë°ì´í„° ì²˜ë¦¬ë¥¼ ìœ„í•œ SIMD ëª…ë ¹ì–´ í™œìš©:

   ```go
   func ProcessBlocksSIMD(blocks []byte, key []byte) {
       // AVX2 ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•œ ë³‘ë ¬ ì²˜ë¦¬
       for i := 0; i < len(blocks); i += 32 {
           // 256ë¹„íŠ¸(32ë°”ì´íŠ¸) ë‹¨ìœ„ë¡œ ì²˜ë¦¬
           block := blocks[i:i+32]
           processBlockAVX2(block, key)
       }
   }
   ```

### 9.1.2 GPU í™œìš©

ëŒ€ê·œëª¨ ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ìœ„í•œ GPU í™œìš©:

```go
type GPUAccelerator struct {
    Device      *cuda.Device
    BlockSize   int
    ThreadCount int
}

func (ga *GPUAccelerator) BatchEncrypt(
    plaintexts [][]byte,
) ([][]byte, error) {
    // ë°ì´í„°ë¥¼ GPU ë©”ëª¨ë¦¬ë¡œ ì „ì†¡
    deviceData := ga.allocateAndTransfer(plaintexts)
    
    // ì»¤ë„ ì‹¤í–‰ êµ¬ì„±
    config := &cuda.LaunchConfig{
        BlockCount:  (len(plaintexts) + ga.BlockSize - 1) / ga.BlockSize,
        ThreadCount: ga.ThreadCount,
    }
    
    // ë³‘ë ¬ ì•”í˜¸í™” ì‹¤í–‰
    err := ga.encryptKernel.Launch(
        config,
        deviceData.input,
        deviceData.output,
        len(plaintexts),
    )
    if err != nil {
        return nil, err
    }
    
    // ê²°ê³¼ íšŒìˆ˜
    return ga.retrieveResults(deviceData.output)
}
```

ì²˜ë¦¬ëŸ‰ ë¶„ì„:
$Throughput_{GPU} = N_{cores} \cdot Clock_{GPU} \cdot Instructions_{per\_cycle}$

### 9.1.3 SIMD ëª…ë ¹ì–´

SIMDë¥¼ í™œìš©í•œ ë³‘ë ¬ ì²˜ë¦¬ ìµœì í™”:

```go
type SIMDProcessor struct {
    VectorSize int
    Alignment  int
}

func (sp *SIMDProcessor) ProcessVectors(data []byte) {
    aligned := sp.alignData(data)
    
    // ë²¡í„° ë‹¨ìœ„ ì²˜ë¦¬
    for i := 0; i < len(aligned); i += sp.VectorSize {
        vector := aligned[i:i+sp.VectorSize]
        sp.processVector(vector)
    }
}
```

## 9.2 ì†Œí”„íŠ¸ì›¨ì–´ ìµœì í™”

### 9.2.1 ì•Œê³ ë¦¬ì¦˜ ìµœì í™”

1. **ì—°ì‚° ìµœì í™”**
   ëª¨ë“ˆëŸ¬ ì§€ìˆ˜ ì—°ì‚°ì˜ ìµœì í™”:

   ```go
   func ModularExp(base, exponent, modulus *big.Int) *big.Int {
       result := big.NewInt(1)
       base.Mod(base, modulus)
       
       // ìœˆë„ìš° ë°©ì‹ êµ¬í˜„
       windowSize := 4
       precomputedValues := precomputeValues(base, modulus, windowSize)
       
       for i := exponent.BitLen() - 1; i >= 0; i-- {
           result.Mul(result, result)
           result.Mod(result, modulus)
           
           if exponent.Bit(i) == 1 {
               result.Mul(result, base)
               result.Mod(result, modulus)
           }
       }
       
       return result
   }
   ```

   ì‹œê°„ ë³µì¡ë„:
   $T(n) = O(\log n \cdot \frac{n}{\text{windowSize}})$

2. **ë©”ëª¨ë¦¬-ì‹œê°„ íŠ¸ë ˆì´ë“œì˜¤í”„**
   ```go
   type PrecomputationTable struct {
       Values    map[string][]byte
       BlockSize int
   }

   func (pt *PrecomputationTable) Initialize(key []byte) {
       // ìì£¼ ì‚¬ìš©ë˜ëŠ” ê°’ ë¯¸ë¦¬ ê³„ì‚°
       for i := 0; i < 256; i++ {
           pt.Values[string(i)] = computeRoundKey(key, i)
       }
   }
   ```

### 9.2.2 ë³‘ë ¬ ì²˜ë¦¬

ë©€í‹°ìŠ¤ë ˆë“œ ì²˜ë¦¬ êµ¬í˜„:

```go
type ParallelProcessor struct {
    Workers    int
    ChunkSize  int
    BufferPool sync.Pool
}

func (pp *ParallelProcessor) ProcessData(data []byte) error {
    chunks := pp.splitIntoChunks(data)
    results := make(chan Result, len(chunks))
    
    // ì‘ì—… ë¶„ë°°
    for i := 0; i < pp.Workers; i++ {
        go func(worker int) {
            for chunk := range chunks {
                result := pp.processChunk(chunk)
                results <- result
            }
        }(i)
    }
    
    // ê²°ê³¼ ìˆ˜ì§‘
    return pp.collectResults(results)
}
```

ì²˜ë¦¬ëŸ‰ ë¶„ì„:
$Throughput_{parallel} = \min(N_{cores}, \frac{DataSize}{ChunkSize}) \cdot Throughput_{single}$

### 9.2.3 ìºì‹œ í™œìš©

íš¨ìœ¨ì ì¸ ìºì‹œ ì‚¬ìš©:

```go
type CryptoCache struct {
    cache    *lru.Cache
    hitCount uint64
    missCount uint64
}

func (cc *CryptoCache) Get(key []byte) ([]byte, error) {
    // ìºì‹œ ì¡°íšŒ
    if value, ok := cc.cache.Get(string(key)); ok {
        atomic.AddUint64(&cc.hitCount, 1)
        return value.([]byte), nil
    }
    
    atomic.AddUint64(&cc.missCount, 1)
    
    // ìºì‹œ ë¯¸ìŠ¤ ì‹œ ê³„ì‚°
    value := cc.compute(key)
    cc.cache.Add(string(key), value)
    
    return value, nil
}
```

ìºì‹œ íš¨ìœ¨ì„±:
$CacheEfficiency = \frac{CacheHits}{CacheHits + CacheMisses}$

## 9.3 í™•ì¥ì„± ê³ ë ¤

### 9.3.1 ë¶€í•˜ ë¶„ì‚°

ë¡œë“œ ë°¸ëŸ°ì‹± êµ¬í˜„:

```go
type LoadBalancer struct {
    Workers     []*CryptoWorker
    Strategy    BalancingStrategy
    Monitoring  *PerformanceMonitor
}

func (lb *LoadBalancer) Process(request *CryptoRequest) (*CryptoResponse, error) {
    // ì›Œì»¤ ì„ íƒ
    worker := lb.Strategy.SelectWorker(lb.Workers)
    
    // ìš”ì²­ ì²˜ë¦¬
    response, err := worker.Process(request)
    
    // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
    lb.Monitoring.RecordMetrics(worker, request, response)
    
    return response, err
}
```

### 9.3.2 í‚¤ ìºì‹±

íš¨ìœ¨ì ì¸ í‚¤ ê´€ë¦¬:

```go
type KeyCache struct {
    activeKeys  map[string]*CachedKey
    mu          sync.RWMutex
    maxAge      time.Duration
}

func (kc *KeyCache) GetKey(id string) (*CachedKey, error) {
    kc.mu.RLock()
    defer kc.mu.RUnlock()
    
    if key, exists := kc.activeKeys[id]; exists {
        if !key.IsExpired() {
            return key, nil
        }
    }
    
    // í‚¤ ê°±ì‹ 
    return kc.refreshKey(id)
}
```

### 9.3.3 ì„¸ì…˜ ê´€ë¦¬

ì•”í˜¸í™” ì„¸ì…˜ ê´€ë¦¬:

```go
type SessionManager struct {
    sessions     map[string]*CryptoSession
    cleanupInterval time.Duration
}

func (sm *SessionManager) InitSession(id string) *CryptoSession {
    session := &CryptoSession{
        ID:        id,
        Created:   time.Now(),
        KeyMaterial: generateSessionKey(),
    }
    
    sm.sessions[id] = session
    return session
}
```

## 9.4 ì„±ëŠ¥ ì¸¡ì •ê³¼ ëª¨ë‹ˆí„°ë§

### 9.4.1 ì„±ëŠ¥ ë©”íŠ¸ë¦­

ì£¼ìš” ì„±ëŠ¥ ì§€í‘œ ì¸¡ì •:

```go
type PerformanceMetrics struct {
    OperationsPerSecond float64
    AverageLatency     time.Duration
    P95Latency         time.Duration
    P99Latency         time.Duration
    MemoryUsage        uint64
    CPUUtilization     float64
}

func (pm *PerformanceMetrics) Record(operation *CryptoOperation) {
    // ì§€í‘œ ìˆ˜ì§‘
    duration := operation.EndTime.Sub(operation.StartTime)
    
    // ì´ë™ í‰ê·  ê³„ì‚°
    pm.AverageLatency = calculateMovingAverage(
        pm.AverageLatency,
        duration,
    )
    
    // ì²˜ë¦¬ëŸ‰ ì—…ë°ì´íŠ¸
    atomic.AddUint64(
        &pm.OperationCount,
        1,
    )
}
```

### 9.4.2 ì„±ëŠ¥ ë¶„ì„

ì„±ëŠ¥ ë°ì´í„° ë¶„ì„:

```go
type PerformanceAnalyzer struct {
    Metrics    *PerformanceMetrics
    Thresholds map[string]float64
}

func (pa *PerformanceAnalyzer) Analyze() *AnalysisReport {
    report := &AnalysisReport{
        Timestamp: time.Now(),
        Metrics:   pa.Metrics,
    }
    
    // ë³‘ëª© ì§€ì  ì‹ë³„
    if pa.Metrics.CPUUtilization > pa.Thresholds["cpu"] {
        report.Bottlenecks = append(
            report.Bottlenecks,
            "CPU Bound",
        )
    }
    
    return report
}
```

## ë§ˆë¬´ë¦¬

ì•”í˜¸í™” ì‹œìŠ¤í…œì˜ ì„±ëŠ¥ ìµœì í™”ëŠ” ë³´ì•ˆì„±ì„ ìœ ì§€í•˜ë©´ì„œ ìˆ˜í–‰ë˜ì–´ì•¼ í•˜ë©°, ë‹¤ìŒ ì‚¬í•­ë“¤ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤:

1. í•˜ë“œì›¨ì–´ ê°€ì† í™œìš©
2. íš¨ìœ¨ì ì¸ ì†Œí”„íŠ¸ì›¨ì–´ êµ¬í˜„
3. ì ì ˆí•œ ìºì‹±ê³¼ ë³‘ë ¬ ì²˜ë¦¬
4. ì§€ì†ì ì¸ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### ì„±ëŠ¥ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸

1. í•˜ë“œì›¨ì–´ ê°€ì† ê¸°ëŠ¥ í™•ì¸
2. ë³‘ë ¬ ì²˜ë¦¬ ê°€ëŠ¥ì„± ê²€í† 
3. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
4. ìºì‹œ íš¨ìœ¨ì„± ë¶„ì„
5. ë¶€í•˜ ë¶„ì‚° ì „ëµ ìˆ˜ë¦½

### í–¥í›„ ê³ ë ¤ì‚¬í•­

1. ìƒˆë¡œìš´ í•˜ë“œì›¨ì–´ ê°€ì† ê¸°ìˆ  ì ìš©
2. ë¶„ì‚° ì‹œìŠ¤í…œ ìµœì í™”
3. í´ë¼ìš°ë“œ í™˜ê²½ ìµœì í™”
4. ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ê°•í™”

ì„±ëŠ¥ ìµœì í™”ëŠ” ì§€ì†ì ì¸ ê³¼ì •ì´ë©°, ì‹œìŠ¤í…œì˜ ìš”êµ¬ì‚¬í•­ê³¼ ì‚¬ìš© íŒ¨í„´ì˜ ë³€í™”ì— ë”°ë¼ ê³„ì†í•´ì„œ ê°œì„ ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.

---

# 10. ë¯¸ë˜ ì „ë§ê³¼ ë°œì „ ë°©í–¥

ì•”í˜¸í™” ê¸°ìˆ ì€ ê³„ì†í•´ì„œ ì§„í™”í•˜ê³  ìˆìœ¼ë©°, ìƒˆë¡œìš´ ìœ„í˜‘ê³¼ ê¸°ìˆ ì˜ ë°œì „ì— ë”°ë¼ ì ì‘í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë³¸ ë¬¸ì„œì—ì„œëŠ” ì•”í˜¸í™” ê¸°ìˆ ì˜ ë¯¸ë˜ ì „ë§ê³¼ ì£¼ìš” ë°œì „ ë°©í–¥ì„ ì‚´í´ë³´ê³ , ì´ì— ëŒ€í•œ ì¤€ë¹„ ë°©ì•ˆì„ ë…¼ì˜í•©ë‹ˆë‹¤.

## 10.1 ì–‘ì ì»´í“¨íŒ… ëŒ€ë¹„

### 10.1.1 ì–‘ì ì»´í“¨í„°ì˜ ì˜í–¥

í˜„ì¬ ì•”í˜¸í™” ì‹œìŠ¤í…œì— ëŒ€í•œ ì–‘ì ì»´í“¨í„°ì˜ ìœ„í˜‘ì„ ìˆ˜í•™ì ìœ¼ë¡œ ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

1. **Shorì˜ ì•Œê³ ë¦¬ì¦˜ ì˜í–¥**
   RSAì˜ ê²½ìš°, ê¸°ì¡´ ìµœì  ì•Œê³ ë¦¬ì¦˜ê³¼ ì–‘ì ì•Œê³ ë¦¬ì¦˜ì˜ ë³µì¡ë„ ë¹„êµ:

   ê¸°ì¡´: $O(e^{(\frac{64}{9}\log n)^{\frac{1}{3}}(\log \log n)^{\frac{2}{3}}})$
   ì–‘ì: $O((\log n)^2(\log \log n))$

```go
type QuantumSecurityAnalyzer struct {
    KeySize        int
    Algorithm      string
    QuantumBits    int
}

func (qsa *QuantumSecurityAnalyzer) AnalyzeQuantumResistance() SecurityLevel {
    switch qsa.Algorithm {
    case "RSA":
        // RSA í‚¤ì˜ ì–‘ì ë³´ì•ˆì„± ë¶„ì„
        quantumStrength := qsa.calculateQuantumStrength()
        return &SecurityAnalysis{
            ClassicalBits: qsa.KeySize,
            QuantumBits: quantumStrength,
            Recommendation: qsa.getRecommendation(),
        }
    case "ECC":
        // ECCì˜ ì–‘ì ë³´ì•ˆì„± ë¶„ì„
        return qsa.analyzeECCQuantumSecurity()
    }
    return nil
}
```

### 10.1.2 í¬ìŠ¤íŠ¸ í€€í…€ ì•”í˜¸í™”

ì–‘ì ë‚´ì„± ì•”í˜¸í™” êµ¬í˜„:

```go
type PostQuantumCrypto struct {
    Lattice    *LatticeBasedScheme
    MultiVar   *MultiVariateScheme
    Hash       *HashBasedSignature
}

func (pq *PostQuantumCrypto) GenerateKeys() (*PQKeys, error) {
    // ê²©ì ê¸°ë°˜ í‚¤ ìƒì„±
    latticeKeys, err := pq.Lattice.GenerateKeyPair()
    if err != nil {
        return nil, err
    }
    
    // í•´ì‹œ ê¸°ë°˜ ì„œëª…í‚¤ ìƒì„±
    signatureKeys, err := pq.Hash.GenerateSigningKeys()
    if err != nil {
        return nil, err
    }
    
    return &PQKeys{
        EncryptionKeys: latticeKeys,
        SignatureKeys:  signatureKeys,
    }, nil
}
```

ì£¼ìš” ê²©ì ê¸°ë°˜ ì•”í˜¸í™” ë§¤ê°œë³€ìˆ˜:

$q$: ëª¨ë“ˆëŸ¬ìŠ¤
$n$: ê²©ì ì°¨ì›
$\sigma$: ê°€ìš°ì‹œì•ˆ ë¶„í¬ì˜ í‘œì¤€í¸ì°¨

ë³´ì•ˆ ê°•ë„: $\lambda = \log_2(\text{ìµœì  ê³µê²© ë³µì¡ë„})$

### 10.1.3 ì „í™˜ ì „ëµ

ì–‘ì ë‚´ì„± ì•”í˜¸í™”ë¡œì˜ ì „í™˜ ê³„íš:

```go
type QuantumTransitionPlan struct {
    Phases        []TransitionPhase
    Timeline      time.Duration
    RiskAnalysis  *RiskAssessment
}

func (qtp *QuantumTransitionPlan) ImplementHybridScheme() error {
    // í•˜ì´ë¸Œë¦¬ë“œ ì•”í˜¸í™” ì‹œìŠ¤í…œ êµ¬í˜„
    hybridSystem := &HybridCryptoSystem{
        Classical: &ClassicalCrypto{
            RSA:  NewRSA(4096),
            ECC:  NewECC(256),
        },
        Quantum: &PostQuantumCrypto{
            Lattice: NewLatticeScheme(),
            Hash:    NewHashSignature(),
        },
    }
    
    return hybridSystem.Initialize()
}
```

## 10.2 ì‹ ê¸°ìˆ  í†µí•©

### 10.2.1 ë¸”ë¡ì²´ì¸ ì‘ìš©

ë¸”ë¡ì²´ì¸ ê¸°ìˆ ê³¼ ì•”í˜¸í™”ì˜ í†µí•©:

```go
type BlockchainCrypto struct {
    Chain      *Blockchain
    ZKProofs   *ZeroKnowledgeProofs
    HashFunc   hash.Hash
}

func (bc *BlockchainCrypto) CreateConfidentialTransaction(
    sender, receiver []byte,
    amount *big.Int,
) (*Transaction, error) {
    // ì˜ì§€ì‹ ì¦ëª… ìƒì„±
    proof, err := bc.ZKProofs.ProveTransaction(
        sender,
        receiver,
        amount,
    )
    if err != nil {
        return nil, err
    }
    
    // íŠ¸ëœì­ì…˜ ìƒì„± ë° ì„œëª…
    tx := &Transaction{
        Proof:     proof,
        Timestamp: time.Now(),
        Hash:      bc.calculateTransactionHash(),
    }
    
    return tx, nil
}
```

### 10.2.2 ì˜ì§€ì‹ ì¦ëª…

ì˜ì§€ì‹ ì¦ëª… í”„ë¡œí† ì½œ êµ¬í˜„:

```go
type ZKProofSystem struct {
    Setup      *ZKSetup
    Prover     *ZKProver
    Verifier   *ZKVerifier
}

func (zk *ZKProofSystem) GenerateProof(
    secret []byte,
    publicInfo []byte,
) (*ZKProof, error) {
    // ì¦ëª… ìƒì„±
    commitment := zk.Prover.Commit(secret)
    challenge := zk.Verifier.GenerateChallenge(commitment, publicInfo)
    response := zk.Prover.Respond(challenge, secret)
    
    return &ZKProof{
        Commitment: commitment,
        Challenge:  challenge,
        Response:   response,
    }, nil
}
```

ìˆ˜í•™ì  ê¸°ë°˜:
$Completeness: Pr[\text{Verify}(x, \pi) = 1 | x \in L] = 1$
$Soundness: Pr[\text{Verify}(x, \pi) = 1 | x \notin L] \leq \epsilon$

### 10.2.3 ë™í˜• ì•”í˜¸í™”

ì™„ì „ ë™í˜• ì•”í˜¸í™” êµ¬í˜„:

```go
type HomomorphicEncryption struct {
    PublicKey  *HEPublicKey
    SecretKey  *HESecretKey
    Params     *HEParameters
}

func (he *HomomorphicEncryption) Evaluate(
    circuit *Circuit,
    ciphertexts []*HECiphertext,
) (*HECiphertext, error) {
    // ì•”í˜¸ë¬¸ ìƒíƒœì—ì„œ ì—°ì‚° ìˆ˜í–‰
    result := ciphertexts[0]
    
    for _, gate := range circuit.Gates {
        switch gate.Type {
        case ADD:
            result = he.Add(result, ciphertexts[gate.Input])
        case MULT:
            result = he.Multiply(result, ciphertexts[gate.Input])
        case ROTATE:
            result = he.Rotate(result, gate.Rotation)
        }
        
        // ë…¸ì´ì¦ˆ ê´€ë¦¬
        if he.NoiseLevel(result) > he.Params.NoiseThreshold {
            result = he.Refresh(result)
        }
    }
    
    return result, nil
}
```

## 10.3 í‘œì¤€í™”ì™€ ê·œì œ

### 10.3.1 ì•”í˜¸í™” í‘œì¤€

ìƒˆë¡œìš´ ì•”í˜¸í™” í‘œì¤€ì˜ ê°œë°œ:

```go
type CryptoStandard struct {
    Version     string
    Algorithms  map[string]Algorithm
    Parameters  map[string]Parameter
    Compliance  map[string]Requirement
}

func (cs *CryptoStandard) ValidateImplementation(
    implementation *CryptoSystem,
) (*ValidationReport, error) {
    report := &ValidationReport{
        StandardVersion: cs.Version,
        Timestamp:      time.Now(),
    }
    
    // ì•Œê³ ë¦¬ì¦˜ ê²€ì¦
    for name, algo := range cs.Algorithms {
        if err := algo.Validate(implementation); err != nil {
            report.AddFailure(name, err)
        }
    }
    
    return report, nil
}
```

### 10.3.2 ì»´í”Œë¼ì´ì–¸ìŠ¤

ê·œì œ ì¤€ìˆ˜ ê´€ë¦¬ ì‹œìŠ¤í…œ:

```go
type ComplianceManager struct {
    Standards   map[string]*Standard
    Auditor     *ComplianceAuditor
    Reporter    *ComplianceReporter
}

func (cm *ComplianceManager) EnsureCompliance(
    system *CryptoSystem,
) (*ComplianceStatus, error) {
    // ê·œì œ ìš”êµ¬ì‚¬í•­ ê²€ì¦
    status := &ComplianceStatus{
        Timestamp: time.Now(),
        System:    system.ID,
    }
    
    for _, standard := range cm.Standards {
        result := standard.Validate(system)
        status.AddResult(standard.Name, result)
    }
    
    // ê°ì‚¬ ë¡œê·¸ ìƒì„±
    cm.Auditor.LogCompliance(status)
    
    return status, nil
}
```

### 10.3.3 ìƒí˜¸ìš´ìš©ì„±

ë‹¤ì–‘í•œ ì‹œìŠ¤í…œ ê°„ì˜ ìƒí˜¸ìš´ìš©ì„± ë³´ì¥:

```go
type InteroperabilityLayer struct {
    Protocols     map[string]Protocol
    Converters    map[string]FormatConverter
    Validators    map[string]DataValidator
}

func (il *InteroperabilityLayer) ConvertFormat(
    data []byte,
    sourceFormat,
    targetFormat string,
) ([]byte, error) {
    // ë°ì´í„° í˜•ì‹ ë³€í™˜
    converter := il.Converters[sourceFormat+"_to_"+targetFormat]
    if converter == nil {
        return nil, fmt.Errorf("ì§€ì›í•˜ì§€ ì•ŠëŠ” ë³€í™˜: %s -> %s",
            sourceFormat, targetFormat)
    }
    
    return converter.Convert(data)
}
```

## ë§ˆë¬´ë¦¬

ì•”í˜¸í™” ê¸°ìˆ ì€ ë¹ ë¥´ê²Œ ë°œì „í•˜ê³  ìˆìœ¼ë©°, ë‹¤ìŒê³¼ ê°™ì€ ì£¼ìš” íŠ¸ë Œë“œë¥¼ ì£¼ëª©í•´ì•¼ í•©ë‹ˆë‹¤:

1. ì–‘ì ì»´í“¨íŒ… ìœ„í˜‘ì— ëŒ€í•œ ëŒ€ë¹„
2. ìƒˆë¡œìš´ ì•”í˜¸í™” ê¸°ìˆ ì˜ í†µí•©
3. í‘œì¤€í™”ì™€ ê·œì œ ì¤€ìˆ˜
4. ìƒí˜¸ìš´ìš©ì„± í™•ë³´

### ì¤€ë¹„ ì‚¬í•­

1. **ê¸°ìˆ ì  ì¤€ë¹„**
   - ì–‘ì ë‚´ì„± ì•Œê³ ë¦¬ì¦˜ ì—°êµ¬
   - í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ êµ¬ì¶•
   - ì„±ëŠ¥ ìµœì í™” ì—°êµ¬

2. **ìš´ì˜ì  ì¤€ë¹„**
   - ìœ„í—˜ í‰ê°€ ë° ëŒ€ì‘ ê³„íš
   - ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ ìˆ˜ë¦½
   - ì¸ë ¥ êµìœ¡ ë° í›ˆë ¨

3. **ê·œì œ ëŒ€ì‘**
   - ìƒˆë¡œìš´ í‘œì¤€ ëª¨ë‹ˆí„°ë§
   - ì»´í”Œë¼ì´ì–¸ìŠ¤ ì²´ê³„ êµ¬ì¶•
   - ê°ì‚¬ ì²´ê³„ ê°•í™”

ì•”í˜¸í™” ê¸°ìˆ ì˜ ë¯¸ë˜ëŠ” ì–‘ì ì»´í“¨íŒ…, ë¸”ë¡ì²´ì¸, ì˜ì§€ì‹ ì¦ëª… ë“± ìƒˆë¡œìš´ ê¸°ìˆ ì˜ ë°œì „ê³¼ í•¨ê»˜ ê³„ì†í•´ì„œ ì§„í™”í•  ê²ƒì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ë³€í™”ì— ëŒ€ë¹„í•˜ì—¬ ì§€ì†ì ì¸ ì—°êµ¬ì™€ ì¤€ë¹„ê°€ í•„ìš”í•©ë‹ˆë‹¤.