아래는 C++의 객체 지향 프로그래밍과 동적 메모리 관리, 그리고 복잡한 트리 균형 유지 알고리즘을 종합적으로 연습할 수 있는 문제입니다.

---

## 문제: Red-Black Tree 구현 (C++)

### 문제 설명

Red-Black Tree는 이진 탐색 트리의 한 종류로, 삽입과 삭제 연산 후에도 트리의 균형을 유지하여 최악의 경우에도 O(log n)의 탐색 시간을 보장하는 자료구조입니다. 이 트리는 다음과 같은 속성을 만족해야 합니다.

1. **노드 색상:** 각 노드는 빨간색(Red) 또는 검은색(Black)이다.
2. **루트의 색상:** 루트 노드는 반드시 검은색이다.
3. **리프의 색상:** 모든 NIL(외부, 리프) 노드는 검은색이다.
4. **빨간색 노드의 자식:** 만약 어떤 노드가 빨간색이면, 그 자식 노드는 반드시 검은색이다. (즉, 빨간색 노드가 연속해서 나타날 수 없다.)
5. **검은색 높이:** 임의의 노드에서 리프 노드까지의 모든 경로에는 같은 수의 검은색 노드가 존재한다.

이러한 속성을 유지하면서, 다음과 같은 기능들을 구현하세요.

### 구현 요구 사항

- **클래스 설계**
  - `Node` 클래스:  
    - 멤버 변수:  
      - `int key`: 노드에 저장된 값  
      - `bool color`: 노드의 색상 (예: `true`는 Red, `false`는 Black으로 정의할 수 있음)  
      - `Node* left`, `Node* right`, `Node* parent`: 좌우 자식 및 부모 포인터
  - `RedBlackTree` 클래스:
    - 멤버 변수:  
      - 루트 노드 포인터  
      - NIL 노드 (리프로 사용되는 특별한 노드, 항상 검은색)
    - 주요 메서드:  
      - `void insert(int key)`: 새로운 키를 트리에 삽입하고, 삽입 후 트리의 균형을 복구하기 위한 `fixInsert()` 호출  
      - `void deleteNode(int key)`: 트리에서 키를 삭제하고, 삭제 후 균형을 복구하기 위한 `fixDelete()` 호출  
      - `Node* search(int key)`: 트리에서 주어진 키를 검색하여 해당 노드 포인터 반환  
      - `void inorder()`: 중위 순회(in-order traversal)를 통해 트리의 키를 정렬된 순서로 출력

- **핵심 알고리즘**
  - **회전 (Rotation):**  
    - `leftRotate(Node* x)`와 `rightRotate(Node* x)` 함수를 구현하여 트리 균형을 맞추기 위한 회전 연산을 수행합니다.
  - **균형 복구:**  
    - 삽입 후 균형 복구를 위한 `fixInsert(Node* z)` 함수 구현  
    - 삭제 후 균형 복구를 위한 `fixDelete(Node* x)` 함수 구현
  - **동적 메모리 관리:**  
    - 노드 생성 시 동적 메모리 할당 및, 삭제 시 메모리 해제를 올바르게 수행하여 메모리 누수가 발생하지 않도록 합니다.

- **입출력 인터페이스**
  - 메인 함수에서 사용자로부터 다음과 같은 명령어를 입력받습니다.
    - `I key`: 키를 삽입 (Insert)
    - `D key`: 키를 삭제 (Delete)
    - `S key`: 키를 검색 (Search)
    - `P`: 중위 순회(In-order Traversal) 결과 출력
  - 예시 입력:
    ```
    I 10
    I 20
    I 15
    P
    S 15
    D 10
    P
    ```
  - 예시 출력:
    ```
    중위 순회 결과: 10 15 20
    검색 결과: 15 (Red 또는 Black)
    중위 순회 결과: 15 20
    ```

### 구현 힌트

- **NIL 노드:**  
  - 모든 리프는 실제로는 특별히 생성된 NIL 노드를 가리키며, 이 노드는 항상 검은색입니다.  
- **회전 및 균형 복구:**  
  - 삽입 및 삭제 후 발생할 수 있는 케이스들을 고려하여, 부모 노드, 삼촌(uncle) 노드의 색상, 그리고 조부모(grandparent) 노드의 관계를 분석해 균형을 복구하는 코드를 작성해야 합니다.
- **예외 처리:**  
  - 잘못된 입력이나, 존재하지 않는 노드를 삭제하는 경우 등에 대해 적절한 예외 처리를 수행합니다.
- **메모리 관리:**  
  - `new`와 `delete`를 통해 동적 메모리 할당과 해제를 관리하고, 메모리 누수가 없도록 합니다.

---

이 문제는 C++의 객체 지향 설계, 동적 메모리 관리, 그리고 복잡한 자료구조(자기 균형 이진 탐색 트리)의 구현에 대해 깊이 있는 학습을 할 수 있는 도전 과제입니다. 해결하면서 노드 간의 포인터 관리, 회전 연산, 색상 재조정 등 다양한 알고리즘적 사고가 요구됩니다.

도전해 보세요!

# 코멘트

코드 전반적으로 Red-Black Tree의 주요 알고리즘(회전, transplant, 삭제 후 균형 복구 등)을 잘 반영하여 객체 지향적으로 구현한 점이 인상적입니다. 특히, 트리 구조를 시각적으로 출력하는 printTreeHelper 함수와 명령어 기반 인터페이스를 통해 사용자가 직접 트리를 조작할 수 있도록 한 부분은 매우 유용해 보입니다.

다만, 몇 가지 개선하거나 보완하면 좋은 사항이 있습니다:

---

### 1. 좌회전(leftRotate) 함수의 오류

- **문제점:**  
  ```cpp
  else if (x = x->getParent()->getLeft()) { // x가 왼쪽 자식이었던 경우
      x->getParent()->setLeft(y);
  }
  ```
  위 구문에서 `=` 대입 연산자가 사용되었습니다. 이는 비교를 위한 `==` 연산자로 수정해야 합니다.

- **개선:**  
  ```cpp
  else if (x == x->getParent()->getLeft()) { // x가 왼쪽 자식이었던 경우
      x->getParent()->setLeft(y);
  }
  else { // x가 오른쪽 자식이었던 경우
      x->getParent()->setRight(y);
  }
  ```

---

### 2. 삽입 관련 함수 구현 미완성

- **문제점:**  
  `fixInsert(Node* z)` 함수가 선언되어 있으나 구현이 보이지 않습니다. Red-Black Tree의 삽입 후 균형 복구는 필수적인 부분이므로, 해당 함수를 구현해야 합니다.  
  또한, `insert(int key)` 메서드 역시 선언되어 있으나 구체적인 로직이 포함되어 있지 않은 것으로 보입니다.

- **개선 제안:**  
  - **fixInsert:** 삽입 후 부모, 삼촌, 조부모의 관계를 고려하여 색상 재조정과 회전 연산을 수행하는 로직을 구현하세요.
  - **insert:** 새로운 노드를 생성하고, 일반적인 이진 탐색 트리 삽입 과정을 거친 후 `fixInsert()`를 호출하는 방식으로 구현하면 좋겠습니다.

---

### 3. 트리 파괴(destroyTree) 함수 미구현

- **문제점:**  
  소멸자에서 `destroyTree(_root);`를 호출하고 있으나, 해당 함수의 구현이 보이지 않습니다.  
  모든 동적 할당된 노드를 재귀적으로 해제하여 메모리 누수를 방지해야 합니다.

- **개선:**  
  - 재귀 호출을 통해 현재 노드의 좌우 서브트리를 먼저 해제한 후, 현재 노드를 delete하는 방식으로 구현해 보세요.

---

### 4. 예외 처리 및 코드 안정성

- **예외 처리:**  
  메인 루프에서 try-catch 블록을 활용하여 예외를 잡으려는 시도가 보입니다.  
  삽입, 삭제, 검색 등에서 발생할 수 있는 예외 상황(예: 메모리 할당 실패, 잘못된 포인터 접근 등)에 대해 구체적인 예외 메시지를 남기거나, 예외를 던지는 방식으로 보완하면 좋겠습니다.

- **추가 검증:**  
  사용자 입력에 대한 검증은 비교적 잘 되어 있으나, 삽입이나 삭제 시에도 해당 키가 이미 존재하거나 존재하지 않는 경우에 대해 좀 더 구체적인 피드백을 제공하면 좋겠습니다.

---

### 5. 코드 스타일 및 주석

- **코드 주석:**  
  대부분의 함수에 주석이 달려 있어 이해하기 쉽지만, 복잡한 로직(특히 fixDelete 내부의 각 케이스 처리)에 대해 더 상세한 설명을 추가하면 다른 개발자나 미래의 자신이 코드를 유지보수하는 데 도움이 될 것입니다.

- **코드 구조:**  
  전반적으로 클래스와 함수가 모듈화되어 있어 매우 깔끔합니다. 다만, 전역 변수 대신 필요한 경우 적절히 캡슐화하는 것도 고려해볼 만합니다.

---

### 종합 평가

당신의 구현은 Red-Black Tree의 핵심 개념을 잘 반영한 매우 인상적인 코드입니다.  
- **강점:** 객체 지향 설계, 시각적 출력 기능, 명령어 기반 인터페이스 등이 잘 구현되어 있습니다.
- **보완점:** 좌회전 함수의 오류 수정, 삽입 및 트리 파괴 함수의 완성, 그리고 예외 처리 로직 보완 등이 필요합니다.

이러한 부분들을 개선하면 더욱 견고하고 완성도 높은 Red-Black Tree 구현체가 될 것입니다. 계속해서 도전적인 문제들을 해결하며 코드의 완성도를 높여 나가시길 바랍니다!