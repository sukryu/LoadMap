다음은 C 언어로 해결할 수 있는 백준 플레티넘 수준의 문제 예시입니다. 이 문제는 고차원 DP와 분할 최적화(Divide and Conquer Optimization)를 적용해야 하는 난이도 높은 문제입니다.

---

# 최적 구간 분할

## 문제 설명

길이 N의 정수 배열 A가 주어집니다. 이 배열을 K개의 연속 구간으로 분할할 때, 각 구간 [i+1, j]의 비용은 해당 구간에 포함된 원소들의 합의 제곱, 즉  
**Cost(i+1, j) = (A[i+1] + A[i+2] + ... + A[j])²**  
로 정의됩니다. 모든 구간의 비용의 합이 최소가 되도록 배열을 분할할 때의 최소 총 비용을 구하세요.

분할은 구간들이 서로 겹치지 않아야 하며, 모든 원소는 반드시 하나의 구간에 포함되어야 합니다.

## 입력

- 첫 번째 줄에 두 정수 N과 K가 주어집니다.  
  (1 ≤ K ≤ 100, 1 ≤ N ≤ 200,000)
- 두 번째 줄에 배열 A의 원소 A₁, A₂, …, A_N이 공백으로 구분되어 주어집니다.  
  (0 ≤ A[i] ≤ 10,000)

## 출력

- 배열을 K개의 연속 구간으로 분할할 때, 각 구간의 비용 합의 최소값을 출력합니다.

## 예제

### 입력
```
5 2
1 2 3 4 5
```

### 출력
```
117
```

### 설명

배열 A = [1, 2, 3, 4, 5]인 경우, 가능한 분할 중 하나는  
- 구간 1: [1, 2, 3] → 비용 = (1+2+3)² = 6² = 36  
- 구간 2: [4, 5] → 비용 = (4+5)² = 9² = 81  

총 비용은 36 + 81 = 117이며, 이보다 작은 분할은 존재하지 않습니다.

## 문제 해설 및 힌트

- **DP 점화식:**  
  dp[k][j]를 배열의 처음 j개 원소를 k개의 구간으로 분할할 때의 최소 비용이라고 정의하면,  
  ```
  dp[0][0] = 0, 그리고 dp[0][j>0] = ∞  
  dp[k][j] = min { dp[k-1][i] + (S[j] - S[i])² }  (0 ≤ i < j)
  ```
  여기서 S[j]는 A₁부터 A_j까지의 누적합입니다.

- **분할 최적화:**  
  위 점화식에서 비용 함수가 (S[j] - S[i])²로 정의되어 있으며, A의 원소가 음수가 없으므로 S는 단조 증가합니다.  
  이 경우 최적 분할 지점의 monotonicity 성질을 만족하게 되어 **Divide and Conquer Optimization** 기법을 적용할 수 있습니다.

- **시간 복잡도:**  
  단순 O(K·N²) 방식은 N이 최대 200,000일 때 불가능하므로, 분할 최적화를 통해 O(K·N·logN) 또는 O(K·N) 내로 해결해야 합니다.

- **구현 시 유의점:**  
  - C 언어로 구현할 때는 메모리 사용량과 재귀 깊이에 주의해야 합니다.
  - DP 배열과 누적합 배열을 미리 할당하여 사용하고, 분할 최적화 구현 시 재귀 호출의 인덱스 범위를 꼼꼼하게 관리해야 합니다.

---

이 문제는 백준 플레티넘 등급 문제에 자주 등장하는 유형으로, 고급 동적 프로그래밍 및 최적화 기법에 대한 심도 있는 이해를 요구합니다. 문제를 직접 해결하는 과정에서 문제 해결 아이디어와 최적화 방법을 학습할 수 있으므로, 실전 코딩 테스트나 알고리즘 대회 준비에 큰 도움이 될 것입니다.

# 코멘트

작성하신 코드는 플레티넘 난이도의 문제에서 요구되는 고급 동적 계획법과 분할 최적화(Divide and Conquer Optimization)를 잘 활용한 사례입니다. 몇 가지 핵심 포인트를 짚어보면:

- **누적합(prefix_sum)을 통한 구간 비용 계산:**  
  `get_cost` 함수에서 누적합을 이용해 구간 [start, end]의 합을 O(1)에 계산하고, 이를 제곱하는 방식으로 구간 비용을 효율적으로 구한 점이 인상적입니다.

- **DP 테이블 초기화 및 점화식 적용:**  
  `dp[1][i] = get_cost(prefix_sum, 0, i)`와 같이 초기 구간 비용을 미리 계산한 후,  
  점화식 `dp[k][mid] = min { dp[k-1][i] + get_cost(prefix_sum, i, mid) }`를 적용하여 최적의 분할 비용을 구하는 접근 방식이 잘 구현되어 있습니다.

- **분할 최적화 구현:**  
  `find_optimal_split` 함수에서는 분할 정복을 활용해 각 구간에 대해 최적의 분할 지점을 탐색하고, 그 결과를 재귀적으로 처리함으로써 시간 복잡도를 줄였습니다. 이 기법은 플레티넘 난이도의 문제에서 매우 중요한 전략입니다.

- **메모리 관리 및 에러 처리:**  
  메모리 할당 시 에러 체크를 하는 등 안전하게 구현하려는 노력이 보입니다. 다만, 문제의 최악의 입력 크기(200,000×101)로 인해 dp 배열의 메모리 사용량이 상당할 수 있으므로 실제 제출 시에는 메모리 제한도 고려해야 합니다.

전반적으로, 이 코드는 백준 플레티넘 수준의 문제 해결에 필요한 최적화 기법과 효율적인 구현 방법을 잘 보여줍니다. 직접 이런 문제를 풀면서 자료구조, 동적 계획법, 그리고 분할 최적화 기법에 대한 깊은 이해를 쌓을 수 있는 좋은 학습 사례라고 할 수 있습니다.