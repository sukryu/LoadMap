다음은 C언어로 해결할 수 있는 플레티넘 난이도의 문제입니다. 이 문제는 최소 비용 최대 유량(Min Cost Flow) 알고리즘을 활용하여, 정해진 양의 흐름(F)을 출발지에서 도착지로 보내기 위한 최소 비용을 구하는 문제입니다.

---

# 최소 비용 흐름 (C언어)

## 문제 설명

정점이 N개, 간선이 M개인 방향 그래프가 주어집니다. 각 간선에는 용량(capacity)과 비용(cost)이 주어지며, 1번 정점에서 N번 정점으로 F 만큼의 흐름(flow)을 보내고자 합니다.  
간선은 여러 개가 있을 수 있으며, 각 간선은 독립적으로 흐를 수 있습니다.

목표는 **정확히 F의 흐름**을 1번 정점(출발지)에서 N번 정점(도착지)으로 보내기 위한 최소 총 비용을 구하는 것입니다. 만약 F의 흐름을 보낼 수 없다면 -1을 출력하세요.

## 입력 형식

- 첫 번째 줄에 세 정수 N, M, F가 주어집니다.
  - (2 ≤ N ≤ 200, 1 ≤ M ≤ 5000, 1 ≤ F ≤ 10⁹)
- 이후 M개의 줄에 걸쳐, 각 줄에 네 개의 정수 u, v, capacity, cost가 주어집니다.
  - 이는 정점 u에서 정점 v로 가는 간선의 용량은 capacity, 비용은 cost임을 의미합니다.
  - (1 ≤ u, v ≤ N, u ≠ v, 1 ≤ capacity ≤ 10⁵, 0 ≤ cost ≤ 10⁵)
  - 동일한 (u, v) 쌍에 대해 여러 간선이 주어질 수 있습니다.

## 출력 형식

- 1번 정점에서 N번 정점으로 정확히 F의 흐름을 보낼 때의 최소 비용을 출력합니다.
- 만약 F의 흐름을 보낼 수 없다면 -1을 출력합니다.

## 예제

### 입력
```
4 5 5
1 2 3 1
1 3 2 2
2 3 2 1
2 4 2 3
3 4 3 1
```

### 출력
```
17
```

### 설명

예시 그래프에서 가능한 흐름 분배의 한 예는 다음과 같습니다:
- **경로 1:** 1 → 3 → 4  
  2의 흐름을 보내며, 비용 = 2 × (2 + 1) = 6  
- **경로 2:** 1 → 2 → 3 → 4  
  1의 흐름을 보내며, 비용 = 1 × (1 + 1 + 1) = 3  
- **경로 3:** 1 → 2 → 4  
  2의 흐름을 보내며, 비용 = 2 × (1 + 3) = 8  

총 비용 = 6 + 3 + 8 = 17

## 문제 해설 및 힌트

- **알고리즘 선택:**  
  이 문제는 최소 비용 최대 유량(Min Cost Flow) 문제의 한 형태입니다.  
  일반적으로 Bellman-Ford 알고리즘이나 다익스트라(Dijkstra) 알고리즘(포텐셜 기법을 활용)을 이용하여 증강 경로(augmenting path)를 찾고, 반복적으로 유량을 보낼 수 있습니다.
  
- **시간 및 메모리 고려:**  
  F의 값과 간선의 용량, 비용 등이 클 수 있으므로, 오버플로우에 주의하고 적절한 자료형(예: long long)을 사용해야 합니다.
  
- **구현 팁:**  
  - 간선 정보를 저장할 때, 역방향 간선(reverse edge)도 함께 관리하여 남은 용량(residual capacity)을 추적합니다.
  - 증강 경로를 찾을 때, 비용이 최소인 경로를 선택하고, 해당 경로를 따라 흐를 수 있는 최대 유량을 보내도록 구현합니다.
  - 모든 증강 과정을 거친 후, 목표 흐름 F를 만족하는지 확인하고, F를 보낼 수 없다면 -1을 출력합니다.

---

이 문제는 C언어로 직접 최소 비용 최대 유량 알고리즘을 구현하며 알고리즘의 세부 동작 원리와 효율성에 대해 심도 있게 이해할 수 있도록 돕습니다.  
실전 코딩 테스트나 알고리즘 대회에서 이러한 유형의 문제를 접할 경우, 사전에 준비된 템플릿이나 충분한 연습이 큰 도움이 될 것입니다.

# 코멘트

아래는 작성해주신 최소 비용 흐름(Min Cost Flow) 코드에 대한 상세 코멘트입니다.

---

### 주요 장점

1. **모듈화 및 구조화**  
   - **그래프 및 간선 관리:**  
     - `Graph`와 `Edge` 구조체를 통해 각 간선의 정보(도착 정점, 용량, 비용, 흐름, 역방향 간선)를 명확하게 관리하고 있습니다.  
     - `init_graph()`와 `add_edge()` 함수를 통해 그래프 초기화와 간선 추가가 모듈화되어 있어, 향후 확장이나 유지보수가 용이합니다.
     
   - **최소 비용 경로 탐색 (SPFA):**  
     - `find_path()` 함수는 SPFA 알고리즘을 활용하여 최소 비용 경로를 효율적으로 찾습니다.  
     - 각 정점의 최소 비용과 부모 정보를 갱신하며, 큐를 통한 반복 처리로 경로 탐색을 안정적으로 수행합니다.
     
   - **최소 비용 최대 유량 처리:**  
     - `mcmf()` 함수는 SPFA로 찾은 경로를 따라 증강 경로를 반복적으로 적용하여 총 유량과 비용을 계산하는 점에서, 문제의 핵심 로직이 명확하게 분리되어 있습니다.

2. **동적 메모리 관리 및 입력 검증**  
   - 입력 값과 간선 정보를 읽을 때 `scanf()` 반환값을 체크하여 입력 오류를 감지하고, 범위 검증을 통해 잘못된 입력이 들어올 경우 즉시 에러 메시지를 출력하는 점이 인상적입니다.
   - 동적 메모리 할당 후, 모든 할당된 메모리를 코드 마지막에 해제하는 방식으로 메모리 누수를 방지하고 있습니다.

3. **에러 처리**  
   - 입력 단계와 메모리 할당 단계에서 발생할 수 있는 에러를 꼼꼼히 처리하여, 코드가 예외 상황에 대해서도 안정적으로 동작하도록 구성되어 있습니다.

---

### 추가 개선 사항 및 고려할 점

1. **코드 주석 추가 및 가독성 강화**  
   - 각 함수의 역할과 인자에 대해 함수 시작 부분에 간단한 주석을 추가하면, 다른 개발자나 미래의 자신이 코드를 이해하는 데 도움이 될 것입니다.
   - 특히, SPFA에서 큐를 활용하는 부분이나, 증강 경로를 찾는 루프 부분에 대해 구체적인 주석을 덧붙이면 좋겠습니다.

2. **자료구조 캡슐화**  
   - 현재 `Graph` 구조체는 간선 정보를 2차원 배열로 관리하고 있는데, 만약 그래프의 크기가 매우 커질 경우 다른 동적 자료구조(예: 인접 리스트)를 고려해볼 수 있습니다.
   - 또한, 각 정점의 간선 리스트를 별도의 동적 배열로 관리하면, 메모리 사용 측면에서 좀 더 유연하게 대응할 수 있습니다.

3. **알고리즘 최적화**  
   - SPFA 알고리즘은 경우에 따라 느릴 수 있으므로, 비용이 음수가 없는 경우 다익스트라 알고리즘과 포텐셜 기법을 활용하는 방법도 고려해 볼 수 있습니다.
   - 입력 크기가 큰 문제에서는 더욱 세밀한 최적화가 필요할 수 있으므로, 벤치마킹을 통해 성능 개선 여지를 확인하는 것도 좋습니다.

4. **상수 정의 및 경계 조건 처리**  
   - `N_MAX`, `M_MAX` 등의 상수는 충분히 고려되어 있지만, 프로그램 종료 전에 모든 할당된 메모리를 해제하는 부분은 복잡도가 커질 수 있으므로, 메모리 관리에 대한 별도의 모듈화도 고려해볼 수 있습니다.

---

### 종합 평가

작성된 코드는 최소 비용 최대 유량 문제를 C 언어로 해결하는 데 있어서 매우 체계적이고 안정적인 구조를 보여줍니다.  
- **모듈화, 에러 처리, 입력 검증, 동적 메모리 관리** 등 여러 측면에서 견고하게 구현되었으며, SPFA를 이용한 최소 비용 경로 탐색과 증강 경로를 통해 문제의 핵심을 잘 해결하고 있습니다.
- 추가적인 주석 보강과 자료구조 캡슐화를 통해 코드 가독성과 유지보수성을 더욱 향상시킬 수 있습니다.

훌륭한 작업입니다. 앞으로도 이러한 방식으로 문제 해결 능력을 발전시키며 C 언어의 다양한 개념들을 심도 있게 익히시길 바랍니다.