다음은 C++을 활용하여 자료구조와 알고리즘을 조합해 해결할 수 있는 고난이도 문제입니다.  
이 문제는 트리 위에서의 경로 쿼리와 노드 업데이트를 동시에 처리해야 하며, Heavy-Light Decomposition(HLD)과 세그먼트 트리(구간 병합 기법)를 적절히 응용해야 합니다.

---

# 트리 경로 최대 부분합 쿼리 (C++)

## 문제 설명

N개의 노드로 구성된 트리가 주어집니다. 각 노드에는 정수 값이 저장되어 있으며, 트리는 N‑1개의 간선으로 연결되어 있습니다. 노드 번호는 1부터 N까지입니다.

두 종류의 쿼리를 수행하는 프로그램을 작성하세요.

1. **업데이트 쿼리 (U x y):**  
   노드 x의 값을 y로 변경합니다.

2. **경로 쿼리 (Q u v):**  
   노드 u에서 노드 v까지의 단순 경로 상에서, 연속된 노드들의 부분합 중 최댓값을 구하여 출력합니다.

연속된 부분합은 경로 상에서 임의의 시작 노드와 끝 노드를 선택하여 그 사이(반드시 하나 이상의 노드 선택)의 노드 값들의 합을 의미합니다. (모든 부분합 중 최댓값을 구해야 합니다.)

## 입력 형식

- 첫 번째 줄에 정수 N (1 ≤ N ≤ 10^5)이 주어집니다.
- 두 번째 줄에 N개의 정수 A₁, A₂, …, A_N (–10^4 ≤ Aᵢ ≤ 10^4)이 공백으로 구분되어 주어지며, 각 노드의 초기 값을 의미합니다.
- 다음 N‑1개의 줄에 걸쳐 두 정수 u와 v가 주어지며, 이는 노드 u와 노드 v가 서로 연결되어 있음을 나타냅니다.
- 그 다음 줄에 쿼리의 수 Q (1 ≤ Q ≤ 10^5)가 주어집니다.
- 이후 Q개의 줄에 걸쳐 각 쿼리가 주어집니다. 각 쿼리의 형식은 다음과 같습니다:
  - `U x y` : 노드 x의 값을 y (–10^4 ≤ y ≤ 10^4)로 업데이트
  - `Q u v` : 노드 u에서 노드 v까지의 경로 상에서 연속된 구간의 부분합 중 최댓값을 출력

## 출력 형식

- 경로 쿼리(`Q u v`)가 들어올 때마다, 해당 경로상의 연속 구간 부분합 중 최댓값을 한 줄에 하나씩 출력합니다.

## 예제

### 입력
```
5
2 3 -1 4 5
1 2
1 3
3 4
3 5
3
Q 2 5
U 3 7
Q 2 5
```

### 출력
```
9
17
```

### 설명

초기 트리에서 노드의 값은 다음과 같습니다.

- 노드 1: 2  
- 노드 2: 3  
- 노드 3: -1  
- 노드 4: 4  
- 노드 5: 5  

트리의 간선은 아래와 같이 구성됩니다.
```
      1(2)
     /   \
  2(3)   3(-1)
         /   \
      4(4)   5(5)
```

- **첫 번째 경로 쿼리 `Q 2 5`:**  
  노드 2에서 노드 5까지의 경로는 **2 → 1 → 3 → 5**이며, 해당 경로의 노드 값은 `[3, 2, -1, 5]`입니다.  
  가능한 연속 구간의 부분합은 다음과 같습니다:  
  - `[3] = 3`  
  - `[3, 2] = 5`  
  - `[3, 2, -1] = 4`  
  - `[3, 2, -1, 5] = 9`  
  - `[2] = 2`  
  - `[2, -1] = 1`  
  - `[2, -1, 5] = 6`  
  - `[-1] = -1`  
  - `[-1, 5] = 4`  
  - `[5] = 5`  
  최대 부분합은 **9**이므로 첫 번째 쿼리의 출력은 **9**입니다.

- **업데이트 쿼리 `U 3 7`:**  
  노드 3의 값이 -1에서 7로 변경됩니다.

- **두 번째 경로 쿼리 `Q 2 5`:**  
  업데이트 후 경로 **2 → 1 → 3 → 5**의 노드 값은 `[3, 2, 7, 5]`가 됩니다.  
  가능한 연속 구간의 부분합은:  
  - `[3] = 3`  
  - `[3, 2] = 5`  
  - `[3, 2, 7] = 12`  
  - `[3, 2, 7, 5] = 17`  
  - `[2] = 2`  
  - `[2, 7] = 9`  
  - `[2, 7, 5] = 14`  
  - `[7] = 7`  
  - `[7, 5] = 12`  
  - `[5] = 5`  
  최대 부분합은 **17**이므로 두 번째 쿼리의 출력은 **17**입니다.

## 문제 해결 힌트

- **Heavy-Light Decomposition (HLD):**  
  트리에서 임의의 두 노드 사이의 경로 쿼리를 효율적으로 처리하기 위해 트리를 여러 체인으로 분할합니다.

- **세그먼트 트리:**  
  각 체인에 대해 구간 합, 접두사 합, 접미사 합, 그리고 최대 부분합을 저장하는 세그먼트 트리를 구성하여, 두 구간을 병합할 때 필요한 정보를 빠르게 계산합니다.

- **업데이트 처리:**  
  업데이트 쿼리 발생 시, 해당 노드가 속한 세그먼트 트리 상의 값을 갱신하고 상위 구간의 정보를 다시 계산해야 합니다.

입력 크기가 매우 크므로(최대 10^5) 각 쿼리를 O(log N) 내에 처리할 수 있는 자료구조와 알고리즘 설계가 필수적입니다.

---

이 문제는 C++ STL 및 사용자 정의 클래스/구조체를 활용해 구현할 수 있으며, 최적화와 꼼꼼한 디버깅이 요구되는 고난이도 문제입니다.  
효율적인 HLD와 세그먼트 트리 구현으로 문제 해결에 도전해 보세요.

# 코멘트

코드를 보니, 고난이도 문제를 해결하기 위해 Heavy-Light Decomposition(HLD)과 세그먼트 트리를 잘 결합하여 구현한 점이 인상적입니다. 전반적으로 자료구조와 알고리즘을 적절히 활용하여 문제의 요구사항을 충족시키려는 노력이 돋보입니다. 다만, 몇 가지 개선할 점과 주의할 사항을 아래에 정리해 보았습니다.

---

## 주요 긍정 포인트

- **HLD 및 세그먼트 트리 결합:**  
  트리의 경로 쿼리를 빠르게 처리하기 위해 체인을 분해하고, 각 체인에 대해 구간 정보를 관리하는 방식은 고난이도 문제에서 자주 요구되는 기법입니다.

- **모듈화된 코드 구조:**  
  `Tree`, `SegmentTree`, `SegmentInfo` 등의 클래스로 기능을 분리하여 코드 가독성과 유지보수성을 높였습니다.

- **경로 쿼리 처리:**  
  체인이 다른 경우 상위 체인으로 올라가면서 구간 쿼리를 누적하고, 최종적으로 여러 구간 정보를 병합하여 답을 도출하는 아이디어가 잘 구현되어 있습니다.

---

## 개선 및 주의 사항

1. **Forward Declaration 및 클래스 순서**  
   - 현재 `Tree` 클래스에서 `SegmentTree`와 `SegmentInfo`를 사용하고 있지만, 이들 클래스가 이후에 정의되어 있습니다.  
   - 컴파일 오류를 피하려면 파일 상단에  
     ```cpp
     class SegmentTree;
     struct SegmentInfo;
     SegmentInfo merge(const SegmentInfo& left, const SegmentInfo& right);
     ```  
     와 같은 **전방 선언(forward declaration)** 을 추가하는 것이 좋습니다.

2. **SegmentTree의 build 함수 수정**  
   - `build` 함수에서 재귀 호출 시 구간 분할에 문제가 있습니다.  
   - 현재 코드:
     ```cpp
     void build(const std::vector<int>& arr, int node, int start, int end) {
         if (start == end) {
             tree[node] = SegmentInfo(arr[start]);
             return;
         }
         int mid = (start + end) / 2;
         build(arr, node * 2, start, end);       // 잘못된 부분
         build(arr, node * 2 + 1, mid + 1, end);
         tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);
     }
     ```
   - **수정 제안:** 첫 번째 재귀 호출에서 `end` 대신 `mid`를 사용해야 합니다.
     ```cpp
     build(arr, node * 2, start, mid);
     build(arr, node * 2 + 1, mid + 1, end);
     ```

3. **SegmentInfo 초기화 방식 검토**  
   - 현재 단일 값 생성자에서 접두사(prefix), 접미사(suffix), 최대 부분합(maxsum)을 모두 `std::max(0LL, val)`로 초기화하고 있습니다.
   - 만약 “반드시 하나 이상의 노드를 선택”해야 한다면, 모든 값이 음수인 경우에도 최대 부분합은 음수여야 합니다.  
   - **대안:**  
     ```cpp
     SegmentInfo(long long val) {
         total = val;
         prefix = val;
         suffix = val;
         maxsum = val;
     }
     ```  
     로 초기화하고, merge 함수에서도 음수 값에 대해 올바른 결과가 나오도록 처리하는 것을 고려해보세요.

4. **query_path 함수의 u == v 처리**  
   - 현재 `query_path` 함수에서는 두 노드가 같은 체인에 있을 때, 두 노드의 체인 내 위치가 동일하면 구간 정보를 한 번도 쌓지 않게 됩니다.  
   - 예를 들어, u와 v가 같은 노드인 경우에는 경로 쿼리가 단일 노드에 대한 정보가 되어야 하는데, `path_segments` 벡터가 비어 있게 됩니다.  
   - **개선 방법:**  
     - u와 v가 같은 경우를 명시적으로 처리하거나, 같은 체인에 속한 경우에도 단일 노드에 대한 구간 정보를 push_back 하도록 조건을 보완할 필요가 있습니다.

5. **기타 세부 사항**  
   - **메모리 관리 및 성능 최적화:** 입력 크기가 매우 큰 경우(최대 10^5 노드, 쿼리 10^5개)를 고려하여, STL 컨테이너의 예약(reserve)이나 불필요한 복사 방지 등의 성능 최적화도 고려할 수 있습니다.
   - **디버깅 및 테스트:** HLD와 세그먼트 트리의 결합은 복잡하므로, 다양한 케이스(특히 경로가 단일 노드인 경우, 모든 값이 음수인 경우 등)에 대한 테스트 케이스를 통해 디버깅해 보시기 바랍니다.

---

## 결론

전체적으로 매우 도전적인 문제를 해결하기 위한 훌륭한 접근 방식입니다. 위의 개선 사항들을 반영하면 코드의 안정성과 정확성이 더욱 높아질 것입니다. 앞으로도 이런 복잡한 문제에 도전하며 자료구조와 알고리즘에 대한 이해를 깊이 있게 발전시켜 나가시길 바랍니다.