# 실시간 채팅 서버 프로젝트

## 프로젝트 개요
이 프로젝트는 OTP와 Elixir의 강력한 동시성, 분산 처리, 내결함성 기능을 활용하여 **실시간 채팅 서버**를 구현한 예제입니다.  
본 시스템은 다수의 클라이언트가 실시간으로 메시지를 주고받을 수 있도록 설계되었으며, OTP의 GenServer, Supervisor, 분산 노드 통신 등의 핵심 개념을 실전에서 적용하는 방법을 보여줍니다.

---

## 주요 기능
- **실시간 메시지 브로드캐스트:**  
  클라이언트가 메시지를 전송하면, 서버는 이를 연결된 모든 클라이언트에게 즉시 전달합니다.
  
- **개별 클라이언트 관리:**  
  각 클라이언트와의 연결을 독립적인 프로세스로 관리하여, 하나의 연결 문제가 전체 시스템에 영향을 미치지 않도록 설계하였습니다.
  
- **오류 복구 및 자동 재시작:**  
  Supervisor가 클라이언트 핸들러나 서버 프로세스의 실패를 감시하고 자동으로 재시작함으로써, 시스템의 안정성을 보장합니다.
  
- **분산 통신 지원:**  
  여러 노드에 걸친 분산 환경에서도 안정적인 채팅 서비스를 제공할 수 있도록, Erlang/OTP의 분산 기능을 활용합니다.

---

## 시스템 아키텍처

### 프로세스 구조
- **채팅 서버 프로세스:**  
  - 클라이언트로부터 메시지를 수신하고, 이를 전체 브로드캐스트하는 역할을 담당합니다.
  - GenServer를 사용하여 상태(연결된 클라이언트 목록 등)를 관리합니다.
  
- **클라이언트 핸들러 프로세스:**  
  - 각 클라이언트의 연결 및 개별 메시지 송수신을 처리합니다.
  - 개별 프로세스로 동작하여, 장애가 발생해도 다른 클라이언트에 영향을 주지 않습니다.
  
- **Supervisor 트리:**  
  - 채팅 서버와 클라이언트 핸들러 프로세스의 생명주기를 관리합니다.
  - 자식 프로세스가 예기치 않게 종료될 경우, 자동으로 재시작하여 시스템의 내결함성을 확보합니다.

### OTP 구성 요소 활용
- **GenServer:**  
  채팅 서버와 클라이언트 핸들러의 상태 관리 및 메시지 처리 로직을 캡슐화하여, 개발자가 반복되는 코드를 줄이고 안정적인 서비스를 구현할 수 있도록 도와줍니다.
  
- **Supervisor:**  
  프로세스 오류 발생 시, 정의된 재시작 전략(예: one_for_one)을 통해 프로세스를 자동 복구합니다.
  
- **분산 노드 통신:**  
  노드 간 메시지 전달 기능을 사용하여, 여러 서버 인스턴스를 클러스터로 구성할 수 있으며, 확장성과 고가용성을 확보합니다.

---

## 설치 및 실행 방법

### 요구 사항
- Erlang/OTP 24 이상
- Elixir 1.12 이상
- Linux, macOS 또는 Windows 운영체제
- 터미널 또는 명령 프롬프트 환경

### 설치 방법

1. **Erlang/OTP 및 Elixir 설치**
   - **Ubuntu/Debian:**
     ```bash
     sudo apt-get update
     sudo apt-get install erlang elixir
     ```
   - **macOS (Homebrew):**
     ```bash
     brew install erlang elixir
     ```
   - **Windows:**
     - Erlang 및 Elixir 설치 프로그램을 [Elixir 공식 웹사이트](https://elixir-lang.org/install.html)에서 다운로드하거나, Chocolatey를 통해 설치:
       ```bash
       choco install erlang
       choco install elixir
       ```

2. **프로젝트 클론**
   ```bash
   git clone https://github.com/your-repo/real-time-chat-server.git
   cd real-time-chat-server
   ```

3. **컴파일**
   - `src` 디렉토리에 있는 모든 Elixir 소스 파일들을 컴파일하여 `ebin` 디렉토리에 출력합니다.
     ```bash
     mix compile
     ```

### 실행 방법

1. **Erlang/Elixir 셸 시작**
   ```bash
   iex -S mix
   ```

2. **채팅 서버 시작**
   - Elixir 셸에서 채팅 서버를 시작합니다.
     ```elixir
     RealTimeChatServer.start()
     ```
   - 서버는 클라이언트 연결을 대기하며, 연결된 클라이언트로 메시지를 브로드캐스트할 준비를 합니다.

3. **클라이언트 연결**
   - 별도의 터미널에서 IEx 셸을 열고, 클라이언트 모듈을 실행하여 서버에 접속합니다.
     ```elixir
     ChatClient.start()
     ```
   - 클라이언트는 서버와의 연결을 통해 실시간 메시지 송수신 기능을 사용할 수 있습니다.

4. **메시지 전송 및 수신**
   - 클라이언트 혹은 서버에서 메시지를 전송하면, 해당 메시지가 연결된 모든 클라이언트에게 전달되고, 실시간으로 결과를 확인할 수 있습니다.

---

## 코드 구조

- **src/real_time_chat_server.ex:**  
  채팅 서버의 핵심 로직을 포함하는 모듈입니다. 클라이언트 연결 관리, 메시지 수신 및 브로드캐스트 기능이 구현되어 있습니다.
  
- **src/chat_client.ex:**  
  클라이언트와의 연결 및 메시지 송수신을 처리하는 모듈입니다. 서버와의 상호작용을 담당합니다.
  
- **src/supervisor_chat.ex:**  
  Supervisor 트리 구성을 통해, 채팅 서버와 클라이언트 핸들러 프로세스의 생명주기를 관리합니다.
  
- **README.md:**  
  이 문서는 프로젝트 개요, 설치 및 실행 방법, 시스템 아키텍처 등을 상세히 설명합니다.

---

## 예제 사용 시나리오

1. **서버 시작:**  
   채팅 서버를 실행하여 클라이언트 연결을 대기합니다.
   
2. **클라이언트 접속:**  
   여러 클라이언트가 각자의 터미널에서 `ChatClient.start()` 명령어로 서버에 접속합니다.
   
3. **메시지 브로드캐스트:**  
   한 클라이언트에서 메시지를 전송하면, 서버는 해당 메시지를 받아 모든 연결된 클라이언트에게 전달합니다.
   
4. **오류 복구:**  
   클라이언트 혹은 서버 프로세스가 예기치 않게 종료되더라도, Supervisor가 자동으로 재시작하여 시스템의 안정성을 유지합니다.

---

## 개발 및 확장 계획

- **실시간 분산 채팅:**  
  여러 노드를 연결하여 클러스터 환경에서 채팅 서버를 운영, 고가용성과 확장성을 보장합니다.
  
- **웹 인터페이스 지원:**  
  웹소켓 기반의 웹 클라이언트를 도입하여, 브라우저를 통한 채팅 기능을 구현할 계획입니다.
  
- **보안 강화:**  
  클라이언트 인증, 메시지 암호화 등 보안 기능을 추가하여, 안전한 채팅 서비스를 제공합니다.
  
- **추가 기능:**  
  사용자 상태 표시, 그룹 채팅, 파일 전송 등 부가 기능 확장을 고려하고 있습니다.

---

## 참고 자료

- [Programming Erlang - Joe Armstrong](https://pragprog.com/titles/jjoe/programming-erlang/)
- [Learn You Some Erlang for Great Good! - Fred Hebert](http://learnyousomeerlang.com/)
- [Elixir 공식 문서](https://hexdocs.pm/elixir/)
- [Phoenix 프레임워크](https://www.phoenixframework.org/) – 실시간 웹 애플리케이션 개발 관련

---

이 프로젝트는 OTP와 Elixir를 활용한 실시간 시스템 구축에 관한 이해를 높이고, 분산 시스템, 내결함성, 실시간 메시지 처리를 실전에서 체험할 수 있도록 설계되었습니다.  
의견이나 개선 사항은 [이슈 트래커](https://github.com/your-repo/real-time-chat-server/issues)를 통해 공유해 주시기 바랍니다.

Happy coding!