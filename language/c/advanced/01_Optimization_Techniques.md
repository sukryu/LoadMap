# 01. Optimization Techniques

## 1. 최적화의 개념

### 최적화란?
최적화는 프로그램의 실행 속도와 메모리 사용량을 개선하여 성능을 극대화하는 과정입니다. 특히 C 언어는 하드웨어와 밀접하게 연관된 저수준 작업을 수행할 수 있어 최적화의 효과가 매우 큽니다.

### 최적화의 목표
1. **속도 향상**: 실행 시간을 줄이고, 응답성을 개선합니다.
2. **메모리 효율화**: 메모리 사용량을 줄여 자원을 효과적으로 활용합니다.
3. **전력 소모 감소**: 임베디드 시스템과 같은 환경에서 중요.

---

## 2. 컴파일러 최적화

### 컴파일러의 역할
컴파일러는 소스 코드를 분석하고 최적화 기법을 적용하여 더 효율적인 기계어 코드를 생성합니다. 이를 위해 컴파일러 최적화 옵션을 사용하는 것이 중요합니다.

### GCC 최적화 옵션
- `-O0`: 최적화를 수행하지 않음 (기본값).
- `-O1`: 기본적인 최적화 수행.
- `-O2`: 실행 속도를 중점으로 한 추가 최적화.
- `-O3`: CPU 사용량과 실행 속도를 극대화하는 고급 최적화.
- `-Os`: 실행 속도를 유지하면서 바이너리 크기를 최소화.

#### 예제: 최적화 옵션 사용
```bash
gcc -O2 -o program program.c
```

### Clang 최적화 옵션
GCC와 비슷하지만, Clang은 자체적인 최적화 패스를 통해 더욱 세부적인 설정이 가능합니다.

#### 예제: Clang에서의 최적화
```bash
clang -O3 -o program program.c
```

---

## 3. 루프 최적화

### 루프 언롤링 (Loop Unrolling)
루프 반복 횟수를 줄이기 위해 여러 반복을 한 번에 처리하는 방법입니다. 이는 분기(branch)와 반복문의 오버헤드를 줄여 성능을 향상시킵니다.

#### 예제: 루프 언롤링 전후 비교
```c
// 일반 루프
for (int i = 0; i < 100; i++) {
    arr[i] = i;
}

// 루프 언롤링
for (int i = 0; i < 100; i += 4) {
    arr[i] = i;
    arr[i + 1] = i + 1;
    arr[i + 2] = i + 2;
    arr[i + 3] = i + 3;
}
```

### 루프 병합 (Loop Fusion)
연속적으로 실행되는 두 개 이상의 루프를 하나로 합쳐 오버헤드를 줄이는 기법입니다.

#### 예제: 루프 병합
```c
// 루프 병합 전
for (int i = 0; i < n; i++) {
    a[i] = b[i] + c[i];
}
for (int i = 0; i < n; i++) {
    d[i] = a[i] * 2;
}

// 루프 병합 후
for (int i = 0; i < n; i++) {
    a[i] = b[i] + c[i];
    d[i] = a[i] * 2;
}
```

---

## 4. 메모리 최적화

### 메모리 정렬 (Memory Alignment)
CPU는 데이터가 메모리에서 정렬(aligned)되어 있을 때 더 빠르게 처리할 수 있습니다. 구조체 패딩(padding)과 정렬을 이해하고 활용하는 것이 중요합니다.

#### 예제: 구조체 정렬
```c
#include <stdio.h>
#include <stddef.h>

struct Aligned {
    char a;   // 1 byte
    int b;    // 4 bytes
};

int main() {
    printf("Size of struct: %lu\n", sizeof(struct Aligned));  // 8 bytes (패딩 포함)
    return 0;
}
```

### 캐시 친화적 프로그래밍
캐시 메모리는 프로그램 성능에 큰 영향을 미칩니다. 데이터의 **공간적 지역성**과 **시간적 지역성**을 활용하여 성능을 최적화할 수 있습니다.

#### 예제: 캐시 효율적 데이터 접근
```c
// 캐시 친화적 방식
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = i + j;
    }
}

// 캐시 비효율적 방식
for (int j = 0; j < cols; j++) {
    for (int i = 0; i < rows; i++) {
        matrix[i][j] = i + j;
    }
}
```

---

## 5. 매크로와 인라인 함수

### 매크로의 장단점
- **장점**: 반복적인 코드의 중복 제거.
- **단점**: 디버깅이 어렵고, 코드가 복잡해질 수 있음.

#### 예제: 매크로 활용
```c
#define SQUARE(x) ((x) * (x))

int main() {
    int num = 5;
    printf("Square: %d\n", SQUARE(num));
    return 0;
}
```

### 인라인 함수
매크로의 단점을 보완하면서도 성능을 유지할 수 있는 기법입니다.

#### 예제: 인라인 함수
```c
inline int square(int x) {
    return x * x;
}

int main() {
    int num = 5;
    printf("Square: %d\n", square(num));
    return 0;
}
```

---

## 6. 성능 프로파일링

### 프로파일링 도구
- **Valgrind**: 메모리 누수와 성능 분석.
- **gprof**: 함수별 실행 시간과 호출 관계 분석.
- **perf**: Linux 환경에서 성능 병목점 파악.

#### 예제: gprof 사용
```bash
gcc -pg -o program program.c
./program
gprof program gmon.out > analysis.txt
```

---

## 7. 실습: 최적화된 합산 프로그램

### 문제 정의
1부터 N까지의 합을 계산하는 프로그램을 최적화합니다.

#### 기본 코드
```c
int sum = 0;
for (int i = 1; i <= n; i++) {
    sum += i;
}
```

#### 최적화된 코드
```c
int sum = n * (n + 1) / 2;  // 수학 공식을 활용한 최적화
```

---

최적화는 성능을 높이고 자원 활용을 극대화하는 중요한 기술입니다. 다양한 기법을 조합하여 효과적인 코드를 작성해보세요!

