# Memory and Performance in C

C 언어는 효율적인 메모리 관리와 높은 성능을 제공하는 저수준 언어입니다. 메모리와 성능에 대한 이해는 C 프로그래밍의 핵심으로, 이를 통해 더 최적화된 코드를 작성할 수 있습니다. 이 문서에서는 C의 메모리 구조와 성능 최적화에 대한 기초를 설명합니다.

---

## 1. C 프로그램의 메모리 구조

C 프로그램은 실행 중 다음과 같은 메모리 영역을 사용합니다:

### 1.1 텍스트 영역 (Text Segment)
- 프로그램의 실행 코드가 저장되는 영역
- 읽기 전용으로 설정되어 있어 실행 중 코드 수정이 불가능함

### 1.2 데이터 영역 (Data Segment)
- 초기화된 전역 변수와 정적 변수가 저장됨
- 프로그램 시작 시 메모리에 로드되고 종료 시까지 유지

### 1.3 BSS 영역 (BSS Segment)
- 초기화되지 않은 전역 변수와 정적 변수가 저장됨
- 프로그램 시작 시 0으로 초기화됨

### 1.4 힙 (Heap)
- 동적 메모리 할당에 사용되는 메모리 영역
- `malloc`, `calloc`, `realloc`으로 할당하고 `free`로 해제

### 1.5 스택 (Stack)
- 함수 호출 시 지역 변수와 매개변수 저장
- 함수가 호출될 때 메모리가 할당되고, 함수가 종료되면 해제됨
- LIFO(Last In First Out) 구조를 따름

#### 메모리 구조 다이어그램
```
높은 주소
+------------------+
|      스택        |
|        ↓         |
|                  |
|        ↑         |
|       힙         |
+------------------+
|       BSS        |
+------------------+
|      데이터      |
+------------------+
|      텍스트      |
+------------------+
낮은 주소
```

---

## 2. 메모리 관리

C에서는 메모리를 직접 관리해야 하므로 효율적인 메모리 사용이 중요합니다.

### 2.1 동적 메모리 할당

#### `malloc`
- 지정된 크기의 메모리를 할당하고, 초기화되지 않은 상태로 반환
- 성공 시 메모리 주소를 반환하고, 실패 시 `NULL` 반환

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr = (int *)malloc(5 * sizeof(int));
    if (arr == NULL) {
        printf("메모리 할당 실패\n");
        return 1;
    }

    for (int i = 0; i < 5; i++) {
        arr[i] = i + 1;
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);
    return 0;
}
```

#### `calloc`
- 요소 개수와 크기를 지정하여 메모리를 할당하고, 0으로 초기화

#### `realloc`
- 기존에 할당된 메모리의 크기를 조정

#### `free`
- 동적 메모리를 해제

### 2.2 메모리 누수 (Memory Leak)

메모리 누수는 할당된 메모리를 해제하지 않아 사용 불가능한 상태로 남는 문제를 말합니다. 이를 방지하려면:
1. 모든 동적 메모리를 사용 후 반드시 해제
2. 동적 메모리를 추적하기 위해 디버깅 도구 사용 (예: Valgrind)

---

## 3. 성능 최적화

### 3.1 시간 복잡도와 공간 복잡도
- 시간 복잡도: 코드 실행 시간이 입력 크기에 따라 어떻게 증가하는지를 측정
- 공간 복잡도: 프로그램이 사용하는 메모리 크기를 나타냄

### 3.2 캐시 친화적 프로그래밍
- 배열과 같은 데이터 구조를 사용하여 데이터 접근을 최적화
- 예를 들어, 2D 배열 접근 시 행 우선 접근을 권장

#### 예제: 캐시 효율적인 배열 접근
```c
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        process(matrix[i][j]);
    }
}
```

### 3.3 불필요한 계산 제거
- 중복 계산을 피하고 결과를 저장하는 방식 (메모이제이션) 활용

### 3.4 적절한 데이터 타입 사용
- 메모리와 성능을 고려해 필요한 만큼의 크기를 가지는 데이터 타입 선택

#### 예: 적절한 데이터 타입 선택
```c
short count = 0;  // 작은 범위의 숫자를 다룰 때
float distance = 3.14f;  // 부동소수점 연산 시
```

---

## 4. 디버깅과 성능 분석

### 4.1 디버깅 도구
- **gdb**: 코드 실행 중단 및 변수 상태 확인
- **Valgrind**: 메모리 누수와 비정상 메모리 접근 디버깅

### 4.2 성능 분석 도구
- **gprof**: 코드의 실행 시간 및 함수 호출 빈도 분석
- **Perf**: 시스템 성능 분석

### 4.3 로그와 프로파일링
- 프로그램의 주요 동작을 로그로 기록하여 성능 문제를 파악
- 프로파일링 도구를 활용하여 병목 현상 확인

---

이 문서는 메모리 관리와 성능 최적화에 대한 기본적인 이해를 돕기 위해 작성되었습니다. 메모리와 성능은 C 프로그래밍에서 중요한 영역으로, 이를 잘 다루는 것이 고급 프로그래밍의 핵심입니다.

