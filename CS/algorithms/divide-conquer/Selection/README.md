# Selection Algorithm

## 개요
Selection Algorithm은 주어진 배열에서 k번째 작은 원소(k-th smallest element) 또는 특정 순위(order statistic)를 효율적으로 찾는 알고리즘입니다.  
이 문제는 정렬 전체를 수행하지 않고도 원하는 순위의 원소만을 찾을 수 있기 때문에, 데이터 분석, 통계, 그리고 다양한 최적화 문제에서 유용하게 사용됩니다.

## 알고리즘의 핵심 아이디어
- **QuickSelect:**  
  가장 대표적인 Selection Algorithm은 QuickSelect로, QuickSort와 유사한 분할 정복 방식을 사용합니다.
  - **분할(Partitioning):**  
    배열에서 임의의 피벗(pivot)을 선택한 후, 피벗을 중심으로 배열을 두 부분으로 나눕니다.
    - 피벗보다 작은 원소들이 왼쪽에, 피벗보다 큰 원소들이 오른쪽에 위치합니다.
  - **재귀적 선택:**  
    피벗의 최종 위치가 k와 일치하면, 피벗이 k번째 작은 원소입니다.
    - 만약 k가 피벗의 인덱스보다 작으면 왼쪽 부분 배열에서, k가 크면 오른쪽 부분 배열에서 재귀적으로 선택 문제를 해결합니다.

## 시간 및 공간 복잡도
- **평균 시간 복잡도:** O(n)  
  피벗이 균형 있게 분할되는 경우, 전체 평균 시간 복잡도는 선형 시간에 가까워집니다.
- **최악의 시간 복잡도:** O(n²)  
  최악의 경우(예: 항상 최악의 피벗 선택)에는 시간 복잡도가 n²까지 증가할 수 있으나, 일반적으로 무작위 피벗 선택이나 피벗 선택 전략을 개선하여 이를 완화할 수 있습니다.
- **공간 복잡도:**  
  재귀적 구현의 경우, 호출 스택에 따른 추가 공간이 필요하지만 평균적으로 O(1) 또는 O(log n)의 공간만 추가로 사용됩니다.

## 장점 및 단점
- **장점:**  
  - 전체 배열을 정렬할 필요 없이 k번째 작은 원소만 효율적으로 찾을 수 있습니다.
  - 평균적인 경우 매우 빠른 선형 시간에 문제를 해결할 수 있습니다.
- **단점:**  
  - 최악의 경우 시간 복잡도가 O(n²)로 증가할 수 있으며, 이를 피하기 위해 피벗 선택 전략에 주의를 기울여야 합니다.
  - 재귀 호출에 의존하는 구현에서는 스택 오버플로우의 가능성을 고려해야 합니다.

## 활용 사례
- **중앙값(Median) 계산:**  
  배열의 중앙값을 찾기 위해 Selection Algorithm을 사용하면 전체 정렬 없이도 효율적으로 계산할 수 있습니다.
- **순위 기반 통계:**  
  데이터 집합에서 특정 순위의 값(예: 상위 10% 또는 하위 10%)을 빠르게 찾는 데 유용합니다.
- **최적화 문제:**  
  다양한 최적화 및 의사 결정 문제에서 부분적으로 정렬된 순서를 기반으로 한 선택 과정에 적용할 수 있습니다.

## 참고 자료
- [Wikipedia - Quickselect](https://en.wikipedia.org/wiki/Quickselect)
- [GeeksforGeeks - Selection Algorithms](https://www.geeksforgeeks.org/selection-algorithms/)
- 관련 알고리즘 서적 및 학술 자료