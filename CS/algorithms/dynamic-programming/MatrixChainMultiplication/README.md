# 행렬 체인 곱셈 (Matrix Chain Multiplication)

## 개요
행렬 체인 곱셈 문제는 여러 개의 행렬을 순서대로 곱할 때, 곱셈 연산의 총 비용(스칼라 곱셈의 수)을 최소화하는 최적의 괄호 배치를 찾는 문제입니다.  
각 행렬의 곱셈은 결합 법칙이 성립하지만, 곱셈 순서에 따라 계산 비용이 크게 달라지므로, 효율적인 계산 순서를 찾는 것이 핵심입니다.

## 문제 설명
- **입력:**  
  - n개의 행렬 A₁, A₂, ..., Aₙ  
  - 각 행렬 Aᵢ의 크기는 p[i-1] x p[i]로 주어지며, 행렬 곱셈이 가능한 조건을 만족합니다.
- **목표:**  
  - 행렬 곱셈의 전체 계산 비용(스칼라 곱셈 연산의 수)을 최소화하는 괄호 배치를 찾습니다.
  
예를 들어, 행렬 A (10x30), B (30x5), C (5x60)의 경우  
- (A×B)×C는 10×30×5 + 10×5×60 = 1500 + 3000 = 4500번의 곱셈 연산이 필요하고,  
- A×(B×C)는 30×5×60 + 10×30×60 = 9000 + 18000 = 27000번의 곱셈 연산이 필요합니다.  
따라서, (A×B)×C가 최적의 순서입니다.

## 알고리즘의 핵심 아이디어
동적 계획법(Dynamic Programming)을 이용하여 문제를 해결합니다:
- **상태 정의:**  
  dp[i][j]는 행렬 Aᵢ부터 Aⱼ까지의 곱셈에 필요한 최소 연산 수를 나타냅니다.
  
- **점화식:**  
  dp[i][j] = min { dp[i][k] + dp[k+1][j] + (p[i-1] × p[k] × p[j]) }  
  for all i ≤ k < j.
  
- **기저 사례:**  
  dp[i][i] = 0 (단일 행렬의 경우 곱셈이 필요 없으므로)

이 방식은 모든 가능한 분할 지점을 고려하여 최적의 해답을 찾으며,  
최종적으로 dp[1][n] (또는 0-based index의 경우 dp[0][n-1])이 전체 행렬 곱셈의 최소 비용이 됩니다.

## 시간 및 공간 복잡도
- **시간 복잡도:** O(n³)  
  (n은 행렬의 개수, 3중 반복문을 사용하여 모든 가능한 분할 지점을 탐색)
- **공간 복잡도:** O(n²)  
  DP 테이블을 저장하기 위해 n×n 크기의 2차원 배열이 필요

## 응용 분야
- **최적화 문제:**  
  행렬 곱셈 순서를 최적화하여 계산 비용을 줄이는 문제는, 수치해석, 컴퓨터 그래픽스, 기계 학습 등에서 중요합니다.
- **동적 계획법 연습:**  
  복잡한 DP 문제의 전형적인 예제로서, 문제 해결 및 알고리즘 설계 능력을 향상시키는 데 도움을 줍니다.

## 참고 자료
- [Wikipedia - Matrix Chain Multiplication](https://en.wikipedia.org/wiki/Matrix_chain_multiplication)
- [GeeksforGeeks - Matrix Chain Multiplication](https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/)
- 관련 알고리즘 서적 및 학술 자료