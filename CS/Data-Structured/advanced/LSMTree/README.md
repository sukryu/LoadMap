# LSM Tree 자료구조 📚📝

LSM Tree (Log-Structured Merge-Tree)는 높은 쓰기 성능과 효율적인 디스크 I/O를 목표로 설계된 자료구조입니다.  
대량의 데이터 삽입과 빠른 배치 처리가 필요한 시스템에서 주로 활용되며,  
메모리 내 임시 저장소(메모테이블)와 디스크 기반 정렬 파일(SSTable)을 결합하여 운영됩니다.

---

## 목차 📝
1. [개요](#개요-🧐)
2. [LSM Tree의 정의와 특징](#lsm-tree의-정의와-특징)
3. [메모리 구조 및 다이어그램](#메모리-구조-및-다이어그램-🖼️)
4. [주요 연산](#주요-연산-🛠️)
5. [장단점](#장단점-⚖️)
6. [실무 활용 예시](#실무-활용-예시-💼)
7. [참고 자료](#참고-자료-🔗)

---

## 개요 🧐
LSM Tree는 로그 구조를 활용한 자료구조로,  
데이터 삽입 시 우선 메모리 내 메모테이블에 기록하고,  
일정 크기 도달 시 이를 디스크에 순차적으로 기록하여 SSTable을 생성합니다.  
이후 주기적인 컴팩션(compaction) 과정을 통해 여러 SSTable을 병합하여 정렬 상태와 효율성을 유지합니다.

---

## LSM Tree의 정의와 특징
- **정의**:  
  LSM Tree는 **Log-Structured Merge Tree**의 약자로,  
  쓰기 작업의 효율성을 극대화하기 위해 데이터를 메모리에서 임시 저장한 후,  
  디스크에 순차적으로 기록하고 배치 처리하는 구조입니다.
  
- **특징**:
  - **빠른 쓰기 성능**:  
    메모테이블에 우선 기록하여 빠른 데이터 삽입이 가능합니다.
  - **순차 디스크 I/O**:  
    플러시(Flush) 시 순차적으로 데이터를 디스크에 기록하여 I/O 효율을 높입니다.
  - **주기적 컴팩션**:  
    여러 SSTable 파일을 병합하여 중복 데이터 및 삭제된 항목을 제거하고, 정렬된 상태를 유지합니다.
  - **읽기 증폭(Read Amplification)**:  
    여러 레벨의 SSTable을 검색해야 하므로, Bloom Filter 등의 기법으로 보완합니다.

---

## 메모리 구조 및 다이어그램 🖼️
LSM Tree는 크게 두 부분으로 구성됩니다:
1. **메모테이블 (Memtable)**:  
   메모리 내에 존재하며, 삽입 및 업데이트 작업을 빠르게 처리합니다.
2. **SSTable**:  
   디스크에 저장된 정렬된 데이터 파일로,  
   메모테이블의 데이터가 플러시되어 생성되며,  
   여러 레벨로 구성되어 주기적인 컴팩션 과정을 거칩니다.

```mermaid
flowchart TD
    A[메모테이블<br>(In-Memory)]
    B[SSTable Level 0<br>(디스크)]
    C[SSTable Level 1<br>(디스크)]
    D[SSTable Level 2<br>(디스크)]
    A -->|Flush| B
    B -->|Compaction| C
    C -->|Compaction| D
```

---

## 주요 연산 🛠️
- **삽입 (Insertion)**:  
  - 데이터는 먼저 메모테이블에 삽입됩니다.
  - 메모테이블의 크기가 임계값을 초과하면, 디스크의 SSTable로 플러시됩니다.

- **검색 (Search)**:  
  - 우선 메모테이블에서 데이터를 검색하며,  
  - 없을 경우 여러 SSTable을 대상으로 Bloom Filter 등을 활용해 검색합니다.

- **삭제 (Deletion)**:  
  - 삭제는 tombstone(삭제 마커)을 기록하여 처리되며,  
  - 컴팩션 과정에서 실제 데이터에서 제거됩니다.

- **컴팩션 (Compaction)**:  
  - 여러 SSTable 파일을 병합해 중복 및 삭제된 항목을 제거하고,  
  - 정렬 상태를 유지하며 디스크 공간을 최적화합니다.

---

## 장단점 ⚖️

### 장점 👍
- **높은 쓰기 처리량**:  
  메모리 기반의 빠른 삽입과 순차 디스크 기록을 통해 높은 쓰기 성능을 제공합니다.
- **디스크 I/O 효율성**:  
  순차적인 쓰기 방식으로 랜덤 디스크 접근 비용을 줄입니다.
- **배치 처리**:  
  컴팩션을 통해 여러 파일을 효과적으로 병합, 정리할 수 있습니다.

### 단점 👎
- **읽기 증폭(Read Amplification)**:  
  여러 SSTable을 검색해야 하는 경우, 읽기 성능이 저하될 수 있습니다.
- **컴팩션 오버헤드**:  
  백그라운드 컴팩션 작업이 추가적인 리소스를 소모합니다.
- **복잡한 관리**:  
  여러 레벨의 SSTable 관리 및 컴팩션 정책 설계가 복잡할 수 있습니다.

---

## 실무 활용 예시 💼
- **키-값 저장소**:  
  LevelDB, RocksDB, Cassandra 등에서 높은 쓰기 성능을 위해 활용됩니다.
- **로그 관리 시스템**:  
  대량의 로그 데이터를 효율적으로 저장하고 검색하는 시스템에서 사용됩니다.
- **분산 데이터베이스**:  
  대규모 데이터 삽입과 관리를 필요로 하는 시스템에서 핵심 구조로 채택됩니다.

---

## 참고 자료 🔗
- [LSM Tree - Wikipedia](https://en.wikipedia.org/wiki/Log-structured_merge-tree)
- [Understanding LSM Trees](https://www.cockroachlabs.com/blog/lsm-architecture/)
- [LSM Trees in Modern Databases](https://www.sciencedirect.com/science/article/pii/S1570866718300505)

---

LSM Tree의 구조와 동작 원리를 이해하면,  
대용량 데이터 처리와 높은 쓰기 부하가 요구되는 환경에서 효과적인 데이터 관리 솔루션을 설계할 수 있습니다.