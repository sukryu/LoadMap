# Bw Tree 자료구조 📚🗂️

Bw Tree는 높은 동시성 환경과 인메모리 데이터베이스를 위해 설계된 락-프리(무잠금) B-트리 계열의 인덱스 자료구조입니다.  
전통적인 B-트리와 달리, Bw Tree는 물리적 포인터 대신 매핑 테이블과 델타 레코드를 활용하여 데이터 수정 이력을 관리하며,  
원자적 연산(atomic CAS 등)을 통해 락 없이도 안전한 동시 접근을 보장합니다.

---

## 목차 📝
1. [개요](#개요-🧐)
2. [Bw Tree의 정의와 특징](#bw-tree의-정의와-특징)
3. [메모리 구조 및 다이어그램](#메모리-구조-및-다이어그램-🖼️)
4. [주요 연산](#주요-연산-🛠️)
5. [장단점](#장단점-⚖️)
6. [실무 활용 예시](#실무-활용-예시-💼)
7. [참고 자료](#참고-자료-🔗)

---

## 개요 🧐
Bw Tree는 인메모리 환경에서 고성능 동시성 인덱싱을 목표로 하는 락-프리 자료구조입니다.  
매핑 테이블(mapping table)과 델타 레코드(delta record)를 사용하여,  
데이터 변경 사항을 로그 형식으로 기록하고 주기적으로 병합(consolidation)함으로써,  
잠금 없이도 안전하게 다중 스레드의 읽기/쓰기 작업을 지원합니다.

---

## Bw Tree의 정의와 특징
- **정의**:  
  Bw Tree는 전통적인 B-트리 구조를 기반으로 하면서,  
  물리적 포인터 대신 논리적 매핑 테이블을 활용해 노드의 위치를 관리하고,  
  모든 수정 연산(삽입, 삭제, 업데이트)은 델타 레코드로 기록되어  
  주기적인 병합 작업을 통해 정리되는 락-프리 인덱스입니다.
  
- **특징**:
  - **락-프리 동시성**:  
    원자적 연산(예: CAS)을 사용하여, 락 없이 여러 스레드가 동시에 접근할 수 있습니다.
  - **매핑 테이블 기반 관리**:  
    노드 포인터 대신 매핑 테이블을 사용해, 노드 변경 시 일관성을 유지합니다.
  - **델타 레코드**:  
    모든 수정 사항을 델타 레코드로 기록하여, 실제 노드 구조를 변경하지 않고도 빠른 업데이트가 가능합니다.
  - **주기적 병합(consolidation)**:  
    델타 레코드들이 누적되면, 이를 주기적으로 병합하여 트리의 구조를 최적화합니다.

---

## 메모리 구조 및 다이어그램 🖼️
Bw Tree의 메모리 구조는 크게 두 부분으로 나뉩니다:
1. **매핑 테이블**:  
   각 논리적 페이지(노드)의 위치를 실제 메모리 주소와 연결하여 관리합니다.
2. **델타 레코드 체인**:  
   각 노드에 대한 수정 사항(삽입, 삭제, 업데이트)이 델타 레코드 형태로 기록되며,  
   누적된 델타 레코드들은 주기적으로 병합되어 기본 노드(base node)를 갱신합니다.

```mermaid
flowchart TD
    A[매핑 테이블]
    B[기본 노드(Base Node)]
    C[델타 레코드 1]
    D[델타 레코드 2]
    E[델타 레코드 3]
    A --> B
    B --> C
    C --> D
    D --> E
```

---

## 주요 연산 🛠️
- **삽입 (Insertion)**:  
  새 키-값 쌍은 해당 노드의 델타 레코드로 기록되며,  
  매핑 테이블을 통해 논리적 위치를 관리합니다.
  
- **삭제 (Deletion)**:  
  삭제 연산 역시 델타 레코드로 기록되어,  
  기존 데이터에 대한 삭제 마커를 남기고 주기적 병합 시 실제 삭제가 반영됩니다.
  
- **검색 (Search)**:  
  매핑 테이블을 기반으로 노드를 찾아,  
  기본 노드와 누적된 델타 레코드를 순차적으로 적용하여 최신 상태의 값을 반환합니다.
  
- **병합 (Consolidation)**:  
  누적된 델타 레코드가 일정 임계치를 넘으면,  
  이를 병합하여 기본 노드를 갱신하고, 매핑 테이블을 업데이트합니다.

---

## 장단점 ⚖️

### 장점 👍
- **높은 동시성**:  
  락-프리 설계로 다중 스레드 환경에서 효율적인 동시 접근을 지원합니다.
- **빠른 업데이트**:  
  델타 레코드를 통한 비파괴적 수정으로 빠른 쓰기 성능을 제공합니다.
- **메모리 효율성**:  
  매핑 테이블과 델타 레코드를 활용하여, 필요 시에만 노드 병합을 수행함으로써  
  불필요한 메모리 복사를 줄입니다.

### 단점 👎
- **복잡한 구현**:  
  매핑 테이블, 델타 레코드, 그리고 주기적 병합 등의 관리 로직이 복잡합니다.
- **병합 오버헤드**:  
  델타 레코드가 누적될 경우 병합 작업으로 인한 오버헤드가 발생할 수 있습니다.
- **디버깅 어려움**:  
  락-프리 및 비파괴적 수정 방식은 디버깅 및 테스트가 상대적으로 어렵습니다.

---

## 실무 활용 예시 💼
- **인메모리 데이터베이스**:  
  SQL Server의 인메모리 OLTP 엔진 등, 높은 동시성 환경에서 사용됩니다.
- **고성능 캐시 시스템**:  
  락 없이 빠른 검색 및 업데이트가 필요한 캐시 인덱스로 활용됩니다.
- **실시간 분석 시스템**:  
  대량의 데이터 업데이트와 빠른 쿼리 처리가 요구되는 시스템에서 채택됩니다.

---

## 참고 자료 🔗
- [Bw-Tree: A Latch-Free B-Tree](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2007-144.pdf)
- [High Performance Concurrency Control Mechanisms for Main-Memory Databases](https://www.microsoft.com/en-us/research/publication/high-performance-concurrency-control-mechanisms-for-main-memory-databases/)
- [Bw-Tree 관련 기술 자료 및 발표 자료](https://www.microsoft.com/en-us/research/)

---

Bw Tree의 구조와 알고리즘을 이해하면,  
고성능 인메모리 데이터베이스 및 동시성 집약적 응용 프로그램에서  
락 없이 빠른 검색과 업데이트, 그리고 효율적인 인덱스 관리를 구현할 수 있습니다.