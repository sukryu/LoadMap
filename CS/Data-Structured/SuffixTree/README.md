# 접미사 트리 (Suffix Tree) 🌳🔍

접미사 트리는 주어진 문자열의 모든 접미사를 포함하는 트리 구조로,  
각 경로가 문자열의 한 접미사를 나타내며, 리프 노드에는 해당 접미사의 시작 인덱스가 저장됩니다.  
이 자료구조는 패턴 매칭, 중복 서브스트링 탐색, 최장 공통 서브스트링(LCS) 찾기 등  
다양한 문자열 문제를 효율적으로 해결할 수 있도록 도와줍니다.

---

## 목차 📝
1. [개요](#개요-🧐)
2. [접미사 트리의 정의 및 특징](#접미사-트리의-정의-및-특징-🔍)
3. [메모리 구조 및 다이어그램](#메모리-구조-및-다이어그램-🖼️)
4. [주요 연산](#주요-연산-🛠️)
5. [장단점](#장단점-⚖️)
6. [실무 활용 예시](#실무-활용-예시-💼)
7. [참고 자료](#참고-자료-🔗)

---

## 개요 🧐
접미사 트리는 문자열 S의 모든 접미사를 트리 구조로 저장하여,  
특정 패턴의 존재 여부나 위치를 빠르게 판별할 수 있도록 설계된 자료구조입니다.  
효율적인 패턴 매칭과 중복 서브스트링 분석을 통해,  
텍스트 검색, 압축, 생물정보학 등 다양한 분야에서 활용됩니다.

---

## 접미사 트리의 정의 및 특징 🔍
- **정의**:  
  주어진 문자열 S에 대해, S의 모든 접미사를 포함하는 트리입니다.  
  각 경로는 문자열의 한 접미사를 나타내며, 리프 노드는 해당 접미사의 시작 인덱스를 저장합니다.
  
- **특징**:
  - **빠른 패턴 매칭**: 패턴 P가 S에 존재하는지 O(m) 시간(단, m은 P의 길이)에 판별할 수 있습니다.
  - **중복 서브스트링 분석**: 문자열 내 반복되는 서브스트링을 효율적으로 찾을 수 있습니다.
  - **압축 저장**: 접미사 트리는 일반적으로 간접적으로 경로 압축을 수행하여, 메모리 사용을 최적화할 수 있습니다.
  - **구현 복잡성**: 효율적인 접미사 트리 알고리즘(예: Ukkonen의 알고리즘)은 구현이 복잡하지만,  
    빠른 질의 성능을 보장합니다.

---

## 메모리 구조 및 다이어그램 🖼️
접미사 트리는 각 노드가 문자열의 일부(엣지 레이블)를 나타내며,  
루트부터 리프까지의 경로가 하나의 접미사를 구성합니다.  
리프 노드에는 해당 접미사의 시작 인덱스가 저장됩니다.

```mermaid
flowchart TD
    A[루트]
    B["an"a (접미사, 인덱스 2)]
    C["ana" (접미사, 인덱스 1)]
    D["banana" (접미사, 인덱스 0)]
    E["na" (접미사, 인덱스 4)]
    F["nana" (접미사, 인덱스 3)]

    A --> D
    A --> C
    A --> B
    A --> F
    A --> E
```

(위 다이어그램은 개념을 단순화한 예시입니다. 실제 트리는 접미사 간의 공통 접두사를 공유하는 방식으로 구성됩니다.)

---

## 주요 연산 🛠️
- **구성 (Construction)**:  
  Ukkonen의 알고리즘 등으로 접미사 트리를 O(n) 또는 O(n log n) 시간에 구축할 수 있습니다.
- **패턴 매칭 (Pattern Matching)**:  
  주어진 패턴 P에 대해, 루트부터 내려가며 P가 존재하는 경로를 O(m) 시간에 찾을 수 있습니다.
- **중복 서브스트링 탐색**:  
  트리 내 공통 경로를 분석하여 반복되는 서브스트링을 효율적으로 찾을 수 있습니다.
- **최장 공통 서브스트링 (LCS)**:  
  두 문자열 간의 접미사 트리를 구성하거나, LCP 배열과 결합하여 LCS를 빠르게 찾을 수 있습니다.

---

## 장단점 ⚖️

### 장점 👍
- **빠른 질의 성능**: 패턴 검색, 서브스트링 탐색 등이 매우 효율적입니다.
- **포괄적 정보**: 모든 접미사를 저장하므로, 다양한 문자열 분석이 가능합니다.
- **알고리즘 응용**: 최장 공통 서브스트링, 반복 서브스트링 등 고급 문자열 문제 해결에 유용합니다.

### 단점 👎
- **높은 메모리 사용**: 모든 접미사를 저장하므로, 긴 문자열의 경우 메모리 사용량이 많을 수 있습니다.
- **구현 복잡성**: 효율적인 알고리즘(예: Ukkonen의 알고리즘)은 구현이 매우 복잡합니다.
- **갱신 어려움**: 문자열 변경 시 전체 트리 재구성이 필요합니다.

---

## 실무 활용 예시 💼
- **텍스트 검색 엔진**: 대용량 텍스트 데이터에서 빠른 패턴 매칭을 위한 인덱스 구축.
- **데이터 압축**: 문자열 내 반복되는 패턴을 분석하여 압축 효율을 높임.
- **생물정보학**: 유전체 데이터의 서열 분석, 서열 유사도 계산에 활용.
- **자연어 처리**: 문서 내 서브스트링 빈도 분석, 키워드 추출 등.

---

## 참고 자료 🔗
- [Suffix Tree - Wikipedia](https://en.wikipedia.org/wiki/Suffix_tree)
- [Ukkonen's Algorithm](https://www.cs.helsinki.fi/u/ukkonen/SuffixT1.ps)
- [GeeksforGeeks - Suffix Tree](https://www.geeksforgeeks.org/suffix-tree-introduction/)
- [Baekjoon Online Judge](https://www.acmicpc.net/)

접미사 트리의 원리와 알고리즘을 이해하면,  
복잡한 문자열 검색 및 분석 문제를 빠르고 효율적으로 해결할 수 있습니다.  
```